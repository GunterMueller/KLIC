% (C) 1998 Japan Information Processing Development Center
% 詳細な配布条件については、COPYRIGHT-JIPDEC.jを参照してください。
\chapter{ジェネリック・オブジェクト}
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト}

\section{ジェネリック・オブジェクトの概略}%1-1

ジェネリック・ オブジェクトとして実現されたデータは、
単一化 や GC など
様々な局面での自分自身の処理の仕方を記述したメソッドを集めた
メソッド表、及びデータ領域から成る。
このメソッド表がオブジェクトのクラス定義に当たるものである。

ユーザはメソッド表に含めるべきメソッド、オブジェクト生成のための
ルーチン、データ領域の構成などを、ジェネリック・オブジェクト定義用
に作成したマクロや関数
% ( 以後、これをオブジェクト定義用マクロセットと呼ぶ )
を使用しつつ、C言語で記述することで、
ジェネリック・オブジェクトを定義する。
ジェネリック・オブジェクトのデータ領域は KL1 の組み込みデータ型
や C で定義可能なデータ型から構成することが可能であり、
様々なデータをジェネリック・オブジェクトに持たせることが出来る。
%また、ジェネリック・オブジェクトは入れ子構造にすることが可能である、
%つまり、あるジェネリック・オブジェクトのデータ領域を、
%別のジェネリック・オブジェクトを使って定義したり、
%ジェネリック・オブジェクトに関する様々な処理の局面で、
%別のジェネリック・オブジェクトを使用したりすることが可能である。

ジェネリック・オブジェクトの定義に当たっては、
 KLIC システムの実行時カーネルに関する完全な知識は必要とせず、
ジェネリック・オブジェクト定義時には、実行時カーネルには一切手を入れる
必要はないように設計がなされている。
KLIC の組み込みデータ型のデータが
 KLIC システムの実行時カーネルによって処理されるのに対し、
ジェネリック・オブジェクト型のデータに対しては、
実行時カーネルがそのメソッド表を参照して適切な処理を呼びだす。
実行時カーネルは、ジェネリック・オブジェクトのメソッドの中身やデータ領域の
構成については特に仮定を置いておらず、これらの点について
ユーザはかなり自由に
%定義することにより
KLICを拡張することができる
\footnote{もちろん、あるデータがジェネリック・オブジェクトかどうかの
判定は出来る。また、そのジェネリック・オブジェクトが、後述する3種類
の内のどの種類のジェネリック・オブジェクトかの判定も出来る。}。
%処理中に、扱い方を知らないジェネリック・オブジェクトを扱わなくては
%いけない場面になった実行時カーネルは、そのジェネリック・オブジェクトの
%然るべきメソッドを呼び出すことで、ジェネリック・オブジェクトに
%処理を任せる

ジェネリック・オブジェクトはこのように定義の記述に大きな自由度があり、
また、処理実行の面や定義記述の面で実行時カーネルから独立しているので、
言語システムの高い拡張性を実現するものになっている。

\subsection{ジェネリック・オブジェクトの種類}%2-1
ジェネリック・オブジェクトは
実行時カーネルから見た場合、(少なくとも top level について)、
以下のように分類できる。

\begin{itemize}
\item 具体化されているデータ

\item 値が決定すれば、行われる計算が決められている変数(ゴールを
フックしている変数に類似)

\item 値が必要なら、値を求める方法が定められている変数
\end{itemize}

分類の各々に応じて、以下の呼ばれるオブジェクトの種別が用意されている。

\begin{description}
\item [Data object] 具体化されているデータと同様の扱い
を行うべき オブジェクト である。
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト!data}

\item [Consumer object] 値が決められればそれに応じて計算が行われる
オブジェクト である。
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト!consumer}
\begin{itemize}
\item 書き込みを行うことにより、なにか処理が行われる。

\item 読み出すことによってはなにも処理は行われない。純粋未定義変数と
等価の動作をする変数。
\end{itemize}

\item [Generator object] 今までのKL1処理系には (少なくとも
言語表面には ) なかったデータ型。
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト!generator}
\begin{itemize}
\item 書き込みを行うことにより、なにか処理が行われる
(Consumer objectと共通)。

\item 読み出すことによって、何か値を決めるための処理が行われる。
\end{itemize}

つまり、generator は  cosumer を包含した機能を持つものである。

\end{description}

メソッド表の構成、他の(つまり、通常のKL1の)データ構造との関係は、
これら3種類で各々異る。 

%なお、consumer, generatorは、言語表層上では、あくまで「未定義変数」であり、
%具体値ではない。
%よって、「未定義変数」には、純粋未定義変数以外に、これらのobjectも含まれる。
%さらに、
%次章で述べる「中断要因となっている未定義変数」も未定義変数である。
%言語上は「未定義変数」となるデータ構造についての実装の一覧を
%図ref{variables}に挙げる。

%\begin{figure}
%\begin{center}
%\[
%未定義変数 \left\{
%   \begin{array}{l}
%   読み書きどちらに対しても具体化/中断のみで
%               計算は起こらない \ldots 純粋未定義変数\\
%   書き込むと計算 \left\{ \begin{array}{l}
%                           中断ゴール\\
%                           Consumer
%                          \end{array} \right.\\
%   読み込むと計算 \ldots Generator
%   \end{array} \right.
%\]
%\end{center}
%\caption{未定義変数の分類}
%\label{variables}
%\end{figure}

\subsection{Data object}
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト!data}
Data objectについては浮動小数点型を実装するために用いられている
floatクラスのオブジェクトを例として説明する(\filename{gfloat.c})

Data objectに関しては\incfilename{gdobject.h}, 
\incfilename{gd\_macro.h}
中に定義されたマクロを用いて記述する。

\begin{description}
\item[データ構造:\ ] Float型は、基本的に、

\begin{verbatim}
struct {
  struct data_object_method_table *method_table;
  double value;
};
\end{verbatim}
という型である。これを定義するのに、

\begin{verbatim}
GD_OBJ_TYPE {
  struct data_object_method_table *method_table;
  double value;
};
\end{verbatim}
とする。各々、メソッド表ポインタ、浮動小数点の値、である。

以下でメソッドの説明をする。データオブジェクトのメソッドは``GDDEF\_''
で開始されるマクロにより行われている。

\item [単一化:\ ]
KL1でデータに対して行う単一化操作は、汎用的なものとして、
以下の2つがある。

\begin{description}
\item[GUNIFY メソッド:\ ]
引数である他の data object と自分の passive unification を試みる。
メソッド実行の結果としては、成功、失敗、中断の3種類である。
それぞれの状態に対応する値
\footnote{中断の場合は中断原因の変数への参照}
をメソッドの返り値としている。

Float型では、まず、メソッドテーブル同士を同じかどうか比較し、
その後、value部分を比較している。

\item[UNIFY メソッド:\ ]
引数である他の object と自分の active unification を試みる。
メソッド実行の結果としては、成功、中断の2種類である。
失敗ならばGD\_GUNIFY\_FAIL により、abortする。
\end{description}

\item [印字:\ ]
実行時カーネルのプリントルーチンが Data object を発見した場合に呼びだされる。
次のメソッドを呼ぶ。

\begin{description}
\item[PRINT メソッド:\ ]
引数は、 UNIX の FILE構造体へのポインタ、
オブジェクトのプリントの深さや幅を示す値である。
その FILE 構造体へのポインタが示す UNIX のストリームに自分の印字内容を流す。

PRINTメソッドはGD\_RETURN\_FROM\_PRINTにてreturnする必要がある。
\end{description}

\item [GC:\ ]
GC時に生きているオブジェクトの(新領域への)コピーの仕方を記述した
メソッドである。実行時カーネルのGCルーチンがデータ
追跡中にジェネリック・オブジェクトを発見したときに利用される。
このメソッドがあるため、タグを持たない要素(例えば、floatのvalue部)
を持ったオブジェクトでも安心して作成することができる。
通常は、自分自身をコピーする。内部にKL1の項を持つ場合などは
再帰的にコピーさせる必要がある。

なお、KLICのGCは幅優先ではなく、深さ優先の順で
データのコピーを行う。よっていわゆる``scan''は行わず、
ジェネリック・オブジェクト内部で保持しているタグのないデータも
上手く扱うことができる。

メソッドでは、コピー先ヒープのヒープ割付点へのポインタを引数に持つ。
自分のサイズに従って、コピー先ヒープ上に領域を確保し(ヒープ割付点を進める)、
その自分をそこへコピーする。
メソッドの返り値はコピー後のヒープ割付点へのポインタを返す。

gfloatでは、value部が8byte alignされている必要がある場合が多いため、
alignを合せるためヒープを進めている。

\item [ジェネリック・メソッド:\ ] 
今までのメソッドは、基本的には実行時カーネルから直接呼び出され、
実行時カーネルが行うべき仕事を肩代りして行うために記述された
メソッドであった。これらのオブジェクトは実装されていることが必須である。

これらのメソッド
の他に、ユーザが自由に定義し、ジェネリック・オブジェクトを任意の時
点で任意に操作するための様々なメソッドが定義できる。
例えば、floatでは、各種の演算が行えなければ、
floatを実装する意味はあまりない。
このような、オブジェクトに依存するようなメソッドをジェネリック・メソッドと
呼ぶ。

ジェネリック・メソッドにはガード用とボディ用があり、
2 つ (1 つのジェネリック・オブジェクトクラス当たり 2 つ) のメソッドとして
実装される。
ジェネリック・メソッドを呼ぶ時には、そのメソッド群の中の 1 メソッド
を指定するメソッド記述子を引数として呼ぶことで、
実行したいメソッドを指定する。

\begin{description}
\item[body generic メソッド:\ ]
ボディ用のジェネリック・メソッドである。
引数は、メソッド記述子およびジェネリック・メソッド引数、
そしてヒープ割付点へのポインタである。

Body generic メソッドは、以下の2種より構成される。

\begin{itemize}
\item 様々な独立した処理を記述したメソッド。floatでは、
print\_1 とint\_1が定義されている。

\item 上記も含めた様々な処理にdispatchするためのメソッド。
つまり、コンパイルコードからはこのメソッドが直接的に呼びだされ、
dispatchを行い、必要であれば、上記個別処理に飛ぶようになっている。
\end{itemize}

前者はGDDEF\_METHOD(メソッド名\_アリティ)として定義される。
後者は、GDDEF\_GENERICにより定義される。floatの場合を例にして基本的な処理を
以下で説明する。

\begin{enumerate}
\item GD\_SWITCH\_ON\_METHOD なるマクロで、method名/アリティにより
dispatchされる。個別の処理(GDDEF\_METHODにより定義される処理)に
飛ぶ為には、このSWITCHの中でGD\_METHOD\_CASE(method名/アリティ) として
定義をしておく。
\item 残りについてdefault: で受け、
アリティでSWITCHするため、GD\_SWITCH\_ON\_ARITY
を用いる。

その結果、case 1(アリティが1)、 case 2(アリティが2)の場合で各々
GD\_SWITCH\_ON\_METHOD により再度dispatchしている。
その結果行うべき処理を
GD\_METHOD\_CASE\_DIRECTで記述する。別にGDDEF\_METHODに
より定義せずに、直接記述する(単順な処理の場合にはそのような
記述が適当であろう)場合にはこの記述が便利である。
\end{enumerate}

\item[guard generic メソッド:\ ]
ガード用のジェネリック・メソッドである。
この場合も、以下を除きbodyとほぼ同様である。

\begin{itemize}
\item 個々の処理のためにはGDDEF\_GMETHODマクロを利用する。

\item DispatchのためにはGDDEF\_GGENERICマクロを利用する。
その他、GD\_SWITCH\_ON\_GMETHOD, GD\_GMETHOD\_CASE などと記述する。
\end{itemize}

引数は、メソッド記述子およびジェネリック・メソッド引数である。
 このメソッドはガードゴールに相当する。
メソッドを実行した結果は成功/失敗/中断のいずれかになるが、
それは戻り値により表現する(GENERIC\_SUCCEEDED 成功、
GENERIC\_FAILED: 失敗、それ以外: 中断の原因となった変数への参照)。
詳細は\incfilename{generic.h} のguard\_genericマクロを参照のこと。
\end{description}

\item [new ルーチン:\ ]
メソッドは、既にヒープ上に生成されたジェネリック・オブジェクトのメソッド
表に登録されたものである。
メソッド表には、ジェネリック・オブジェクトを生成するためのメソッドを
含めず、new ルーチンとして、メソッド表とは別に、
各ジェネリック・オブジェクトに対して定義される。
何故なら、生成の時にはオブジェクトは存在せず、結果、
メソッド表へのポインタも存在しないためである。

new ルーチンは、ジェネリック・メソッドと同様に、コンパイルされた実行
時ルーチンから呼ばれ得るルーチンである。
また、newルーチンに引数としてデータを渡すことも可能である。
これを new ルーチン引数と呼ぶことにする。

このルーチンは引数として、newルーチン引数とそのサイズおよび
ヒープ割付点へのポインタを取る。
ヒープ上に領域を取り、そこにジェネリック・オブジェクトを生成する。
新たなヒープ割付点をルーチンの返り値として返す。
\end{description}

\subsection{Consumer object}
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト!consumer}

Consumer objectについては、マージャを例として説明する(\filename{gmerge.c})

Consumerオブジェクトを記述するに必要なマクロ群は
\incfilename{gc\_macro.h}に記述されている。また、マクロの名称は
一般的にはGC\_, またはGCDEF\_で開始されている。

\begin{description}
\item [単一化:\ ] 
consumer object は文字通り、データ消費者で、他からデータが送ら
れてきたら動き出す。%のが基本であり、他からの要求でデータを生産する
%ことはしない。
よって、自発的には実行を開始しようとしないので、
consumer object に対しては passive unification
は無意味である。よって、active unifyに対応する UNIFYメソッドしか存在ししない。

consumer object は
変数に フックしたゴール列である中断構造中のフック鎖の中に入っている。
通常の KL1 項とフックされた変数の active unify 時に、
鎖をたどっていった 実行時カーネルが consumer object を
見つけた場合に、このメソッドを呼び出す。

引数として、単一化対象の他のデータ、そしてヒープ割付点へのポインタを取
る。例えば、 merger の入力ストリームに vector を 単一化する時の
処理から分かるように、このメソッドの中身は通常かなり複雑なものになる。
メソッド実行の結果としては、成功、中断、GC要求の3種類である。
それぞれの状態に対応する値
\footnote{中断の場合は中断原因}
を大域変数を通して返す。
active unification には goal の エンキューを行うなど、
ヒープを消費する場合があるので、
メソッド引数として、ヒープ割付点へのポインタを持ち、
メソッドの返り値として、メソッド実行後の新たな
ヒープ割付点ポインタを返す。

GCDEF\_UNIFY()により定義される。ここで利用されている主な
マクロ群の解説を行う。

\begin{description}
\item[GC\_SWITCH\_ON\_TERM:\ ] 単一化対象項の型によりdispatchする。
引数はラベル名称。

\item[GC\_TRY\_TO\_ALLOC:\ ] 指定された分のデータをヒープに割りつける。
割付に失敗したらならば、そこでgc\_requestに飛ぶ。

\item[GC\_UNIFY:\ ] 2つの引数の項をその場で単一化する。

\item[GC\_KL1\_UNIFY:\ ] 2つの引数の項を単一化するゴールをエンキューする。
メモリが不足した時などに利用する。

\item[GC\_SELF:\ ] オブジェクト自身

\item[GC\_RETURN\_WITH\_HOOK:\ ] 再度フックされるべき項を返す。
\end{description}

\item [印字]
実行時カーネルのプリントルーチンが consumer object を印字する。
次のメソッドを呼ぶ。

\begin{description}
\item[print メソッド:\ ]
data object のprint メソッドと同様である。
\end{description}

\item [GC:\ ] 
GCに関しての処理は data object の時と同様である。
Hook関連の処理はkernelがやるため、自オブジェクト、および、
自分が参照している分のコピーだけを行えばよい。

\item [new ルーチン:\ ]
new ルーチンに関しても、data object と同様である。
\end{description}

\subsection{Generator object}
\index{じぇねりっく・おぶじぇくと@ジェネリック・オブジェクト!generator}

Generator については、% {\Large まだ書けていない。}
乱数発生器(\filename{random.c})を例として記述する。

\begin{description}
\item[単一化:\ ] 単一化については、generatorはactive unification用のものしか
持たない。
しかしながら、以下の2つのメソッドを定義することが可能であり、
特定のクラスとの単一化について、幅広い処理を行うことができるようになっている。

\begin{description}
\item[UNIFYメソッド:\ ] 単一化の対象となる
オブジェクトが渡される。
対象オブジェクト種別に対して処理を変更したり、
対象のオブジェクトに対しての操作を行ったりすることができる。
また、「遅延」を返すことが可能であり、遅延の時には次のgenerateメソッドが
呼びだされる。

「遅延」かどうかは、戻り値が0であるかどうかによる。0の場合は「遅延」である。
非ゼロの場合には、新しいヒープ割付点を示す。

\item[GENERATE:\ ] 文字通り、generaterオブジェクトを他のデータ型に
「変身」させるためのオブジェクト。
オブジェクトが関連付けられている変数の値が必要がゴールがあるときや、
active\_unifyが失敗したときなどに呼びだされる。

戻り値は3通りである。

\begin{description}
\item[makeref(0):\ ] メモリ不足等の理由により生成を中断した。再度、
generateメソッドが呼び出されることが期待される。

\item[makecons(0):\ ] 内部エラー。

\item[上記以外:\ ] 生成された項を示す。
\end{description}
\end{description}

乱数発生器の実装では、特に単一化の相手による処理の変更などは必要ないため、
UNIFYに対しては常に失敗を返し、GENERATEに対しては乱数をCARにもち、
CDRに生成器(つまり自分自身)を持つ新しいhookを入れたCONSを返す。

\item[印字:\ ] PRINTメソッドはこれまでと同様。

\item[GC:\ ] GCについてはこれまでと同様。

\item[NEW ルーチン:\ ] 
new ルーチンに関しては、これまでと同様である。
\end{description}

