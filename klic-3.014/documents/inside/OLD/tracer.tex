% (C) 1998 Japan Information Processing Development Center
% 詳細な配布条件については、COPYRIGHT-JIPDEC.jを参照してください。
\chapter{トレーサ}

\index{tracer}
\index{とれーさ@トレーサ}

トレーサは、 プログラムの動作状況をユーザに提示することによって、 プログ
ラムがユーザの想定したと同じ動作をしているかどうかをユーザに確かさせる
ことによって誤りを発見するための、 基本的なデバッグ・ツールである。

%KL1 のような高水準言語による並列プログラムにあっては、 プログラマは必ず
%しもプログラム動作の詳細までを指定しない。  たとえば、 複数のプロセスの
%実行順の詳細は指定せず、 計算の進行状況に応じて決定される。  このため、
%KL1 のためのトレーサは逐次型言語、 あるいは低レベルで動作を指定するよう
%な並列処理言語のためのトレーサとは、 かなり異なる仕様をもつことになる。

%第五世代計算機プロジェクトにおいては、 並列推論マシン PIM 上のオペレー
%ティング・システムPIMOSの一部として、 このような目的に沿ったトレーサの
%仕様と実現方式の研究が行われてきた。  しかし、 その実現方式には専用計
%算機上の KL1 の実装方式に依存した部分が大きく、 そのままの形で KLIC 用
%に実現することは困難であり、 効率や使い勝手の面でも不利が少なくない。

%そこで、 新たに KLIC の実現方式との親和性の良いトレース方式を設計し、 試
%験実装と試用を通してその技術を確立するのが本研究の目的である。

%\bArabicsection{本年度の目標と開発方針}

%本年度は KLIC の逐次核部分の実装技術の確立に合わせ、 逐次処理方式の実装
%に合った機能的で効率的なトレーサの実現を目標とする。  この逐次版トレー
%サの設計にあたっては、 提供機能を十分高いレベルに設定することによって、 
%将来の並列版のトレーサの原型として役立つものにするように心がける。

\section{機能概要}

KLICのトレーサは、概略以下
の機能を持つ。
\begin{itemize}
\item プログラムのステップ実行
\item トレース不要プログラム部分のトレースなし実行
\item 注目する述語にいたるまでのトレースなし実行
\item その他、 付随する諸機能
\end{itemize}
提供機能の一覧を表\ref{tracer-functions}に示す。
\index{とれーさ@トレーサ!きのういちらん@機能一覧}
\begin{table}[p]
\begin{tabular}{|l|l|l|l|} \hline 
コマンド名 & コマンド入力形式& 入力可能ポート& コマンドの意味\\ \hline \hline
Continue &{\tt <cr>,c}  & 全てのポート  & 対象となるゴールのトレースを続ける\\ 
Abort& {\tt a}  & 全てのポート  & 対象となるプログラムのトレースを止める \\ 
Skip&{\tt s}    & 全てのポート & 対象となるゴールのトレースを止める\\
Leap&{\tt l}    & 全てのポート & spyされたサブゴールが現れるまで、\\
        && &トレースの表示・入力を抑制する\\ 
Enable port&{\tt E} ~~ ポート名& 全てのポート& そのポートを観測する\\
Disable port&{\tt D} ~~ ポート名& 全てのポート& そのポートは観測しない\\
Leash port&{\tt L} ~~ ポート名& 全てのポート& そのポートでユーザからの入力待ちにする\\
Unleash port&{\tt U} ~~ ポート名& 全てのポート& そのポートでゴールの表示だけ行う\\ 
Trace&{\tt +}サブゴール番号 & REDUポート& そのサブゴールをトレース対象とする\\
Notrace&{\tt -}サブゴール番号 & REDUポート& そのサブゴールをトレース対象外とする\\
Toggle trace&サブゴール番号 & REDUポート& そのサブゴールをトレースフラグを反転する\\ 
Notrace default &n 述語 & 全てのポート & その述語をトレース対象外とする \\
Trace default&t 述語 & 全てのポート & その述語をトレース対象とする \\
Spy&{\tt S} 述語 & 全てのポート & その述語にスパイをかける\\
Nospy&{\tt N} 述語 & 全てのポート & その述語のスパイを外す\\ 
Set Print Depth&pd:引数 & 全てのポート & 表示する構造の深さの変更 \\
Set Print Length&pl:引数 & 全てのポート & 表示する構造の長さの変更 \\
Toggle Verbose print&pv      & 全てのポート & verboseモードへの切替え\\
Status query&=  & 全てのポート & 現在のパラメータの状況を表示\\
List Modules &lm        & 全てのポート & 全モジュールの表示\\
List Predicates&lp      & 全てのポート & 全述語の表示\\
Help&h,?        & 全てのポート & 全モジュールの表示\\ 
Queue&Q & 全てのポート & ゴールプール内のゴールの表示\\ \hline
\end{tabular}
\caption{トレーサのコマンド一覧}
\label{tracer-functions}
\end{table}

\section{提供機能の概要}

KLICでは、以下の操作の繰り返しによりリダクションを進める。

\begin{enumerate}
\item ゴールプールからゴールを１つ取ってくる。(ゴール呼びだし操作)
\item ゴール引数の値を、KL1節のガード部の規則にしたがってチェックし、チェックに適合した節を１つ選んでそのボディ部を実行し、生成されたサブゴールをゴールプールに入れる。(リダクション操作)
\item 2 で呼び出されたゴールの引数が変数等になっており、チェックが即時にできない時、ゴールをサスペンションプールに入れる。（サスペンション操作）
\item 2 で呼び出されたゴールが失敗した場合、プログラムを呼び出したプロセスに
制御が戻される。逐次版のKLICでは、プログラムの実行を終了しshellに戻る。
（失敗操作）
\end{enumerate}

トレーサでは、各操作をモニターする部分を「ポート」と呼ぶ。
ゴール呼びだし操作、リダクション操作、中断操作、失敗操作
についてのポートはそれぞれ、
「CALLポート」、「REDUポート」、「SUSPポート」、「FAILポート」と呼ばれる。
\index{とれーさ@トレーサ!CALLぽーと@CALLポート}
\index{とれーさ@トレーサ!REDUぽーと@REDUポート}
\index{とれーさ@トレーサ!SUSPぽーと@SUSPポート}
\index{とれーさ@トレーサ!FAILぽーと@FAILポート}

図\ref{tracer-port}に、KL1の実行モデルと各ポートの図を示す。

\begin{figure}[htb]
\begin{center}
\epsfile{file=tracer-port.eps,width=10cm}
\caption{KL1の実行モデルと各ポート}
\label{tracer-port}
\end{center}
\end{figure}

トレースモードでコンパイルされたプログラムは、ゴールが上記の4つのポート
を通過する時に、実行を停止してユーザからの入力待ちとなったり、
そのゴールの表示を行ったりする。

以下で、実現方式について解説を行う。

\section{リンク時のトレース指定}

多くのトレーサを持つ言語処理系では、 解釈実行型のシステムを別途用意する、
または、トレースを行うか否かによってユーザ・プログラム自身をコンパイル
し直すといった方法により、トレースの有無に応じて意味は同じでも実現の詳細がか
なり異なるプログラム・コードを動かすことによって、 トレースができる柔軟
性と、 トレースしない場合の効率性を両立させている。

KLIC のトレーサではこのような処理をせずに、 ユーザ・プログラムについて
はまったく同じオブジェクト・コードを用い、 リンクする実行時システム・ラ
イブラリを通常実行用とトレース用の二種用意し、 リンクをし直すだけでトレー
スの有無を切替えられるような方式をとった。  このために、 実際にゴールの
リダクションを行うユーザ・プログラムを1リダクションずつ進め、 リダク
ションの前後の状況の差を検出することによってトレースを行っている。

具体的には、 ゴール・リダクションごとに必要なヒープ溢れの検査を、 トレー
スのきっかけとして利用している。 つまり、「一例外処理」として
トレースのきっかけを実装している\REFER{trace-trigger}。\label{tracer}

トレース用のライブラリで、トレース対象となるゴールを実行する直前に
ヒープあふれの比較対象であるヒープの上限値をダミーの値に設定することによって、
1 リダクションごとに強制的にヒープあふれ処理ルーチンに割出させるように
する。  このあふれ処理ルーチンの中でトレース用の割出しか、 本当のヒープ
あふれかを検査し、 必要ならトレースを行う。
なお、KLICでデフォルトで利用されるのは
トレース用のライブラリである。
 
\section{名前情報の管理}

\index{とれーさ@トレーサ!なまえかんり@名前管理}

KLICでは一般的には実行コードにしてしまえば、その述語名、モジュール名は
もはや必要はない。しかしながら、KLICのトレーサでは、
それらの情報をユーザに提示するし、モジュール、述語を特定させる必要があるため、
名前情報を保持している必要がある。

KLICでは、トレース時のみリンクされるような
データベースを持つことにより管理を行っている。

\begin{itemize}
\item 名前管理のため、以下の表が生成される。

\begin{description}
\item[述語表:\ ] すべてのpte(pred\_table\_entry)の配列を保持する、
変数pred\_table。
\item[述語ハッシュ表:\ ] pteの配列を検索するための述語構造体、
pteへのポインタの表で、変数pred\_hash。
\item[モジュール表:\ ] モジュール情報(mte: mod\_table\_entry)を持つ表、変数mod\_table。
\item[モジュールエントリ表:\ ] モジュール情報へのポインタの表。
変数mod\_index。
\end{description}

なお、構造体pred\_table\_entry、module\_table\_entry は以下に示す
構造を持つ。

\begin{verbatim}
struct pred_table_entry {
  Const struct predicate *pred; /* 述語情報 */
  Const struct mod_table_entry *mte; /* 所属するモジュールのmte */
  Const unsigned char *name; /* 述語名 */
  char spied; /* 述語としてスパイされているかどうか */
  char default_trace; /* デフォルトのトレースフラグ */
};

struct mod_table_entry {
  module (*func)(); /* そのモジュールを実現する関数へのポインタ */
  Const unsigned char *name; /* モジュール名 */
};
\end{verbatim}

\item これら名前表は、make\_name\_tables() (\filename{trace.c})
により以下のように生成される。

\begin{enumerate}
\item 配列defined\_modulesを嘗め、全モジュールの数を数える。
さらに、defined\_modulesより述語表を嘗め、全述語数を数える。
このdefined\_modulesは、KLICコンパイラにより生成されるデータであり、
predicates.cに定義されている。

\item 得られた述語数を用い、述語エントリを割り付け、
得られた述語数より少々大め(述語数の1.5倍を越える2羃程度)に
ハッシュエントリ表を割り付け、
hash\_maskを決め、すべてのエントリを0で初期化する。

\item 全てのモジュール表を嘗め、さらに、それを経由して
全ての述語を嘗め、述語エントリ(pte)を初期化する。pteは以下の形式を持つ。

\begin{tabular}{l|p{5cm}}
エントリ名 & 説明 \\
\hline
Const struct predicate *pred & 述語構造体\\
Const struct mod\_table\_entry *mte & 所属するモジュールのmte\\
Const unsigned char *name & 述語名\\
char spied & spy中かどうかのフラグ。初期的にはoffにする。\\
char default\_trace & デフォルトのトレースフラグ。初期的にはonにする。
\end{tabular}

\item 調べたモジュール数より、モジュール表、
モジュールエントリ表を割り付ける。

\item 全てのモジュールを嘗め、モジュール表を初期化する。
出現順にモジュールエントリ表も初期化する。

\item モジュール表は名前順にソートし、モジュールエントリ表は
モジュール関数順にソートする。

\item モジュール表を検索しながら、述語表のmteを初期化する。

\item 述語表を述語名順にソートする。

\item 全述語を、述語構造体アドレスで検索できるようにハッシュテーブルに
登録する。

\end{enumerate}
\end{itemize}

また、pte, mteを、pred構造体から
検索する関数として、get\_pte(), get\_mte()が
各々定義されている。

\section{トレースの制御と情報入手}

トレースを行うためには:
\begin{itemize}
\item 適切なトレースのタイミングで、 トレースのためのルーチンが呼ばれる
こと
\item トレース・ルーチンからトレースに必要な情報を得ることができること
\end{itemize}
が必要である。  KLIC のトレーサでは、 以下のような方法を用いてトレースの
タイミングをつかみ、 必要な情報を得ている。  全体として、 トレース不要部
分の実行効率が、 まったくトレースしない場合とほとんど変わりなくなるよう
に留意している。

KLICでは、種々のポートでユーザが実行に介入できるように
主に以下のような処理を行っている。

\begin{description}
\item[トレースのきっかけ:\ ] 
トレース対象となるゴールの実行直前に、「擬似的なゴール」を実行することにより
トレースのきっかけとしている。これは、擬似的なゴール内に
本来のゴールを持つようなゴールを作成しておき、それを実行する。
この「擬似的ゴール」の解説については\REF{pseudo-goal-desc}を参照のこと。
この擬似的にゴールがスケジュールされた際には必要な処理
(例えば、CALLポートでのユーザコマンドの受付)を行った後に、
本来のゴールをエンキューしなおすことにより実現されている。

\item[子ゴールの認識:\ ] リダクション処理が行われた結果生成された
ゴールについては、以下のように処理されている。

\begin{itemize}
\item リダクション直前(つまり、「トレースのきっかけ」の時)に、
ゴールスタックの先頭を記録しておく。

\item リダクションが終了した際に、再度ゴールスタックを検査する。
原則的には、このリダクション
前後のゴールスタックの差分が生成されたゴールである。

ただし、他の優先度のゴールスタックにゴールが置かれた場合、また、
再実行可能になった場合などがあるため、それらのゴールについては特別な配慮
が必要になる(詳細後述)。

このリダクションが終了した際に、子ゴールについてもトレースすることが
適当な場合には、前述の「擬似的なゴール」により、本来のゴールを
保持させるようにゴールを変更しておく。

\subsection{擬似ゴールの構造}\label{pseudo-goal-desc}

\index{とれーさ@トレーサ!ぎじごーる@擬似ゴール}

KLIC の実装では、 実行する各ゴールは対応するプログラム・コードへのポイ
ンタを保持している。

トレース対象のゴールについては、 本来実行すべきコードのかわりに、 トレー
サのコードへのポインタを格納しておくことによって、 実行しようとした時に
自然にトレーサのコードが呼び出されてしまうようにする。  これによって上
述の CALL ポートに対応するトレースが可能になる。  本来実行すべきコード
へのポインタはゴールの追加引数として保持する。  CALL ポートで実行を継続
する場合は、 このポインタを用いて本来のコードを呼び出せば良い
(図\ref{pseudo-goal}参照)。

具体的には、トレース対象ゴールに対して、トレースがなされるように処理される。
具体的にはこの処理はtrace\_goal()で以下のように行われる。

\begin{enumerate}
\item 本来のゴールよりも3ワードサイズの大きなゴールを用意する。

\item 対応する引数の、trace\_trigger\_preds を述語として指定する。
この述語内では、関数trace\_trigger\_routineがあたかも
module関数であるかのうように実行される。

\item 引数を本来のゴールからコピーする。

\item 追加されたゴールスロットに対して、以下のデータを格納する。

\begin{itemize}
\item 元のゴールの述語構造体

\item トレースゴールID。PE毎にトレース対象ゴールに付加される整数値。

\item トレース情報(multi windowでデバッグしたときに追加するパラメータ群。
詳細割愛)
\end{itemize}
\end{enumerate}

\end{itemize}
\end{description}

\begin{figure}
\begin{center}
\epsfile{file=pseudo-goal.eps,width=.6\textwidth}
\end{center}
\caption{トレース用擬似的ゴールの構造}
\label{pseudo-goal}
\end{figure}

なお、untrace\_goal()なる関数は上記の逆をおこなう。
ただし、ゴールレコードの再確保は行わず、単に述語構造体の付替のみを行い、
トレースゴールIDを戻り値として返す。

%以下で、より詳細に各種の処理についての解説を行う。

\subsection{CALL ポートのトレースのきっかけ}

\index{とれーさ@トレーサ!CALLぽーと@CALLポート}

先にも延べたように、トレースのきっかけは擬似ゴールで関数として
指定されているmodule関数
trace\_trigger\_routineが実行されることにより行なわれる。
この関数の起動は、通常のKL1がコンパイルされて生成された
module関数と同じ方法にて行なわれる。
よって、
この方式では、 トレース対象かどうかの条件判断が不要で、 通常の実行の効率
に影響を与えることなく、 必要な時にだけトレースできる。

トレース用の実行時ライブラリでは、トレース用のフラグ(-t)が指定された時には、
実行の開始
(\filename{kmain.c})にあたって初期ゴール 
(main:main) を作る際に、 トレースを行うように加工している。  すべての
トレースはこれをきっかけに始まる。

このようにトレース化されたゴールがスケジュールされると、
trace\_trigger\_routine() が本来のモジュール関数と同様に
実行される。その結果:

\begin{itemize}
\item infoにそのゴールに指定されたトレース情報を持つ
(このトレース情報はtrace\_trigger\_routine() 終了時に
大域変数parent\_info に退避され、trace\_after()にて用いられる)。

\item untrace\_goal() により非トレース化する。

\item 指定されているモジュール関数を調べ、ノード番号、優先度番号を
waitするような関数が指定されている場合には、本来の述語を
システムヒープ部に割りつけ、以下の処理を行う。

\item 述語構造体より、get\_pte()によりpteを得る。

\item pteを参照し、述語スパイフラグをコピーする。trace\_flagを立てる。

\item qp\_beforeに、リダクション前のゴールスタックの先頭
(qp-$>$next)を記録しておく(図\ref{child-goals}での「記憶」に相当)。

\item Leap中、Spy中であるか、などによりゴールを印字する
(print\_goal())。
さらに、Leash中であればコマンドをユーザから読む(call\_port\_command())。

\item トレース中(trace\_flagがON)であれば(コマンドを実行した結果
トレース中ではなくなる可能性がある)、heaplimitを0にし、
真のモジュール関数を実行する。
\end{itemize}

その結果、次のリダクションが終了したときに、割り込みが検出され
(klic\_interrupt() \filename{intrpt.c})、
trace\_flagがONであることより、trace\_after()が呼びだされる。


\subsection{REDUCE/SUSPEND ポートのトレースのきっかけ}

\index{とれーさ@トレーサ!REDUぽーと@REDUポート}
\index{とれーさ@トレーサ!SUSPぽーと@SUSPポート}

上述のように CALL ポートで実行を継続する場合、 ヒープの上限値をダミー値
に設定した後に実行を継続する。  これによって、 1 リダクションを経た後に
ヒープあふれの割出しが起きる。  別途用意したトレース・フラグを用いれば、 
本当のヒープあふれなのか、 トレースのためのダミー処理なのか (あるいは両
方か) を区別することができる。  これによって、 ヒープあふれ処理ルーチン
の入口から、 上述の REDUCE ポートをトレースするルーチンを呼び出すことが
できる(klic\_interrupt(), \filename{intrpt.c})。

変数が未定義であったためにゴールが実行を中断することもある。この場合に
は中断処理のためのルーチンが呼ばれる\label{trace-susp}
\REFER{fail-suspend}。トレース用のライブラリ中では、 
トレース・フラグを調べて、 必要なら SUSPEND ポートのトレー
スを行うルーチン、trace\_susp()またはstep\_susp()
を呼び出す。  中断処理自体かなりのコストを伴うので、 
フラグの検査のオーバヘッドは相対的に小さい。  したがって、 トレース用ラ
イブラリを用いても、 実際にトレースを行わない場合の効率はほとんど落ち
ない。

CALL ポートでそのゴールのトレースを不要と指示されれば、 このようなヒー
プ上限値とフラグの設定を行わなければ良い。

\subsection{リダクション結果の子ゴールの認識}
プログラムの実行はゴール・スタック中のゴールをプログラムにしたがって次々
にリダクションしていくことによって行われる。  このゴール・スタックは
優先度ごとに別のものがある。

リダクションはその時点で空でない最高優先度のゴール・スタックの先頭のゴー
ルについて行われる。  このゴールをリデュースした結果の子ゴールは、 そ
れぞれの優先度に対応するゴール・スタックの先頭に入れられる。

REDUCEポートを処理するルーチン、
trace\_after()には、 
親ゴールの優先度に対応するゴール・
スタックの先頭へのポインタが渡される。  CALLポートでその時点のゴール・
スタックの先頭 (リデュースされるゴール自身の次のゴール) は
qp\_beforeとして記録されているので、
リデュース結果として生成された子ゴールはどこまでかを判別できる (図 
\ref{child-goals}。qp\_beforeは図中「記憶」に相当する)。

\begin{figure}
\begin{center}
\epsfile{file=child-goals.eps,width=.7\columnwidth}
\end{center}

\caption{子ゴールの認識}
\label{child-goals}
\end{figure}

この方法だけでは、 親ゴールと異なる優先度の子ゴールを把握できない。  異
なる優先度の子ゴールができるのは、 優先度指定があるボディ・ゴールについ
てだけである。  このような優先度指定つきのゴールについては若干面倒な処
理が必要なので、 コンパイルしたオブジェクト・コード中で直接行うのでは
なく、 実行時サブルーチンを呼ぶようになっている。  そこで、 トレース用の
実行時ライブラリでは、 このサブルーチンをトレース・フラグが立っている場
合にはトレース用情報を保存するようにしている。

多くのプログラムでは子ゴールの優先度が親ゴールと同じである場合が支配的
である。  したがって、 トレース用の実行時ライブラリを使う場合に生じる、 
優先度指定つきゴール処理ルーチン内でのフラグ判定オーバヘッドは、 通常ほ
とんど無視できる程度である。

\subsection{リデュースにともなう再開ゴールの把握}

ゴールのリデュース時には、 リデュースにともなうユニフィケーションによっ
て中断していたゴールが再開することがある。  この処理は実行時ライブラリ
resume\_goals()(\filename{unify.c})中のサブルーチン中で、
trace\_resumption()を呼びだすことにより行われている。

トレース用の実行時ルーチンでは、 トレース・フラグが立っている間に再開し
たゴールを記憶して、 後の REDUCE ポートでのトレースの際に報告するように
している。  再開処理もコストの高い処理なので、 フラグ判定コストは無視で
きる。

\subsection{リデュース結果のゴールのトレース}

トレースされたゴールのリデュースの結果できた子ゴールや、 リデュースに
ともなって実行を再開できたゴールは、 REDUCE ポートでトレースを指定でき
る。  トレースのためには、 上述のプログラム・コードへのポインタを、 本来
のコードからトレース・ルーチンのコードへ差し替えておけばよい。
この処理は、trace\_afterの内部で行われる。

\subsection{トレースされた中断ゴールの再開の把握}

トレース対象のゴールが変数値の待ち合わせのために中断し、 トレース対象外
のゴールのリデュースによってそれが再開される、 という場合もある。  これ
は上述の方法だけでは把握できない。

トレース対象のゴールが中断する場合には、 プログラム・コードへのポインタ
の差し替え処理を行った状態で中断させておく。 これは
前述のtrace\_suspの内部で行われている。
これによって、 実行を
再開し、 そのゴールのリダクションを始めようとする時には、 自然にトレース・
ルーチンが呼ばれるようになる。

\subsection{trace\_after()の処理}
これまでの説明の各所で出現した、trace\_after()で行われている処理について、
以下に纏める。

\begin{enumerate}
\item トレース状態を、親ゴールがスケジュールされたときの状態(parent\_info)に
する。

\item ゴールスタックの先頭から、親ゴールがスケジュールされたときの
先頭ゴール(qp\_before == before)までのゴールを調べる。

\begin{enumerate}

\item 再開によりエンキューされたゴールかどうか調べる。

再開によりエンキューされたゴールは、「再開ゴールリスト
(different\_prio\_resume)」に記録されているので、
ゴールスタック上のゴールがこのリストに記録されているかどうか調べれば判明する。

\begin{itemize}
\item 再開によりエンキューされたゴールであれば、そのゴールが再開によるもので
あることを記録する。
\item 再開によるものでなければ、そのゴールが再開によるものであることを
記録しない。
\end{itemize}
\end{enumerate}

\item 現在の優先度ではないゴールがエンキューされた時に
記録されるリスト(trace\_enqueued\_goal)を調べる。

\begin{enumerate}

\item 再開によりエンキューされたゴールかどうか調べる。

再開によりエンキューされたゴールは、「再開ゴールリスト
(different\_prio\_resume)」に記録されているので、
ゴールスタック上のゴールがこのリストに記録されているかどうか調べれば判明する。

\begin{itemize}
\item 再開によりエンキューされたゴールであれば、そのゴールが再開によるもので
あることを記録する。
\item 再開によるものでなければ、そのゴールが再開によるものであることを
記録しない。
\end{itemize}
\end{enumerate}

\item REDUCE portがenableになっており、Leap状態ではないか、
そのゴールがSpy状態であれば、以下の処理を行う。
\item 親ゴールの処理を以下のように行う。

\begin{enumerate}
\item ます、ゴールが印字対象かどうか検査する。以下の何れかであれば
印字対象となる。
\begin{itemize}
\item 「部分項モード」ではない。
\item 「部分項モード」で対象ゴールである。
\end{itemize}

\item 上記の検査で印字対象であれば、REDUとして印字する。
\end{enumerate}

\item Subgoalについて以下の処理を行い、必要あればゴールを印字する。
また、印字するか否かに関わらず、subgoalを記録しておく(current\_subgoals)。

\begin{enumerate}
\item まず、ゴールスタック中にあるゴールを調べる。
親ゴールの時と同様の条件で判断し、必要あればゴールを印字する。

\item 次に別優先度のスタックにエンキューされたゴールを調べる。
親ゴールの時と同様の条件で判断し、必要あればゴールを印字する。
\end{enumerate}

\item REDUCE ポートがleash状態であるか、当該ゴールがspy状態であるか
yどちらかならば、REDUCE ポートのコマンドの入力を則す。

\item ゴールスタック中のゴール、別優先度のゴールリストを調べ、
trace状態にすべきsubgoalについては、trace\_goal処理を行う。
さもなくば、untrace\_goal処理を行う。

\item 別優先度のゴールについては、ゴールをエンキューする
(トレース中は、直接エンキューされず、このリストに記録されるので、
処理が終了した後にエンキューする)。

\item trace\_enqueued\_goal を空にし、割り込みを終了状態にする。
\end{enumerate}

