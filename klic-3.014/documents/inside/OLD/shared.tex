% (C) 1998 Japan Information Processing Development Center
% 詳細な配布条件については、COPYRIGHT-JIPDEC.jを参照してください。
\chapter{共有メモリ並列実装}
\section{概要}
\index{きょうゆうめもりはん@共有メモリ版}

共有メモリ結合並列計算機上で KLIC の並列実装を設計・開発した。
この拡張での設計目標は、逐次核をそのままにして、共有メモリ並列処理を付
加することであった。

  従来の共有メモリ向け実装は、排他制御コードの挿入が、ベースとなる逐次性
能を損なっていたが、提案した混合方式では、局所データ領域と共有データ領
域を区別することで、そのようなオーバヘッドが小さくなることを狙った。


また、高速な計算機は局所メモリと共有メモリとのアクセスコストの落差が大
きく、並列に一括GCを行うと共有バスがボトルネックになる。それを避ける
ために各ノードが独立に共有メモリをGCする非同期GCを採用した。

\section{処理系の構成}

  処理系は、共有メモリ変数の扱いをジェネリックオブジェクトで実現し、デー
タ領域を局所領域と共有領域とに分割された構成となっている。

\subsection{共有変数オブジェクト}
\index{きょうゆうへんすうおぶじぇくと@共有変数オブジェクト}

KLIC 逐次処理系は、
ユーザが独自に追加したい機能を拡張できる枠組み(ジェネリ
ック・オブジェクト・インタフェース)を持っており、共有メモリ拡張でもジェネ
リック・オブジェクトの枠組みにより拡張した。

逐次実装と共有メモリ実装とのもっとも大きな違いは、共有メモリ
変数の存在である。共有メモリ変数はその書換えの時に
特別な扱いを要する。具体化する場合にはロ
ックが必要であるし、フックする時にもロックが必要である。共有メモリ上の共有
メモリ変数以外のデータ(具体値)へのロックは不要なので、共有メモリ変数はこれ
らと異なった特別なデータタイプにする。

共有メモリ変数は SHVAR というジェネレータオブジェクトで実現される
(このオブジェクトは、\filename{gg\_shvar.c}なるファイルで
定義されている)。
共有メモリ上のそれ以外の基本データタイプは逐次処理の対象データと同じであり、そ
れらのデータに対しては、ロックのオーバヘッドは加わらず、局所メモリのデ
ータにアクセスする場合と何等変わらない。

各ノードには固有の局所メモリを
持ち、ノード間で共有する１つのメモリ領域を持つ。局所メモリはその持ち主
のみがアクセスする。共有メモリ変数を局所データで具体化するときには、共有
メモリ変数に局所データへポインタ付けするのではなく、局所データを共有メモリ
にコピーした上で、変数にポインタ付けする。

\begin{figure}[htbp]
\begin{center}
\epsfile{file=shm-local-shared-data.eps,width=0.8\textwidth}
\end{center}
\caption{局所ヒープと共有ヒープ}
\label{fig-local-shared-data}
\end{figure}

\subsection{局所領域と共有領域}
\index{きょうゆうめもりはん@共有メモリ版!きょくしょりょういき@局所領域}
\index{きょうゆうめもりはん@共有メモリ版!きょうゆうりょういき@共有領域}

局所領域には、局所処理を行うための管理領域と動的に局所ゴールや KL1 デー
タを配置する局所ヒープとがある。管理データには局所ヒープの使用アドレスや実
行ゴールへのポインタなどの情報を持っている。共有領域には共有領域を管理する
データ領域とゴールや KL1 データを配置する共有ヒープ領域がある。共有管理デ
ータには、外部ゴールへのポインタや各ノードの割り込みフラグなどがある。
付加分散するときには、他のノードからアクセスできるようにゴールを共有メ
モリに配置する。

各局所ヒープはGCのために2つの空間に分割されており、
そのGCはすでに述べた逐次核のGCにほぼ等しい。

共有ヒープは３つの
空間に分割されている。新・旧・未使用とに分け、これらはサイクリックに切り替わる。

一般には、共有ヒープから局所ヒープへポインタ付けすることはない。しかし、いく
つかの場合にそのようなポインタが必要となる。そのような場合には間接テーブルに
より、ノード番号とその間接テーブルのインデックスと局所ヒープのあるアドレ
スを指定する。局所GC時には、そのテーブルもGC ルートとして
扱い、また適正に更新する。

各ノードは動的にデータを配置するために共有ヒープ面を持ち、各面は現在アク
セス中のノード表を持っている。同期のためのオーバヘッドを小さくするために
各ノードはゴールやデータを配置するページを確保する。そのページを使いきっ
た時に、各ノードは現在のヒープ面から新たにページを確保する。

ノードはGC時にアクセス面を旧面から新面に移動する。最後に旧面を参照して
いたノードが新面にアクセス面を移動した時に旧面を参照するポインタがなくな
ったことが保証され、その旧面は次のサイクルで未使用面に切り替わる。

\subsection{ゴールの投げだし}
KLIC の共有メモリ並列拡張では、ゴールの
分配をプラグマとして記述し、それにより指定されたノードにゴールの投げ
る方式をとっている。

%\whycolumn{このようにした理由は局所メモリアクセスに比べて共有メモ
%リアクセスのコストが高いので、プログラマに実行の制御を推察させ、プログラマ
%自身にノードの負荷分散を委ねた方がより実用的と考えたことと、
%自動負荷分散は KL1 のレベルでも可能と考えたからである。}

下記のようなコードを例とし、実際にどのようにゴールとして
投げだされるかを説明する。

\begin{verbatim}
    p(X) :- ... | ... , q(X,foo(Y))@node(4), ... .
\end{verbatim}

最初にゴール q を局所ヒープに生成する。
実行時ルーチンによりそれは共有ヒープに
コピーされる。これは、逐次版にも存在するenqueue\_throw\_goal()関数の中で、
行われ、
共有ヒープにコピーされる以降、これから述べる処理は
共有メモリ版特有のthrow\_goal\_routine()関数(\filename{shm\_throw.c})
により実装されている。

コピーは、(1) CONS や FUNCTOR 構造はその構成要素を再帰的にコ
ピーしていき、(2) 変数は共有メモリ上に(ジェネリックオブジェクトである)共有
メモリ変数を生成し、局所メモリの変数はそれへのポインタに置き換える。
(3) 共有メモリへのポインタであった場合にはそれ以上のコピーは必要ない。\par
  ある場合にはもう少し処理しなければならない。(A) フックされた変数を共有メモ
リに移す場合には、中断情報も共有メモリに移さなければならない。コピーされた
中断情報は間接テーブルを通じて局所ヒープ内のゴールへポインタ付けされること
になる。
(B) 現在のアクセス面より古い面のデータであった場合には現在の面にコピーしな
ければならない。また (C) ゴールを投げようとするノードが新しい面を参照して
いた場合には、新しい面にコピーして渡さなければならない。このようにしないと、
新面に移ったノードが旧面を参照してしまうことになる。

ゴールをコピーし終えたら、投げようとするノードの外部受け入れキューに
登録する。投げようとするノードの実行中の優先度を検査して、投げるゴールの
優先度の方が高ければ、割り込みフラッグを立てて、直ちに処理されることを要
求する。
それ以外の場合には投げだし先のノードには割り込まない。各ノードは低い優先
度処理に移るときに外部受け入れキューを調べ、それらをスケジューリングして
処理を再開する(この外部ノードーへの外部受入キューに登録以降の処理は、
throw\_goal\_routine()内の、shm\_goal\_stack()で行われる)。

\subsection{共有変数の具体化}

共有メモリ変数は、ジェネレータオブジェクト SHVAR により実現している
(\filename{gg\_shvar.c})。SHVAR にはメソッド表フィールドと
中断チェーンがあり、
メソッド表フィールドはロック用フィールドとしても利用している。

\begin{verbatim}
typedef struct Shvar {
  struct generator_object_method_table *method_table;
  Sinfo chain;
} Shm_var;
\end{verbatim}

各ノードはロックして変数の状態を変える。通常ノードはフックした後、ロック
をはずさなければならない。しかし具体化した後にはアンロックは必要ない。

これは、
ロック時に、単にロック用フィールドをスピンするだけでなく、変数の値の設定
の有無を監視しながら、ロック用フィールドを監視する。ゆえに、ロックが解除され
ればロックは成功するし、具体化されても、スピンから抜け、該当する処理に移れる。
これらの処理は、shvar オブジェクトのUNIFYメソッドにて行われている。

構造体と共有変数とが具体化される時には以下で述べるような
最適化も行っており、これもUNIFYメソッド中で実装されている。

\subsection{共有ヒープへのコピーの遅延}
他のプロセスに参照されるストリームを生成する場合、最初に生成側と
参照側との間に変数(S)を共有する。生成側はストリーム要素 {\tt X1} を生成し、
最初に {\tt [X1|L1]} を局所ヒープに生成し、そして変数
 S(ジェネリックオブジェクトSHVAR )に単一化する。

 SHVAR のユニファイ・メソッドは局所ヒープ上のリストを共有メモリにコピーする。
そして変数(S)にリスト・ポインタを書き込む。このような操作が１要素を具体化する
毎に繰り返される。

連続した共有メモリ変数の生成およびその具体化は大きなオーバヘッドを伴う。特に
スループット優先のプログラムの場合には、この頻度が大きい。

この問題を回避するために、具体化遅延(ジェネレータフック)という技法を用いる。
ジェネレータフックはフックしていない共有メモリ変数を局所ヒープのデータ構
造で具体化するときに、その時点での具体化は行わずに共有メモリ変数にジェネレ
ータフック情報を記録する。 
あるゴールがその変数の読み出し要求をしたときに、そのオブジェクトはその変数を
具体化しているノードに対して具体化要求をだす
この方式は要求時点で全てもしくはほとんどのデータ構造が局所ヒープ上で具体
化されていることを期待している。このような場合には生成側は共有メモリ変数
を一度だけジェネレータフックにし、データを一気に共有メモリへコピーするこ
とになる。
  変数具体化時にフックしているゴールがあった場合には、ジェネレータフック
にしないで、具体化して待ち合わせているゴールを起こす。
  要約すると、具体値を待つものがいた場合は、局所データはコピーされ、そうで
ない場合は、遅延してコピーする。前者はデータ駆動またはスループット優先プ
ログラムであり、後者は要求駆動またはレスポンス指向のプログラムである。

\section{共有ヒープのガーベジコレクション}

\index{GC!きょうゆうひーぷ@共有ヒープ}

\subsection{局所GC}
局所ヒープと共有ヒープの分割は独立な局所GCを可能にしている。局所GCは、
KLIC の逐次核実装のGCに共有メモリポインタをコンスタントデータのように
扱い(すなわち、そこから先はコピーしない)、また、
共有ヒープから局所ヒープを参照している
データについての間接テーブルをGCルートに加えることで、独立動作でき、
GCルーティンの変更もごくわずかなもので済んでいる。

\subsection{共有ヒープGC}
多くの処理系の共有メモリ実装では、共有ヒープのGCは同期して行っていた。全ての
ノードが通常処理を中断して、GCを始める。しかし、単一プロセッサの性能
は共有バスのスループットよりも飛躍的に高くなってきている。GCは局所性
が低く、並列処理では共有バスがボトルネックになってくる。

この問題を避けるために、KLICの共有メモリ実装では、
各ノードが独立にGCする非同期GCを採用した。
同時に複数のノードがGCする代りに、ノードが通常処理している中、
あるノードが非同期にGCを始めるのである。

この方式は共有バスアクセスが時間軸に一定になることを期待している。その結果
バスを待ち合わせするアイドル時間を軽減させることにある。

%非同期GCは、GCと通常処理を同時に行うという点で on-the-fly GC と似ている。
%しかし非同期GCは、GCと通常処理する分担が決まっておらず、各ノードが動
%的に通常処理からGCに切り替わるという点で違っている。

非同期GCでは、古い面を参照して通常処理していたノードが古い面の領域の
不足を検知してGC処理に切り替わる。ノードは参照している古い面のデータを
新しい面にコピーする。それが終わると、また新しい面を参照面として通常処理
に移る。
もし、２つの面しかなければ、新面があふれた
場合にコピーする面がなくなってしまう。それゆえ、もう一つの未使用面を用意
している。未使用面の確保は実データ使用量が一面のサイズを越えない限り、共
有ヒープ領域のオーバーフローを起こさないことを保証している。\par
 図\ref{fig:shared-heap-gc1} に非同期GCの状態を示した。
この例では、最初に２つのノードが旧面を
参照している。そして、１つのノードが旧面の領域の不足を検知して、参照デー
タを新面にコピーする。その間、もう一方のノードは通常処理を行っている。
一方のノードがGCを終え、その後にもう一方のノードが旧面の領域の不足を検
知して、参照データを新面にコピーする。\par

\begin{figure}[htbp]
\begin{center}
\epsfile{file=shm-shared-heap-gc1.eps,width=0.6\textwidth}
\end{center}
\caption{共有ヒープの非同期 GC}
\label{fig:shared-heap-gc1}
\end{figure}

新面を使いきった場合に、未だ旧面を参照しているノードがいた場合には、
それらのノードに対して、割り込みにより強制GCを通知する。それらのノードが
新面に参照データをコピーし終われば、旧面は未使用面に切り替わる。この
ように面は回転して使用され、新面は次の旧面、未使用面は新面へと切り替わる。
3面を使用する非同期GCでは、以下のような問題を解決しなければならない。

\begin{description}
 \item[GC ルートの決定:\ ]
        共有ヒープを参照しているルートは何か?
 \item[並列の読み書き:\ ]
        通常処理とGCの同時処理方法、同じ場所をアクセスする可能性
 \item[旧面の解放の保証:\ ]
        旧面の解放は新面からポインタ付けされないかまたは、そのようなポインタ
を識別できることであるが、どのようにするか？
\end{description}

これらの問題の解決方法を以下に述べる。

\subsubsection{ルートの決定}
  参照データのルートの決定は on-the-fly GCの主要な問題であるが、この非同期
GCはそれほど重要でない。ノードが通常処理からGC処理に移る際、実使用デ
ータをそのまま引き継いでいる。これをするには局所GCの際に局所ヒープから共有
ヒープを指している箇所を記録すればよい。on-the-fly GC のような通常処理とGC
処理するノード間の調整は必要ない。

\subsubsection{並列読み出しと書き込み}
  データをコピーする際に通常処理ノードが同じデータをアクセスしているかもしれ
ないということに配慮しなければならない。幅優先のコピーの場合には、旧面にある
構造体データを新面にコピーする時旧面データに前方参照ポインターを書き込む。
前方参照ポインターは通常ポインタと見分けがつかないので通常処理ノードにとっ
ては異常データを参照してしまうことになる。\par
この問題を解決する方式はいくつか考えられるが、KLICでは以下に述べる
ボトムアップコピー方式と暗黙前方参照方式を実装した。
(それらは条件コンパイルにより切り替えるようにしている)

\begin{description}
 \item[旧面読み込み専用]
    GCノードは旧面を読み込み専用とする。通常処理ノードは悪影響を及ぼさない。
このことは、GCノードは前方参照ポインタを一切作らないことを意味する。\par
  しかしこの方式で共有メモリ変数は例外にしなければならない。GCノードは、旧
面の変数を新面にコピーすることで１つの変数を２つの変数に分割できない。一
つの変数を２つの変数に分割することは論理変数の意味を壊してしまう。\par
そこで、共有メモリ領域の新しい変数を生成し、それと旧面の変数を単一化を許し、
旧面の変数の値は新しい変数へのポインターにしてしまう(このポインターは実質
的に前方参照ポインタとなる)。\par
  前方参照ポインタが使用できないために、GCノードは古い面のコピーデータが新しい
面のどこにあるのかがわからない。(古い面のデータが新しい面にコピーされた
かどうかさえわからない）ゆえに、旧面データ生きているパスの数だけのコピー
が行われる。その数は非常に大きな数になる恐れがある。
  別の前方参照テーブルを設ける方法も考えられるが、余分な空間を必要とすこ
とや実行時のオーバヘッドを考えると非現実的である。

 \item[ボトムアップコピー方式]
  旧面のデータ構造を新面へボトムアップにコピーする。旧面を指して
  いる構造体への旧面にあるポインタは新面にコピーした構造体へのポイ
  ンタに置き換えられる。リスト[a,b](図 ~\ref{fig-before})のコピーは、
  図 ~\ref{fig-bottomup-copy}(a)から図 ~\ref{fig-bottomup-copy}(b)へと進む。
  新面にコピーされた構造体は旧面にあるものと論理的に等価である。このよう
  な置き換えはいつでも可能である(ポインタの書込みが不可分な処理である
  とすれば、通常の計算機はこのことを保証している)。たとえば、この場合
  通常処理ノードからみて常に[a,b]と見える。


\begin{figure}[htbp]
\centerline{
\epsfile{file=shm-before.eps,scale=0.7}}
\caption{元の状態 (コピー前)}
\label{fig-before}
\end{figure}

\begin{figure}[htbp]
\begin{minipage}{8cm}
\begin{center}
\epsfile{file=shm-bottomup-copy1.eps,scale=0.7}\\
(a)
\end{center}
\end{minipage}
\begin{minipage}{8cm}
\epsfile{file=shm-bottomup-copy2.eps,scale=0.7}\\
(b)
\end{minipage}
\caption{ボトムアップ コピー}
\label{fig-bottomup-copy}
\end{figure}


    この方式でも、重複コピーの問題をはらんでいる。特にループしているデータに
  出合うと無限ループに陥る。しかし、重複コピーする度合はそれ程多くない。
  旧面読み出し専用の場合と違って、参照中のポインタの数だけの重複コピーしか起
  こり得ない。(生きているパスの数と比べれば、はるかに小さい数である。)\par
    幸い多くのKL1 プログラムはループ構造を作っていない。また複数のポインタ
  から参照されるデータ構造の割合も大きくない。
  
 \item[暗黙前方参照方式]
  暗黙前方参照ポインタは前方参照情報を間接ポインタの出現で代替させる。デー
タ中の１語、言うならば先頭に暗黙の前方参照ポインタを配置する。このポインタ
は新面のコピーしたレコードを指す。たとえば、リスト[a,b]をコピーする場合、
最初の CONS レコード(C1)を新面にコピーする。局所メモリから指されるポインタ
は直ちに新面にコピーされた CONS レコード(C1')を指す。そして、C1 レコードの
最初のフィールド(CAR 部)をC1'へのポインタに書き換える。
(図~\ref{fig-topdown-copy}(a))この参照ポインタ
は前方参照ポインタとして扱う。そして同じようにCONS の２番目のフィールド(C2)を
コピーし、前方参照ポインタを設定する。(図~\ref{fig-topdown-copy} (b))
参照点ｋから参照されているデータ
構造は旧面から新面への参照に変る。これらのポインタの付け直しの前後および
途中でも論理的にリスト[a,b]と一定している。\par


\begin{figure}[htbp]
\centerline{
\begin{tabular}{cc}
\epsfile{file=shm-topdown-copy1.eps,scale=0.7}&
\epsfile{file=shm-topdown-copy2.eps,%
        scale=0.7}\\
(a)&(b)
\end{tabular}
}
\caption{トップダウン コピー \label{fig-topdown-copy}}
\end{figure}

  この方式の問題は、(前方参照タグ方式と比較して)間接ポインタと前方参照ポイン
タ見分けが付かないことである。これら２者を識別しなければならない。我々の実装
では共有ヒープ上にポインタを作る場合は以下のような場合に限られている。
\begin{enumerate}
 \item 構造体要素から共有変数を指すポインタ
 \item 共有変数同士の単一化でできるポインタ
\end{enumerate}
(2)ではGCノードによって作られたもの(共有変数を旧面から新面にコピーした時の
ポインタ)か通常処理ノードによって作られたものかは識別できない。しかしこれら
は区別する必要がない。\par
(1)の場合、旧面から新面の共有変数へのポインタなら前方
参照ポインタと区別ができなくなる。そのようなポインタは通常処理ノードが局所メ
モリ上のネストした構造体をコピーするときに生まれる。ゆえに実行時のコピールー
チンでそのようなポインタができないように間接ポインタを差し入れるように修正し
た(この措置により通常処理に若干のオーバヘッドが加わっている)。\par
  この方式で更なる問題がもう一つある。新面のレコードから旧面を指すポインタの
存在である。新面に移った通常処理ノードは、直接GC中のそのようなポインタ
を参照してしまうことはないのだが、旧面を参照中の別の通常処理ノードからその
ようなポインタを受け取ってしまうことがある。ゆえに、この方
式では面を再利用する時、再利用する面を参照しているポインタを新面へのポインタ
にするための局所GCが必要である。
\end{description}

\subsubsection{コンパイル時のオプション}

GCの処理は、\filename{shm\_gc.c}にて行われているが、
コンパイル時のオプションにより行われる。このオプションについての説明を行う。

これらのオプションは、幾つかが関連があり、各々を独立にset/unsetしてはならない。

\begin{description}
\item[TOPDOWN/BOTTOMUP:\ ] どちらか1つをONにしても良い。
TOPDOWNをONにした時のみ、IAFWD/ISFWDに意味がある。

\item[ASYNC\_GC/SYNC\_GC:\ ] 通常実行に対して非同期にGCを行うか、行わないか
を指定する。どちらか一方のみを指定する。
SYNC\_GCとは、あるノードでGCを行うときには他の全てのノードはも通常実行をやめ、
GCを行うか、なにもしないか、どちらかとなる。

\item[PAR\_GC/SEQ\_GC:\ ] 同時に複数のノードでGCを行うことを
禁止するかどうか。SEQ\_GCでは単一のノードでのみGCを行う。

\item[IAFWD/ISFWD:\ ] 暗黙前方参照方式の、さらに詳細な処理分化
\footnote{詳細は現在不明。}
\end{description}


