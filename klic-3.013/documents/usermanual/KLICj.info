
このファイルは KLIC に関するドキュメントです。KLIC は KL1を移植実装す
るものです。このマニュアルは、 KLIC 3.002 版に相当します。

Copyright 1994, 1995 Institute for New Generation Computer
Technology\\ (詳細は「 ICOT 無償公開ソフトウェアの利用条件」を参照して
下さい。)\\ (C)1996, 1997, 1998, 1999 Japan Information Processing
Development Center\\ (配布その他は COPYRIGHT-JIPDEC ファイルを参照して
ください)




File: KLICj.info, Node: Top, Next: Copying, Prev: (dir), Up: (dir)

KLIC
****

KLIC とは、 KL1 を移植実装するものです。 KL1 は Guarded Horn Clauses
(略して GHC) に基づく、並行論理プログラミング言語です。KL1 の構文と意
味は非常に単純で簡潔ですが、並行計算向けの非常に強力な機能を提供してい
ます。

* Menu:

* Copying::                     ICOT 無償公開ソフトウェアの利用条件
* Copying of JIPDEC::           JIPDEC 無償公開ソフトウェアの利用条件
* Introduction::                初めに
* Language::                    KL1 とは
* Builtin and Library::         組込み述語とライブラリ機能
* Using KLIC::                  KLIC の使い方
* Type Index::                  データ型索引
* Predicate Index::             述語、メソッド、メッセージ名索引
* Module Index::                モジュール名索引
* Concepts::                    索引

 -- The Detailed Node Listing ---

初めに

* Description::                 述語とメソッドの説明について
* Reporting Bugs::              バグ報告とコメントの送付

述語とメソッドの説明について

* Predicates and Methods::      述語とメソッド
* Messages::                    メッセージ
* Argument Modes::              引数モード

KL1 とは

* Basics::                      基本的な実行の仕組み
* Predicates::                  述語
* Modules::                     モジュール
* Goals::                       ゴール
* Initial Goal::                初期ゴール
* Generic Objects::             ジェネリック・オブジェクト
* Priority::                    優先順位の指定
* Alternatively::               節の優先関係
* Argument Pair Notation::      引数対の簡略表記
* Inline C Code::               C 言語コードのインライン挿入

ジェネリック・オブジェクト

* Creating Objects::            ジェネリック・オブジェクトの生成
* Guard Methods::               ジェネリック・オブジェクトのガード・メソッド
* Body Methods::                ジェネリック・オブジェクトのボディ・メソッド

引数対の簡略表記

* Paired Arguments::            引数対と引数対の展開
* Macros for Paired Arguments:: 引数対のためのマクロ 
* Usage of Paired Arguments::   引数対の使い方

C 言語コードのインライン挿入

* Top Insertion::               ファイル先頭でのインライン挿入
* Guard Insertion::             ガード部でのインライン挿入
* C-Level Rep::                 KL1 項の C レベル表現
* Examples of Inline::          例
* Hints of Inline::             インライン C コード機能を使う上でのヒント

組込み述語とライブラリ機能

* Common Operations::           共通操作
* Atomic Data::                 アトム・データ
* Structured Data::             構造型データ
* Executable Code::             プログラム・コードのデータとしての扱い
* Unix::                        Unix インタフェース
* Input and Output::            入出力
* System Control::              システム動作の制御
* Timer::                       タイマ
* Random Numbers::              乱数生成器

共通操作

* Unification::                 単一化
* Synchronization::             同期
* Comparison and Hashing::      比較とハッシュ
* Execution Status::            実行ステータス
* Debugging::                   デバッグ

アトム・データ

* Symbolic Atoms::              記号アトム
* Integers::                    整数アトム
* Floating Points::             浮動小数点数

記号アトム

* Notation of Atoms::           記号アトムの表記
* Symbolic Atom Operation::     記号アトムの操作

整数アトム

* Notation of Integers::        整数アトムの表記
* Integer Arith::               整数演算
* Integer Comp::                整数比較

浮動小数点数

* Notation of Floats::          浮動小数点数の生成
* Creating Floats::             新しい浮動小数点数の生成
* Floating Arith::              浮動小数点演算
* Floating Comp::               浮動小数点比較

構造型データ

* Functors::                    ファンクタ構造
* Lists::                       リスト
* Vectors::                     ベクタ
* Strings::                     文字列

ファンクタ構造

* Notation of Functors::        ファンクタの表記
* Functor Operation::           ファンクタの操作

リスト

* Notation of Lists::           リストの表記
* Merging::                     メッセージストリームの操作

ベクタ

* Notation of Vectors::         ベクタの表記
* Creating Vectors::            ベクタの生成
* Predicates on Vectors::       ベクタの述語

文字列

* Notation of Strings::         文字列の表記
* Creating Strings::            文字列の生成
* Predicates on Strings::       文字列の述語

プログラム・コードのデータとしての扱い

* Module Type::                 モジュール
* Predicate Type::              述語

Unix インタフェース

* Unix Stream::                 Unix インタフェース・ストリームの獲得
* I/O Opening::                 入出力用ストリームのオープン
* Sockets::                     ソケットの使い方
* Files & Dirs::                ファイルとディレクトリ
* Signals::                     シグナル割込みの処理
* Misc Unix Messages::          Unix ストリームへのシュシュのメッセージ
* Predicate Interface::         述語インタフェース

入出力

* C-like I/O::                  C 風のインタフェースを用いた入出力
* Prolog I/O::                  Prolog 風のインタフェースを用いた入出力

C 風のインタフェースを用いた入出力

* Common Msgs (C style)::       C 風のインタフェースを用いた共通メッセージ
* Input Msgs (C style)::        C 風のインタフェースを用いた入力メッセージ
* Output Msgs (C style)::       C 風のインタフェースを用いた出力メッセージ

Prolog 風のインタフェースを用いた入出力

* Opening Prolog I/O::          Prolog 風の I/O ストリームのオープン
* Common Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Input Msgs (Prolog style)::   Prolog 風のインタフェースを用いたメッセージ
* Output Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Wrapped Terms::               ラップシタ項

KLIC の使い方

* Compiling::                   KLIC におけるプログラムのコンパイル
* Running::                     KLIC におけるプログラムの実行
* Tracing::                     プログラム実行のトレース
* Install::                     インストール
* Distributed KLIC::            分散 KLIC
* Shared-Memory KLIC::          共有メモリ KLIC

KLIC におけるプログラムのコンパイル

* Command for Compilation::     コンパイル用コマンド
* Compiler Options::            コンパイラ・オプション
* Mechanism of Compilation::    KLIC コンパイラの動作内容

KLIC におけるプログラムの実行

* Runtime Switches::            実行時オプション

プログラム実行のトレース

* Preparing for Trace::         トレース実行の準備
* Trace Ports::                 トレース・ポート
* Output of Tracer::            トレース表示のフォーマット
* Controlling Trace::           トレース制御コマンド
* Spying::                      スパイ
* Port Control::                トレース・ポートのコマンド
* Display Control::             表示を制御するコマンド
* Dumping Goals::               ゴールのダンプ
* Misc Trace Commands::         その他のコマンド
* Perpetual Suspension::        永久中断の探索

トレース制御コマンド

* Goal Control::                トレース対象ゴールのトレース制御
* Subgoal Control::             新しく生成されたサブゴールのトレース制御
* Predicate Control::           述語毎のトレース・スイッチのデフォルト値の変更

インストール

* Configuration::               コンフィギュレーション
* Make All::                    KLIC システムのコンパイル
* Make Tests::                  コンパイル結果のテスト
* Make Install::                オブジェクトのインストール
* Make Distclean::              インストールディレクトリのクリーン・アップ
* Troubles::                    うまく行かない場合

分散 KLIC

* Installation of Distributed KLIC::        分散 KLIC のインストール
* Compiling Programs for Distributed KLIC:: 分散 KLIC 向けプログラムのコンパイル
* Running Programs of Distributed KLIC::    分散 KLIC のプログラム実行

分散 KLIC のプログラム実行

* Setting Up PVM::                          PVM のセット・アップ
* Runtime Options for Distributed KLIC::    分散 KLIC の実行時オプション
* Known Bugs of Distributed KLIC::          分散 KLIC の既知のバグ

共有メモリ KLIC 

* Installation of Shared-Memory KLIC::      共有メモリ KLIC のインストール
* Compiling Programs for Shared-Memory KLIC::   共有メモリ KLIC 向けプログラムのコンパイル
* Running Programs of Shared-Memory KLIC::  共有メモリ KLIC のプログラム実行

共有メモリ KLIC のプログラム実行

* Runtime Options for Shared-Memory KLIC::  共有メモリ KLIC の実行時オプション
* Known Bugs of Shared-Memory KLIC::        共有メモリ KLIC の既知のバグ



File: KLICj.info, Node: Copying, Next: Copying Of JIPDEC, Prev: Top, Up: Top

ICOT 無償公開ソフトウェアの利用条件
***********************************

*1. ICOT無償公開ソフトウェアの目的*

財団法人新世代コンピュータ技術開発機構 (以下、"ICOT"という) は、日本国
通商産業省より委託され、第五世代コンピュータ・プロジェクトを推進してき
た。また、平成５年度からは、このプロジェクトの後継プロジェクトとして、
第五世代コンピュータの研究基盤化プロジェクトを推進している。第五世代コ
ンピュータ・プロジェクトおよびその後継プロジェクト(以下、これらの一連
のプロジェクトを"本プロジェクトという")は、並列推論処理を中核メカニズ
ムとする新しいコンピュータの基礎技術を創出し、その知見と技術を世界の研
究者と共有することによって、コンピュータ科学の発展に貢献することを目的
としている。

本プロジェクトによって、並列推論マシン、並列推論ソフトウェア技術といっ
た新しい技術が開発され、また、こうした技術開発に伴い、多くの先進的なソ
フトウェアが試作されている。これらのソフトウェアは、基礎的な研究開発段
階にあるため、多くの研究者に広め発展させていくべきものである。

そこで、 ICOT は、本プロジェクトの国際貢献の目的に鑑み、著作権が国では
なく ICOT に帰属することとなるこれらの研究開発段階のソフトウェアを、
「 ICOT 無償公開ソフトウェア」として公開してきた。これらのソフトウェア
については、研究開発のための障害となるいっさいの制約をはずすことによっ
て、多くの研究者の方々に自由に利用してもらい、新しいコンピュータ科学へ
の貢献を実践したいと考えている。

本プログラム及びドキュメント(以下、"本プログラム"という)は、" ICOT 無
償公開ソフトウェア"の 1 つとして、 ICOT において無償で配布しているもの
である。

*2. 使用、変更、複製、配布の自由*

本プログラムの"利用者"は、その使用、変更、複製を自由に行うことができる。
ここでいう変更には、本プログラムの機能、性能、品質を向上させるために改
良、拡張を行うこと、もしくは自ら開発したプログラムやドキュメントを本プ
ログラムに追加することが含まれるが、それだけには限定されない。

本プログラムの利用者は、本「 ICOT 無償公開ソフトウェアの利用条件」第3
項(*無保証*)が記されていることを*条件として*、関連法令に違反しない限り、
本プログラムそのもの、または本プログラムの変更版を第三者へ自由に配布す
ることが*できる*。

*3. 無保証*

本プログラムは、本プロジェクトの研究開発の試作物を『あるがまま』の状態
で提供するものである。このため、明示的であるか黙示的であるか、または法
令の規定により生ずるものであるか否かを問わず、一切の保証をつけないで提
供されるものである。ここでいう保証とは、プログラムの品質、性能、市場性、
特定目的適合性、および他の第三者の権利への無侵害についての保証を含むが、
それに限定されるものではない。

本プログラムの利用者は、本プログラムが無保証であることを承諾し、本プロ
グラムが無保証であることによるすべてのリスクを利用者自身で負うものとす
る。

従って、利用者が本プログラムを利用したこと、または利用できないこと、も
しくは本プログラムを利用して得られた結果に起因する一切の損害について、
著作権者である ICOT および本プログラムの開発に関与した関連機関並びにそ
れらの役職員及び従業員は、そのような損害の発生する可能性について、知っ
ていたか否かにかかわらず、何らの責任も負わない。本プログラムの利用者は、
本プログラムの利用を開始したことによりこれを承諾しているものとみなされ
る。ここでいう利用とは、本プログラムの使用、変更、複製、配布、二次的著
作物の作成を含むがこれらに限定されない。

利用者が本プログラムそのもの、または本プログラムの変更版を、 ICOT 以外
の第三者から配布を受けた場合においても、配布を行った第三者が独自に特別
な保証を文書で行わない限り、配布を行った第三者は、その利用者に対して、
本プログラムに関係する限りにおいて同様に何らの責任を負わないものとする。



File: KLICj.info, Node: Copying Of JIPDEC, Next: Copying, Prev: Top, Up: Top

JIPDEC 無償公開ソフトウェアの利用条件
*************************************

ICOTで開発されてきたKLICは、その後JIPDECのAITECにより開発が引き継がれ、
配布されています。よって、1996年以降の著作権はJIPDECにある旨記載してい
ます。

JIPDECのコピーライトが附属されている部分についての改変、配布等の条件は
「ICOT無償公開ソフトウェア」のそれと同じとします。つまり、「ICOT無償公
開ソフトウェアの利用条件」の"ICOT"とある部分をJIPDECとして読み替え適用
するようにしてください。

なお、JIPDECの著作ではないソースコードも存在しますが、それらについても
同様に「ICOT無償公開ソフトウェアの利用条件」の著作者、配布者を読み替え
適用してください。



File: KLICj.info, Node: Introduction, Next: Language, Prev: Copying Of JIPDEC, Up: Top

はじめに
********

このマニュアルでは、第五世代コンピュータの日本における国家プロジェクト
に関与した新世代コンピュータ開発機構と、その後継プロジェクトにおいて開
発された KLIC と呼ばれる移植性の高い KL1 の処理系について説明します。

KL1 は Garded Horn Clauses(略して GHC )に基づく、並行論理型プログラミ
 ング言語です。KL1 の構文と意味は非常に単純で簡潔ですが、並行計算向け
 の非常に強力な機能を提供しています。

KLIC は KL1 プログラムを C プログラムにコンパイルします。その後、ホス
ト・システムの C コンパイラが、 C プログラムを再配置可能なオブジェクト
にコンパイルします。続いて、再配置可能なオブジェクトは、 KLIC の実行時
ライブラリとともに一括してリンクされます(*Note KLIC コンパイラの動作内
容: Mechanism of Compilation.)。したがって、システムはホスト・システム
のハードウェア・アーキテクチャに依存しません。さらに、移植性を確保する
ため、システムは Unix の最小機能だけを使用するように書かれています。

* Menu:

* Description::                 述語とメソッドの説明について
* Reporting Bugs::              バグ報告とコメントの送付



File: KLICj.info, Node: Description, Next: Reporting Bugs, Prev: Introduction, Up: Introduction

述語とメソッドの説明について
============================

* Menu:

* Predicates and Methods::      述語とメソッド
* Messages::                    メッセージ
* Argument Modes::              引数モード



File: KLICj.info, Node: Predicates and Methods, Next: Messages, Prev: Description, Up: Description

述語とメソッド
--------------

他の論理型プログラミング言語システムと異なり、KLIC は述語とジェネリッ
ク・メソッドの 2 種類の手続きを提供します。述語はそれらの引数の関係を
定義し、意味は固定です。ジェネリック・メソッド(または、単にメソッド)は、
適用する*オブジェクト*が定義します。したがって、意味は適用されるオブジェ
クトに依存します。

述語とメソッドの両方で同じ操作を提供するものがあります。例えば、文字列
の要素は、次の 2 つのどちらかで操作できます。

 -- ボディ述語 on builtin: string_element +STRING +INDEX -ELEMENT
 -- ボディ・メソッド on string: element +STRING +INDEX -ELEMENT

前者は、システムの組込み述語で、述語の呼出しは次のように書きます。

     MODULENAME:PREDICATENAME(ARGUMENTS, ...)

上記の述語 `string_element' の場合は、組込み述語として定義されているの
で、呼出しにモジュール名は必要ありません。したがって、呼出しは次のよう
に書きます。

     string_element(STRING, INDEX, ELEMENT)

一般には、モジュール名がコロン (:) とともに先に書かれ、その後に述語名
が書かれます。述語によっては引数を全く持たないものもあります。そのよう
な場合、引数を囲む括弧も省略します。

後者は、`文字列'クラスのオブジェクトに対して定義されるジェネリック・メ
ソッドで、メソッドの呼出しは、次のように書きます。

     generic:METHODNAME(OBJECT, OTHERARGUMENTS, ...)

上記のメソッド `element' の呼出しは次のように書きます。

     generic:element(STRING, INDEX, ELEMENT)

述語とメソッドのどちらでも同じ操作が行えます。例えば、文字列 S の 3 番
目の要素(要素番号 2 )を E にとる場合、次に示すどちらの呼出しでもできま
す。

     string_element(S, 2, E)
     generic:element(S, 2, E)

述語 `string_element' は、文字列の要素をとることだけのものですが、一方、
ジェネリック・メソッドの呼出しは、*類似の*オブジェクトの要素をとるため
にも使えますので注意してください。例えば、ベクタ( 1 次元配列)の要素も、
同じ呼出しでとることができます。



File: KLICj.info, Node: Messages, Next: Argument Modes, Prev: Predicates and Methods, Up: Description

メッセージ
----------

KL1 プログラムは、多数の*プロセス*で構成することがよくあります。プロセ
スは、頻繁に*ストリーム*を使ってお互いに交信することがあります。ストリー
ムは、実際には*メッセージ*のリストです。リストは、 Lisp や類似の言語の
ように、 *car* と *cdr* の 2 個のフィールドを持つ*コンス*・セルと呼ば
れるセルからなっています。したがって、メッセージ・ストリームとして使う
場合、コンス・セルの car にはメッセージが、cdr にはストリームの残りが
入っています。

KLIC システムのいくつかの標準機能も、メッセージ・ストリームのインタフェー
スを持つプロセスとして提供されます。このマニュアルで説明するそのような
メッセージの例を次に示します。

 -- メッセージ on C 風の入出力: putc +C

これは、 `putc' という名前のメッセージが、C 風の I/O プロセスのインタ
フェース・ストリームへのメッセージであることを意味します。この場合、メッ
セージは C という名前の引数を 1 個持ちます。

メッセージ・ストリームにメッセージを送るために、メッセージ・ストリーム
を参照する変数を、コンス・セルで具体化します。例えば、 `S' が C 風の
I/O へのストリームで、コード 10を持つ文字を出力する場合、次のような単
一化を行います。

     S = [putc(10)|T]

ここで、変数 `T' にはストリームの残りが入るので、これ以後のストリーム
に対するメッセージはすべて、この変数に送ることになります。



File: KLICj.info, Node: Argument Modes, Prev: Messages, Up: Description

引数モード
----------
述語、メソッドまたはメッセージの引数は、特定の入出力モードを持つことが
あります。入力引数は、述語やメソッドの呼出しで読み込まれるので、入力引
数に未定義のものがあれば中断されます。出力引数には呼出しによって値が与
えられます。

述語とメソッドの説明では、入力引数には `+' を、出力引数には `-' を付け
てあります。引数の中には、読み込まれないものや値が与えられないものがあ
ります。そのような引数には `?' が付いています。



File: KLICj.info, Node: Reporting Bugs, Prev: Description, Up: Introduction

バグ報告とコメントの送付
========================

KLIC システムとこのドキュメントに関する、バグやコメントは、次のメイル・
アドレスに報告してください。

     `klic-bugs@icot.or.jp'.

KLIC のユーザのためのメイル・リストがあります。このメイル・リストは、
既知のバグ、バグ改修、新しいリリースなどについて、開発者からのアナウン
スに使います。同じメイル・リストをユーザ間のコミュニケーションにも使う
ことができます。メイル・リストへの申込みは、次のアドレスに送ってくださ
い。

     `klic-requests@icot.or.jp'




File: KLICj.info, Node: Language, Next: Builtin and Library, Prev: Introduction, Up: Top

KL1 とは
********

KL1 とは、 Guarded Horn Clauses(GHC) に基づいた、並行計算を記述するた
めのプログラミング言語です。GHC は、並行論理プログラミング言語、または
コミッティッド・チョイス言語と呼ばれる言語の系統に属しています。

他にこの系統に属する言語としては、例えば、 Concurrent Prolog、Parlog、
Fleng、Strand、Janus 等があります。これらの言語は、単純で簡潔な構文と
意味を持ちながら、並行計算向けに非常に強力な機能を提供しています。

ここでは、 KL1 言語の概略を紹介します。将来(できれば)、より正確で詳細
な記述を補う予定です。

* Menu:

* Basics::                      基本的な実行の仕組み
* Predicates::                  述語
* Modules::                     モジュール
* Goals::                       ゴール
* Initial Goal::                初期ゴール
* Generic Objects::             ジェネリック・オブジェクト
* Priority::                    優先順位の指定
* Alternatively::               節の優先関係
* Argument Pair Notation::      引数対の簡略表記
* Inline C Code::               C 言語コードのインライン挿入



File: KLICj.info, Node: Basics, Next: Predicates, Prev: Language, Up: Language

基本的な実行の仕組み
====================


次に、クイックソート・プログラムの一部を記述した、小さな KL1 プログラ
ムの例を示します。

例1:クイックソート

     :- module quicksort.

     sort(X, Y) :- sort(X, Y, []).

     sort([], Y, Z) :- Y = Z.
     sort([P|X], Y, Z) :-
         partition(P, X, X1, X2),
         sort(X1, Y, [P|Y1]),
         sort(X2, Y1, Z).

     partition(_, [], S, L) :-
         S = [],
         L = [].
     partition(P, [W|X], S, L) :- W =< P |
         S = [W|S1],
         partition(P, X, S1, L).
     partition(P, [W|X], S, L) :- W >= P |
         L = [W|L1],
         partition(P, X, S, L1).

最初の行 `:- module quicksort.' は、このプログラムモジュールが
`quicksort' というモジュールであることを宣言しています(*Note モジュー
ル: Modules.) 。

KL1 プログラムの実行とは、(可能ならば並列に行われる)リダクションの繰返
しによって、与えられた"ゴール"がプログラム"節"で繰り返され、リダクショ
ンして行くことです。各節は次のような形をしています。

     PREDICATENAME(ARGUMENT PATTERN ...) :- GUARD | BODY.

ゴールがリダクションされるときには、ゴール中の述語に対応するプログラム
中の節が調べられ、引数パターンに一致する節が見つかると、そのガード部が
調べられます。引数が一致し、ガード部の条件が満たされるような節は、リダ
クションに使用される候補となります。それらの候補のうちの任意の 1 つが、
リダクションに用いられ、元のゴールは、今*選ばれた候補*のボディ部の( 0
個以上の)ゴールによって置き換えられます。

ガード部のテストが必要ない場合、ガード部は、縦棒(|)と共に省略可能です。



File: KLICj.info, Node: Predicates, Next: Modules, Prev: Basics, Up: Language

述語
====

KL1 の"述語"は、 Fortran のサブルーチンや、 C の関数に相当します。述語
は、ヘッドが同じ述語名で同じ引数個数であるような節の集まりとして定義で
きます。他のいくつかの言語と異なり、述語は名前だけでなく、"アリティ(引
数個数)"によっても区別されます。同じ述語名でアリティが異なる述語を区別
するために、このマニュアルでは、`述語名/アリティ'という表記法を使用し
ます。

先ほどのクイックソートのプログラムでは、`sort' という名前の 2 引数と 3
引数の 2 つの述語が定義されていました(*Note 基本的な実行の仕組み:
Basics.)。このような述語を、 `sort/2' や `sort/3' と表します。

述語を定義する節の順序は、プログラムの意味には関係ありません。例えば、
2 つの整数の大きい方の値を出力する述語は、次のように定義できます。
     max(X, Y, M) :- X >= Y | M = X.
     max(X, Y, M) :- X =< Y | M = Y.
@noindent

また、同じ述語を次のように節の順序を逆にして定義することもできます。
     max(X, Y, M) :- X =< Y | M = Y.
     max(X, Y, M) :- X >= Y | M = X.

ある節の集まりが適用できない`ときに限り'、他の節の集合を適用したいとい
う場合には、 otherwise というキーワードを 2 つの節の集合の間に書く必要
があります。例えば、上記の述語 `max' を次のように定義することもできま
す。

     max(X, Y, M) :- X >= Y | M = X.
     otherwise.
     max(X, Y, M) :- M = Y.

この述語の意味は、先ほどの例とほぼ同じですが、 `X' や `Y' が整数でない
場合には、先ほどの 2 つの例では、実行が失敗するのに対し、この述語では、
`M' を `Y' と単一化するという点が異なっています。

`otherwise' 指示より後ろにある節は、それより前のすべての節が適用*でき
ない*ことが分かるまでは調べられません。このことは、後で何らかの情報(変
数の束縛)が追加された場合でも変わりません。otherwise 指示と
alternatively 指示を混同しないようにしてください。`alternatively' 指示
は、その指示よりも前にある節が、後ろにある節に比べて優先的に扱われるこ
とを示すものです(*Note 節の優先関係: Alternatively.)。



File: KLICj.info, Node: Modules, Next: Goals, Prev: Predicates, Up: Language

モジュール
==========

KL1 には、大きなプログラムをいくつかのモジュールに分割するためのモジュー
 ル構造があります。1 つのモジュールは、 1 つ以上の述語から構成されます。
 モジュールは、 `:- module モジュール名.' の形のモジュール宣言で始まり、
 その後に述語定義の節が続きます。1 つのモジュール定義は、ファイルの終
 わり、または別のモジュール宣言で終了します。先ほどのクイックソートの
 例で、次に示す最初の行
     :- module quicksort.

は、このプログラムモジュールが quicksort であることを宣言しています
(*Note 基本的な実行の仕組み: Basics.)。

同じ名前、同じ引数個数でも、異なったモジュールで定義された述語は、異な
る述語とみなされます。したがって、モジュール名を明示することが必要な場
合は、`モジュール:述語/アリティ'という表記法が用いられます。



File: KLICj.info, Node: Goals, Next: Initial Goal, Prev: Modules, Up: Language

ゴール
======

ゴールは、KL1 の実行の単位です。ゴールは述語と結び付けられています。ゴー
ルは、述語を定義する節の 1 つを用いて、0 個以上のより単純なゴールにリ
ダクションされます。

ゴールは以下のように記述されます。

     PREDICATE(ARGUMENTS, ...)

または、引数を持たない場合には、さらに簡単に

     PREDICATE

のように記述できます。

述語が同じモジュール内にない場合には、

     MODULE:PREDICATE(ARGUMENTS, ...)

または

     MODULE:PREDICATE

という構文になります。

quicksort モジュールを使う `main' モジュールは、例えば、次のようになり
ます(*Note 基本的な実行の仕組み: Basics.)。

例 2 : `quicksort' モジュールを使用

     :- module main.

     main :-
         X = [9,2,8,3,6,7,4,1,5],
         builtin:print(X),
         quicksort:sort(X, Y),
         builtin:print(Y).

上の例の `quicksort:sort(X, Y)' というボディ・ゴールは、 `quicksort'
モジュールの `sort/2' という述語を参照しています。



File: KLICj.info, Node: Initial Goal, Next: Generic Objects, Prev: Goals, Up: Language

初期ゴール
==========

すべての KLIC プログラムは、 `main:main' という初期ゴールから実行され
ます。つまり、 `main' モジュールで定義された、引数を持たない `main' と
いう述語です。モジュール `main' の例(*Note ゴール: Goals.)は、メイン・
プログラムの例です。コマンド行の引数は、初期ゴールには渡されません。コ
マンド行引数を得るための述語は、別途用意されています(*Note 述語インタ
フェース: Predicate Interface.)。



File: KLICj.info, Node: Generic Objects, Next: Priority, Prev: Initial Goal, Up: Language

ジェネリック・オブジェクト
==========================

"ジェネリック・オブジェクト"は、 KL1 に新しいデータ型やそれらの操作を
追加するための枠組みを提供します。ジェネリック・オブジェクトには、"デー
タ・オブジェクト"、"コンシューマ・オブジェクト"、"ジェネレータ・オブジェ
クト"という 3 種類があります。

ジェネリック・オブジェクトは、疑似述語 `generic:new' によって作成され
ます。ジェネリック・データ・オブジェクトは、通常の KL1 のデータと似て
います。データ・オブジェクトに対する操作は、それらに対する"ジェネリッ
ク・メソッド"という形で定義できます。メソッドは、疑似述語 `generic: メ
ソッド'によって呼び出されます。コンシューマ・オブジェクトやジェネレー
タ・オブジェクトは、通常の KL1 プログラムの変数と同じように見えるもの
であり、それらに対する操作は、単一化によって暗黙のうちに行われます。

KLIC が提供する標準データ型のいくつか、例えば、ベクタや文字列等は、実
際にはジェネリック・データ・オブジェクトとして実装されています。これら
に関するジェネリック・メソッドは、組込み述語としても呼び出せるようになっ
ています。例えば、 `set_vector_element(ORIGINAL,INDEX,NEWELEMENT,NEW)'
は、 `generic:set_element(ORIGINAL,INDEX, NEWELEMENT, NEW)' と同じこと
を意味します。

* Menu:

* Creating Objects::            ジェネリック・オブジェクトの生成
* Guard Methods::               ジェネリック・オブジェクトのガード・メソッド
* Body Methods::                ジェネリック・オブジェクトのボディ・メソッド



File: KLICj.info, Node: Creating Objects, Next: Guard Methods, Prev: Generic Objects, Up: Generic Objects

ジェネリック・オブジェクトの生成
--------------------------------

ジェネリック・オブジェクトは、次に示す疑似述語によって生成されます。

     generic:new(CLASSNAME, OBJECT, ARGS, ...)

CLASSNAME は、オブジェクトのクラス名を示す記号アトムです。
この疑似述語の呼出しによって、新しくジェネリック・オブジェクトが生成され、 OBJECT で指定された変数に結び付けられます。
ジェネリック・オブジェクト生成時に必要なパラメタは、 ARGS で与えます。
ARGS の意味は、それぞれのオブジェクト・クラスに依存します。



File: KLICj.info, Node: Guard Methods, Next: Body Methods, Prev: Creating Objects, Up: Generic Objects

ジェネリック・データ・オブジェクトのガード・メソッド
----------------------------------------------------

ガード・メソッドを呼ぶことで、ジェネリック・データ・オブジェクトに依存
して節が選択できます。ガード・メソッドは、以下の形式を持っています。

     generic:METHOD(OBJECT, INPUT, ...):OUTPUT:...

`INPUT, ...' では、入力引数を指定します。もし、入力引数のどれかが未定
義のままである場合には、この呼出しは中断されます。`OUTPUT:...' では、
出力引数を指定し、このメソッドからの返却値がここに入れられます。もし、
OUTPUT が既に何らかの具体値を持っていた場合には、その値と返却値との間
のガード・ユニフィケーションが行われます。ガード・メソッドが返却値を持
たない場合には、コロン(:)とそれに続く OUTPUT は省略されます。



File: KLICj.info, Node: Body Methods, Prev: Guard Methods, Up: Generic Objects

ジェネリック・データ・オブジェクトのボディ・メソッド
----------------------------------------------------

ジェネリック・データ・オブジェクトに対する操作は、次に示すボディ・メソッ
ドの呼出し形式で行います。

     generic:METHOD(OBJECT, ARGS, ...)

ガード・メソッドとは異なり、入力引数と出力引数は構文的には区別されませ
ん。また、実行時に動的に呼び出されるメソッドを決めることもできます。そ
の場合は、次の呼出し形式を用います。

     generic:generic(OBJECT, FUNCTOR)

この呼出し形式では、 FUNCTOR は(コンパイル時、または実行時に) `METHOD(ARGS,...)' というファンクタ構造でなければなりません。
FUNCTOR が未定義の場合、具体化されるまで呼出は中断します。



File: KLICj.info, Node: Priority, Next: Alternatively, Prev: Generic Objects, Up: Language

優先順位の指定
==============

ゴールには、実行優先度 (Execution Priority) が付いています。実行優先度
には、正の整数を指定します。大きな優先度を持つゴールは、(通常)小さな優
先度を持つゴールよりも先に実行されます。しかし、優先度の指定は単なる示
唆にすぎず、実装方式によっては、優先度が厳密に守られないこともあります。

ボディ・ゴールの実行優先度は、次の形式で指定されます。

             `GOAL@priority(ABSPRIO)'
             `GOAL@lower_priority'
             `GOAL@lower_priority(RELPRIO)'

上記の ABSPRIO と RELPRIO は、負以外の整数定数、または実行時に負以外の
整数になるような変数でなければなりません。現在の実装方式では、優先度に
負が指定された場合には 0 が指定されたものとして扱われます。

priority による絶対優先度指定によって、ゴールには ABSPRIO で指定された
優先度が与えられます。@lower_priority(RelPrio) による相対優先度指定で
は、ゴールは親のゴールの優先度より RelPrio だけ小さい優先度を持ちます。
`GOAL@lower_priority' という指定は、 `GOAL@lower_priority(1)' と同じ効
果を持ちます。優先度指定のないゴールは、親のゴールと同じ優先度を持ちま
す。

優先度の最大値は整数の最大値であり、ホスト・システムに依存します(*Note
整数アトム: Integers.)。初期ゴール `main:main' は、ホストシステムにお
いて最大の優先度を持ちます(*Note 初期ゴール: Initial Goal.)。



File: KLICj.info, Node: Alternatively, Next: Argument Pair Notation, Prev: Priority, Up: Language

節の優先関係
============

KL1 の述語では、 2 つ以上の節が適用可能なために非決定性を持つことがあ
ります。その場合、節同士の優先関係を `alternatively' 指示によって指定
できます。

`alternatively' というキーワードを 2 つの節の集合の間に書いた場合、
`alternatively' より前の節が、後ろの節よりも*優先的に*選ばれます。もし、
`alternatively' 指示より前の節が情報不足(変数値の具体化が足りず)のため、
選択不可能な場合、この指示よりも後の節が選択の対象となります。この機能
は、実行状況に依存した投機的実行 (speculative execution) の制御に利用
できます。

alternatively と `otherwise' を混同しないでください(*Note 述語:
Predicates.)。例えば、次の 2 つの述語を考えてみます。

     p(1, Y, R) :- R = a.
     alternatively.
     p(X, 2, R) :- R = b.

     q(1, Y, R) :- R = a.
     otherwise.
     q(X, 2, R) :- R = b.

第 1 引数が未定義で、第 2 引数が `2' の場合、述語 `p' は 2 番目の節の
実行によって第 3 引数に `b' を返しますが、述語 `q' は第 1 引数が束縛さ
れるまで待ちます。つまり、第 1 引数が最終的に `1' になるならば、述語
`q' では `a' が返されることが保証されますが、述語 `p' では `a' か `b'
のどちらかが返されることになります。



File: KLICj.info, Node: Argument Pair Notation, Next: Inline C Code, Prev: Alternatively, Up: Language

引数対の簡略表記
================

KL1 のプログラムでは、述語に対して 1 つを入力、 1 つを出力というように
 2 つの引数を対として与えることがよくあります。KLIC では、このような場
 合のために簡略表現を用意しています。

* Menu:

* Paired Arguments::            引数対と引数対の展開
* Macros for Paired Arguments:: 引数対のためのマクロ 
* Usage of Paired Arguments::   引数対の使い方



File: KLICj.info, Node: Paired Arguments, Next: Macros for Paired Arguments, Prev: Argument Pair Notation, Up: Argument Pair Notation

引数対と引数対の展開
--------------------

述語のヘッドや、ガード部やボディ部にあるゴールに対して、 1 つの変数名
をマイナス符号で続けることで、引数対を与えることができます。この疑似変
数名は、マクロ展開のために用いられる変数名であり、通常の KL1 の変数と
区別するために"引数対名"と呼びます。次に例を示します。

     p(X,Y)-Pair :- q(X)-Pair, s(Z)-Pair, r(Pair,Y), t(Z)-Pair.

この場合、疑似変数 `Pair' が引数対名です。この節は、次の節と同じである
と解釈されます。

     p(X,Y,P0,P) :- q(X,P0,P1), s(Z,P1,P2), r(P2,Y), t(Z,P2,P).

ヘッドやゴールに付いているマイナス符号に続く引数対名は、引数列の最後に
追加された 2 つの異なった変数の対と解釈されます。これ以後、この 2 つの
変数を、引数対から生成された"展開対"と呼びます。

あるゴールの中の展開対の 2 番目の変数は、次の同じ引数対名を持つゴール
の展開対の 1 番目の変数と同じです。上の例では、 `P1' はゴール `q/3' の
第 3 引数に現れ、また `s/3' の第 2 引数にも現れています。これらは、元々
同じ引数対名 `Pair' だったものです。

ヘッドにある展開対の 1 番目の変数は、節内で同じ引数対名を持つ最初のゴー
ルの展開対の 1 番目の変数と同じです。またヘッドにある展開対の 2 番目の
変数は、節内で同じ引数対名を持つ最後のゴールの展開対の 2 番目の変数と
同じです。

上の例では、ヘッドにある展開対の 1 番目の変数 `P0' が、最初のゴール 
`q/3' の第 2 引数にも現れており、ヘッドにある展開対の 2 番目の変数 
`P' は、最後のゴール `t/3' の第 3 引数にも現れています。

引数対名がヘッドにしか現れていない場合には、展開対の 2 つの変数がボディ
において単一化されるコードが生成されます。例えば、

     p(X)-Y :- q(X).

は、次のように展開されます。

     p(X,Y0,Y) :- Y0=Y, q(X).

先ほどの例では、ゴール `r/2' の 1 番目の引数に見られるように、引数対名
は、ヘッドやボディにマイナス符号を付けて指定されるだけでなく、通常の引
数位置に置かれることもあります。この場合、引数対名は、単一の変数に展開
されます。この変数は、直前の展開対の 2 番目の変数と同じで、直後の展開
対の 1 番目の変数とも同じです。したがって、この例では、 `r/2' の第 1
引数 `Pair' は `P2' に展開され、これは `s/3' の第 3 引数および `t/3'
の第 2 引数と同じになります。

ゴールやヘッドには、任意の数の引数対名が書けます。例えば、次の例で、

     p-X-Y :- q-X, r-Y, s-Y-X.

は、次のように解釈されます。

     p(X0,X,Y0,Y) :- q(X0,X1), r(Y0,Y1), s(Y1,Y,X1,X).

時には、通常の引数を引数対名の後に指定したくなる場合もあるでしょう。そ
の場合には、プラス符号 `+' の後ろに通常の引数を付けることで指定できま
す。例えば、

     p-X+Y :- q-X+35, r(Y), s+Y-X.

は、次のように解釈されます。

     p(X0,X,Y) :- q(X0,X1,35), r(Y), s(Y,X1,X).

以上、述べた引数対の展開規則は、ゴールの位置に依存することに注意してく
ださい。しかし、これによってボディ・ゴールの実行順序が何らかの制約を受
けることを意味するものでは全く*ありません*。

引数対の記法は、節のマクロ展開にすぎないということも覚えておいてくださ
 い。1 つの述語のいくつかの節を引数対の記法を用いて書き、他の節は通常
 の記法で書くことも可能です。



File: KLICj.info, Node: Macros for Paired Arguments, Next: Usage of Paired Arguments, Prev: Paired Arguments, Up: Argument Pair Notation

引数対のためのマクロ
--------------------

KLIC では、引数対をより多くの場面で利用するため、次のようなマクロを用
意しています。

S <= M
     `S0 = [M|S1]' に展開されます。 
     S0 と S1 は引数対名 S を展開した展開対です。

M => S
     `[M|S0] = S1' に展開されます。 
     S0 と S1 は引数対名 S を展開した展開対です。

S += E
S -= E
S *= E
S /= E
      `S1 := S0 + E0' 等に展開されます。 
     S0 と S1 は引数対名 S を展開した展開対です。

S <== X
     `S1 = X' に展開されます。  S0 と S1 は引数対名 S を展開した展開対
     です。  S0 は展開型には現れません。つまり、元々の引数対 S の値は
     失われます。その代わり、次から現れる S は X を意味することになり
     ます。このマクロは、通常、引数対が対にならずに出現する場合に用い
     られます。例えば、

          ..., p-S, q(S), S <== X, r-S, ...

     は、次のことを意味します。

          ..., p(S0,S1), q(S1), S2 = X, r(S2,S3), ...



File: KLICj.info, Node: Usage of Paired Arguments, Prev: Macros for Paired Arguments, Up: Argument Pair Notation

引数対の使い方
--------------

ここでは、引数対の標準的な使用例をいくつか示します。

次のプログラムは、整数リストの各要素を加え合わせるプログラムです。

     sum(List,Sum) :- sum(List)+0+Sum.

     sum([])-Acc.
     sum([H|T])-Acc :- Acc += H, sum(T)-Acc.

ここでは、引数対 `Acc' はアキュムレータの役割を果たします。

次のプログラムは、整数リストの各要素の符号を反転します。

     inv(List,Inv) :- inv(List)+Inv-[].

     inv([])-Inv.
     inv([H|T])-Inv :- MH := -H, Inv <= MH, inv(T)-Inv.



File: KLICj.info, Node: Inline C Code, Prev: Argument Pair Notation, Up: Language

C 言語コードのインライン挿入
============================

インライン C コード機能によって、 KL1 プログラム中にオブジェクト・コー
ドの中に埋め込む C プログラムが記述できます。この機能は、 C における
`asm' 文に多少似ています。

挿入された C コードが適切なものであるか否かは、 KLIC システムの内部実
装方法に完全に依存します。そして、これは将来変わるかもしれません。した
がって、*一般ユーザがこの機能を使うことは勧められません。*

* Menu:

* Top Insertion::               ファイル先頭でのインライン挿入
* Guard Insertion::             ガード部でのインライン挿入
* C-Level Rep::                 KL1 項の C レベル表現
* Examples of Inline::          例
* Hints of Inline::             インライン C コード機能を使う上でのヒント



File: KLICj.info, Node: Top Insertion, Next: Guard Insertion, Prev: Inline C Code, Up: Inline C Code

ファイル先頭でのインライン挿入
------------------------------

ソース・ファイルの先頭では、以下の方法によって C プログラムに挿入され
る文字列が指定できます。

     :- inline:"挿入されるべきCプログラム・テキスト".

オブジェクトの C プログラム中では、ここで指定したテキストは、標準的な
宣言の後で、かつユーザが定義したモジュールの前に挿入されます。

インライン指定は、いくつも書くことができます。標準的な例を次に示します。

     :- inline:"#include <stdio.h>"

挿入される C プログラムは、 KLIC の文字列定数として書く必要があるので、
C 中の二重引用符文字は、バックスラッシュ (\) によってエスケープする必
要があります。典型的な例は次のとおりです。

     :- inline:"#include \"myheader.h\""

この部分で、節のガード部に書くインライン・コードで使用するマクロや関数
を定義しておくのは、良い考えかもしれません。



File: KLICj.info, Node: Guard Insertion, Next: C-Level Rep, Prev: Top Insertion, Up: Inline C Code

ガード部でのインライン挿入
--------------------------

次に示す形式のどちらかを使って、ガード・ゴールでもインライン挿入が指定
できます。

     inline:"Cプログラム・テキスト"
     inline:"Cプログラム・テキスト":[ARGSPEC, ...]

どちらの形式でも、プログラム・テキスト文字列中のパーセント記号 (`%')
が特別なフォーマットを指定することの他は、 C プログラムのテキストは指
定したとおり、ガード部に対応するオブジェクト・コード中に挿入されます。
次の表に、パーセント記号の後ろに指定される特殊なフォーマット文字とその
意味を列挙します。

数字
     数字番目(ゼロから始まる)の ARGSPEC に対応する C 変数の名前。10 個
     までの引数しか許されないので注意してください。

f
     この節が失敗や中断した場合に、分岐する `goto' の分岐先ラベルの名前

%
     パーセント文字自身

ARGSPECは、次のいずれかの形式です

変数+型
     挿入されたプログラム・テキストが、変数の値を使用することを指示し
     ます。オブジェクト・コードには、コンパイラによって、同期と型チェッ
     クのために必要なコードが生成されます。

変数-型
     挿入されたプログラム・テキストによって変数に値が与えられることを
     意味します。この変数は、ここで最初に出現するものでなければなりま
     せん。コンパイラは挿入されたコードを実行した後は、変数が型の値を
     持つと、仮定されます。

型フィールドは、以下のいずれかでなければなりません。

any
     未束縛の変数を含む任意のもの
bound
     任意の束縛されているもの
atomic
     アトム値(アトムまたは整数)
int
     整数
atom
     記号アトム
list
     リスト構造
functor
     ファンクタ構造(ジェネリック・オブジェクトを含む)
object
     ジェネリック・データ・オブジェクト
object(Class)
     クラスが CLASS であるようなジェネリック・データ・オブジェクト

`any' 以外の型では、間接表現は取りません。入力モード (`+') 引数では、
コンパイラが出力するコードによって、挿入されたプログラム・テキストが実
行される時点では、引数は間接参照ではなく、指定した型の値そのものである
ことが保証されています。逆に、出力モード (`-') 引数では、挿入されたプ
ログラム・テキストの実行後は、その変数の値は間接参照ではなく、指定した
型の値そのものであるとコンパイラは仮定しており、この情報を最適化のため
に利用します。もし、出力変数に関するこの仮定に確信が持てない場合には、
効率は悪いが安全な型として `any' を指定してください。



File: KLICj.info, Node: C-Level Rep, Next: Examples of Inline, Prev: Guard Insertion, Up: Inline C Code

KL1 項の C レベル表現
---------------------

KL1 変数に対応する C の変数の型は、 KL1 のデータ型から推測される C の
型とは違うことに注意してください。

KL1 変数に対応する C の変数はすべて、 1 ワードを占めるという以外の意味
を持たない `q' という型を持ちます。また、 KL1 の値は(タグが付加される
等によって)エンコードされています。例えば、 KL1 における整数 3 は、 C
の整数 3 とは*異なった*ビットパターンを持ちます。

このドキュメントは、 KLIC におけるデータ表現形式の詳細を表すことを目的
としたものではありませんし、そのような記述や、それに依存するプログラム
は、将来の KLIC の版では、使えなくなるでしょう。しかしながら、インライ
ン機能を用いて書かれるほとんどの C のプログラムにおいて、整数値の操作
は最も簡単で役に立つものなので、整数のためのデータ変換用マクロを以下に
説明します。これらは将来のバージョンにおいても変更されることはないでしょ
う。

C の変数から KL1 の整数値に対応する整数値を得るには、`intval(X)' とい
うマクロを用います。C の整数を KL1 表現にするには、`makeint(N)' を用い
ます。



File: KLICj.info, Node: Examples of Inline, Next: Hints of Inline, Prev: C-Level Rep, Up: Inline C Code

例
--

*例1: 2 つの整数の加算*

 2 つの整数は、次の節によって加算できます。

         p(X,Y,Z) :- W := X+Y | Z = W.

同じ機能は、次のようにインライン機能を用いて実現できます。

     p(X,Y,Z) :-
       inline:"%2 = makeint(intval(%0)+intval(%1));":
         [X+int, Y+int, W-int] | Z=W.

挿入されるテキストは、次のようになります。

     x0 = makeint(intval(a0)+intval(a1));

変数 `a0' と `a1' は KL1 プログラムの `X' と `Y' に対応し、 `x0' は
`W' に対応します。

*例 2: 2 つの整数の比較*

 2 つの整数は、次の節によって比較できます。

     p(X,Y) :- X > Y | ...

同じことは、インライン機能を用いて次のように実現できます。

     p(X,Y) :-
       inline:"if (intval(%0) <= intval(%1)) goto %f;":
         [X+int, Y+int] | ...

挿入されるテキストは、次のようになります。

     if (intval(a0) <= intval(a1)) goto p_2_interrupt;

変数 `a0' と `a1' は、 KL1 プログラムの `X' と `Y' に対応し、
`p_2_interrupt' はコンパイラによって自動的に生成されたラベルです。



File: KLICj.info, Node: Hints of Inline, Prev: Examples of Inline, Up: Inline C Code

インライン C コード機能を使う上でのヒント
-----------------------------------------

   * できる限りインライン機能を使うのは避けてください。  KL1 の版によっ
     ては、コードが使えなくなるかもしれません。

   * 複数の行を連続して挿入する場合には、 1 回のインライン記述にそれら
     すべてを書いてください。そうでないと、コードの間にガードのための
     他のコードが割り込むかもしれません。挿入するプログラム・テキスト
     には改行を入れることが許されています。

   * 二重引用符やバックスラッシュの前にはバックスラッシュを付けること
     を忘れないでください。Hello, world と出力したいならば、次のように
     書く必要があります。

          hello :-
              inline:"printf(\"Hello, world\\n\");" |
              ...

     二重引用符の前のバックスラッシュと `n' の前の 2 つのバックスラッ
     シュに注意してください。もし `n' の前にバックスラッシュを 1 つし
     か付けないと、インライン展開の結果、これは改行コードとなってしま
     います。この改行コードは展開された C プログラムの中で文字定数内に
     入り、途中で改行された文字列となります。幸運にもこの場合は、バッ
     クスラッシュを 2 つ入れた場合と同じように動きますが、 C コンパイ
     ラによっては警告メッセージが出力されるかもしれません。

   * もし、インライン・コードを含むプログラムが期待どおりに動かない場
     合には、生成された C コードを調べることが、問題を見つける最良の方
     法かもしれません。




File: KLICj.info, Node: Builtin and Library, Next: Using KLIC, Prev: Language, Up: Top

組込み述語とライブラリ機能
**************************

この章では、 KLIC の組込み述語とライブラリ機能について説明します。

* Menu:

* Common Operations::           共通操作
* Atomic Data::                 アトム・データ
* Structured Data::             構造型データ
* Executable Code::             プログラム・コードのデータとしての扱い
* Unix::                        Unix インタフェース
* Input and Output::            入出力
* System Control::              システム動作の制御
* Timer::                       タイマ
* Random Numbers::              乱数生成器



File: KLICj.info, Node: Common Operations, Next: Atomic Data, Prev: Builtin and Library, Up: Builtin and Library

共通操作
========

述語には、すべてのデータ型に共通するものや依存しないものなどがあります。

* Menu:

* Unification::                 単一化
* Synchronization::             同期
* Comparison and Hashing::      比較とハッシュ
* Execution Status::            実行ステータス
* Debugging::                   デバッグ



File: KLICj.info, Node: Unification, Next: Synchronization, Prev: Common Operations, Up: Common Operations

単一化
------
 -- ガード述語 on builtin: = ?X ?Y
      X と Y が単一化可能か否かをチェックします。この述語の結果は、他
     の節で説明する変数には影響しません。

 -- ボディ述語 on builtin: = ?X ?Y
      X と Y を単一化します。X が未定義で、かつ Y が具体値である場合、
      X を Y と同じ値にします。Y が未定義で、かつ X が具体値である場合、
      Y を X と同じ値にします。両方が未定義の場合、2 つの変数は、同じ
      変数を意味するようになります。両方が具体値の場合、マッチング処理
      を行います。両方が同じ種類のデータ構造の場合、この単一化操作を、
      2 つの構造の対応する要素に対して再帰的に行います。



File: KLICj.info, Node: Synchronization, Next: Comparison and Hashing, Prev: Unification, Up: Common Operations

同期
----
 -- ガード述語 on builtin: wait +X
      X が具体化されるまで待ちます。



File: KLICj.info, Node: Comparison and Hashing, Next: Execution Status, Prev: Synchronization, Up: Common Operations

比較とハッシュ
--------------
 -- ガード述語 on builtin: compare +X +Y -R
      X と Y を比較し、R へ結果を返します。
      X < Y の場合、R < 0 の整数値にします。
      X = Y の場合、R = 0 にします。
      X > Y の場合、R > 0 の整数値にします。

     比較は、以下に示した標準順序に従って行います。この述語では、色々
     な型のデータが比較できます。X と Y の両方が同じ数値型の場合、通常
     の数値比較を行います。ただし、整数と浮動小数点数は、同じ型ではな
     いので注意してください。このような比較を行なっても意味が*ありませ
     ん*。文字列の場合は、(いわゆる)辞書式順序で比較します。

     型の異なる任意の 2 つのデータの順序は、システムによって定義されま
     す。ただし、この順序付けは、単独の実行可能プログラム内でしか保証
     しません。この述語が提供する順序付けを使用して、データ列をファイ
     ルに保存しても、プログラムを、再コンパイルしたり、他のプログラム
     とリンクしたりすると、そのプログラムには、データ列を順序どおりに
     認識するという保証がなくなってしまいます。プログラムが異なると当
     然、順序付けも異なってきます。

     比較を行うためには、X と Y がともに、十分具体化されていなければな
     りません。例えば、`f(V) @< f(W)' は、`V' と `W' の両方が具体化さ
     れない限り、比較の処理を中断します。これに対し、`f(1,V) @<
     f(2,W)' は、`V' や `W' の値を調べるまでもなく、順序が決定できるの
     で成功します。

     データ型によっては、結果 R の絶対値が意味を持つ場合があります。2
     つの文字列の比較の場合、結果 R の絶対値は、最初に異なる要素位置を
     示す(Cの`strcmp'の)インデックスよりも 1 つ大きな値になります。

     ジェネリック・オブジェクトは、比較メソッドを実装しない場合があり
     ます。このような場合、その比較は、重大エラーを引き起こすことにな
     ります。

 -- ガード述語 on builtin: @< +X +Y
 -- ガード述語 on builtin: @=< +X +Y
 -- ガード述語 on builtin: @>= +X +Y
 -- ガード述語 on builtin: @> +X +Y
     標準順序で X と Y を比較します。条件を満たさない場合、述語の呼出
     しは失敗します。

 -- ガード述語 on builtin: \= +X +Y
      X と Y を比較し、主ファンクタが異なる場合だけ成功します。アトム
     値の場合、それらが異なるアトムであることを意味します。ファンクタ
     構造の場合、それらが異なるファンクタ名を持つか、または異なる引数
     個数を持つか、のどちらかであることを意味します。ジェネリック・オ
     ブジェクトの場合、2 つのオブジェクトが異なるクラスのときに成功し
     ます。

     `f(a) \= f(b)' は、2 つの項が同じ主ファンクタを持つ場合、失敗する
     ので注意してください。浮動小数点数はジェネリック・オブジェクトな
     ので、任意の 2 つの浮動小数点数が同じクラスのオブジェクトの場合、
     `X \= Y' は失敗するのでこの場合にも注意してください。

 -- ガード述語 on builtin: hash +X -H
      X のハッシュ値を計算し、その結果を H へ返します。ハッシュ値は、
     負以外の整数値です。

     ハッシュ機能は、構造型データの要素を再帰的に調べます。ハッシュ値
     を計算するには、X は、十分に具体化されていなければなりません。ジェ
     ネリック・オブジェクトは、ハッシュ・メソッドを実装しない場合があ
     ります。このような場合、そのハッシュ値は定数値となります。



File: KLICj.info, Node: Execution Status, Next: Debugging, Prev: Comparison and Hashing, Up: Common Operations

実行ステータス
--------------

 -- ガード述語 on builtin: current_priority -P
     リダクションしたゴールの優先順位の値を P へ返します。優先順位の仕
     組みについての詳細は、*Note 優先順位の指定: Priority。

 -- ボディ述語 on builtin: current_node -NODE -NUMNODES
     並列実装では、述語を実行するノード番号を NODE へ、使用可能な実行
     ノード総数を NUMNODES へ返します。初期ノード番号は、0 です。この
     ため、NODE へ返す最大値は、NUMNODES へ返す値より小さくなります。
     逐次実装では、NODE へ 0 を、NUMNODES へ 1 を返します。



File: KLICj.info, Node: Debugging, Prev: Execution Status, Up: Common Operations

デバッグ
--------

 -- ボディ述語 on builtin: unbound ?X -RESULT
      X が、未定義変数か否かをチェックし、その結果を RESULT へ返します。

     X が未定義変数でない場合、RESULT には、形式 {X} の単一要素のベクタを単一化します。
      X が構造体の場合、その要素が未定義変数でない、という保証はありません。

     X が未定義変数の場合、RESULT には、形式 {ADDR1, ADDR2, X} の 3 つ
     の要素ベクタを単一化します。ADDR1 と ADDR2 は、変数 X の現在のア
     ドレスを示す整数となります。変数のアドレスは、ガーベージ・コレク
     ション、並列実装における自動データ移動、または低レベル実装などに
     よって、変化するので注意してください。これらは、デバッグする上で
     は、ヒント以上の情報にはなり得ません。

     *通常のアプリケーション・プログラムでは、この述語を使用してはなり
     ません。* 逐次 Prolog の `var/1' 機能とは異なり、並列実装では、未
     定義であると判断された直後に、未定義でなくなる可能性があります。
     したがって、この述語の使用は、システム実装の低レベルを詳細に調べ
     る、デバッグツールのようなプログラムに限定されます。




File: KLICj.info, Node: Atomic Data, Next: Structured Data, Prev: Common Operations, Up: Builtin and Library

アトム・データ
==============

KLIC は、数値と記号の 2 種類のアトム・データ型を提供します。

KLIC は、数値データに対し、整数と浮動小数点数のデータ型、およびそれら
を操作する演算を提供します。浮動小数点数は、ジェネリック・オブジェクト
として実装されているため、実際にはアトムではありません。

整数データと浮動小数点データ間では、暗黙の型変換は行わないので注意して
ください。整数と浮動小数点数は、完全に別個のものとして扱います。

データがアトムか否かは、次のガード述語でテストします。

 -- ガード述語 on builtin: atomic +X
      X がアトムか否かをテストします。この述語では、浮動小数点数は、ア
     トムとして判定*しません*。

* Menu:

* Symbolic Atoms::              記号アトム
* Integers::                    整数アトム
* Floating Points::             浮動小数点数



File: KLICj.info, Node: Symbolic Atoms, Next: Integers, Prev: Atomic Data, Up: Atomic Data

記号アトム
----------

"記号アトム"(symbolic atoms)は、概念に名前を与えるアトム・データです。
同じ名前を持つ記号アトムは同じものであり、異なる名前を持つ記号アトムは
異なるものとなります。

* Menu:

* Notation of Atoms::           記号アトムの表記
* Symbolic Atom Operation::     記号アトムの操作



File: KLICj.info, Node: Notation of Atoms, Next: Symbolic Atom Operation, Prev: Symbolic Atoms, Up: Symbolic Atoms

記号アトムの表記
................

記号アトムの表記は、次に示すように Edinburgh Prolog に似ています。

   * 先頭がアルファベットの小文字で、そのあとに任意個(ゼロ個を含む)の
     文字、数字 、または下線の並びが続きます。

     例:
          icot   kl1   a_symbolic_atom_with_a_long_name

   * 特殊文字の並び(`~',`+',`-',`*',`/',
      `\',`^',`<',`>',`=',``'(backquote),
      `:',`.',`?',`@',`#',`$',`&').

     例 :
          +   >=   :-   =:=

   * 単一引用符で囲まれた任意の文字の並び単一引用符が文字の並びに含ま
     れる場合は、 2 個続けるか、またはバックスラッシュ (\) を前に付け
     てエスケープします。

     例 :
          'Hello world'    'an atom with \'singlequotes\' in it'

   *  1 文字の特殊アトムには `!'、`|'、および `;' の 3 種類があります。
     なお、`|' はリスト表記では、特別な意味を持っています( *Note リス
     トの表記: Notation of Lists.)。

   * 特殊アトムの `[]' は通常、リストの終端を表わすために使用します
     ( *Note リスト: Lists. )。
      `[' と `]' の間には、空白を許しています。

Edinburgh Prolog の構文と異なる点のうち、重要なものを以下に示します。

   * 縦棒(`|')は、 1 文字アトムを表します。演算子として使用する場合で
     も、セミコロン(`;')と同じ扱いは*せず*、異なるアトムとして扱います。

   *  1 対の中括弧(`{}')は、記号アトムではありません。要素のないベクタ
     を表します(*Note ベクタの表記: Notation of Vectors.)。



File: KLICj.info, Node: Symbolic Atom Operation, Prev: Notation of Atoms, Up: Symbolic Atoms

記号アトムの操作
................

データが記号アトムか否かは、次のガード述語でテストします。

 -- ガード述語 on builtin: atom +X
     X が記号アトムか否かをテストします。

記号アトムの一意性を保持するために、処理系では、各記号アトムに一意な番
号を付けて、記号アトムの名前文字列と記号アトム番号との関係を保持してい
ます。記号アトムと名前の関係は、`atom_table' モジュールで定義した次の
述語によって調べることができます。

 -- 述語 on atom_table: make_atom +STRING -ATOM
     STRING が与えられたとき、その名前を持つ ATOM を返します。そのよう
     な記号アトムが存在しない場合、新しい記号アトムを登録します。

 -- 述語 on atom_table: atom_number +ATOM -NUMBER
     ATOM の内部表現で利用している通し番号を、整数で NUMBER へ返します。

 -- 述語 on atom_table: get_atom_string +ATOM -STRING
     ATOM の名前文字列を STRING へ返します。

 -- 述語 on atom_table: intern +STRING -RESULT
     返却値が `normal(ATOM)' 形式のファンクタ構造である他は、
     atom_table:make_atom と同じです。

 -- 述語 on atom_table: get_atom_name +ATOM -RESULT
     返却値が `normal(STRING)' 形式のファンクタ構造である他は、
     atom_table:get_atom_string と同じです。

記号アトムは名前文字列を持っていますが、それらの名前文字列を、文字列操
作のために使用すべきでは*ありません*。文字列データは、より豊富な機能性
と、より良い性能を提供しています(*Note 文字列: Strings.)。



File: KLICj.info, Node: Integers, Next: Floating Points, Prev: Symbolic Atoms, Up: Atomic Data

整数アトム
----------

KLIC は、基本的な標準機能として、通常、28 ビットか 60 ビットの整数デー
タを提供します。そのビット長は、使用する C コンパイラに依存します。 整
数データは、 `long int' 型のビット長に比べ、4 ビット短くなります。

 -- ガード述語 on builtin: integer +X
     X が整数アトムか否かをテストします。

* Menu:

* Notation of Integers::        整数アトムの表記
* Integer Arith::               整数演算
* Integer Comp::                整数比較



File: KLICj.info, Node: Notation of Integers, Next: Integer Arith, Prev: Integers, Up: Integers

整数の表記
..........

KLIC は、整数定数を表す方法を提供します。
   * 通常の 10 進表記:任意指定のマイナス符号のあとに、10 進数字の並び
     を続けます。例:`123',`-35' 。
   * 基数表記:任意指定のマイナス符号のあとに、基数を規定する 10 進数字
     の並び (1〜36) 、アポストロフィ、そして、数字とアルファベット(大
     文字、小文字の区別なし)からなる基数の数字列を続けます。例 :
     `2'1010'、`16'0D0a' 。基数 1 の整数の値は、数字列中の 1 の数です。
     例えば、`1'10110' は 3 を表します。

   * 文字コード表記:任意指定のマイナス符号のあとに、数字の 0、アポスト
     ロフィと文字を続けます。例:`0'a' は、アルファベットの小文字の `a'
     の文字コードを表します。上記の定数表記は、KL1 プログラムと、
     Prolog 風の入出力インタフェースで読み込まれる KL1 データの双方で
     使用できます(*Note Prolog 風のインタフェースを用いた入出力:
     Prolog I/O.)。

以下に示す内容も PIM マシン上の PIMOS システムとの互換性のために、 KL1
プログラムは許しています。
   * 基数表記:任意指定のマイナス符号のあとに、基数を規定する 10 進数字
     の並び (1〜36) 、シャープ記号 (#) 、そして、数字とアルファベット
     (大文字、小文字の区別なし)からなる基数の数字列を二重引用符で囲ん
     で続けます。例:`2#"1010"'、`16#" 0D0a"' 。
   * 文字コード表記:任意指定のマイナス符号のあとに、シャープ記号(#)と、
     二重引用符で囲んだ 1 個の文字を続けます。例:`#"a"' は、アルファベッ
     トの小文字の `a' の文字コードを表します。



File: KLICj.info, Node: Integer Arith, Next: Integer Comp, Prev: Notation of Integers, Up: Integers

整数演算
........

 -- ガード述語 on builtin: := -VAR +EXPR
 -- ボディ述語 on builtin: := -VAR +EXPR
     整数式 EXPR の値を計算し、VAR と単一化します。次の演算子が利用可
     能です。

     X + Y
          加算
     + X
          演算せず  
          X が結果となります
     X - Y
          減算
     - X
          符号の反転
     X * Y
          乗算
     X / Y
          整数除算
     X mod Y
          モジュロ
     \(X)
          ビットごとの補数
     X /\ Y
          ビットごとの論理積
     X \/ Y
          ビットごとの論理和
     X xor Y
          ビットごとの排他的論理和
     X << Y
          左論理シフト
     X >> Y
          右論理シフト
     int(X)
          浮動小数点から整数への変換 　X は浮動小数点式で、その値を整
           数値に丸めます(*Note 浮動小数点演算: Floating Arith.)。

     算術オーバフローは無視します。つまり、すべての演算は、使用する C
     コンパイラに依存して、モジュロ2**28 か モジュロ 2**60を行います。
     32ビットの `long int' を持つ Cコンパイラは、28ビットの KLIC 整数
     を提供し、64ビットの `long int' を持つ Cコンパイラは、60ビットの
     KLIC 整数を提供します。

     この述語は、節のガードとボディの両方で利用可能です。

     式中に、具体化されていないオペランドがある場合、すべてのオペラン
     ドが具体化されるまで計算は中断します。

     式中のいくつかのオペランドに対して、再帰的に式を指定できます。た
     だし、プログラム中に変数として書くオペランドは、 `3+5' のような合
     成項に具体化しては *なりません*。具体化するのは整数だけにしてくだ
     さい。整数以外に具体化すると、型不一致のエラーが発生します。



File: KLICj.info, Node: Integer Comp, Prev: Integer Arith, Up: Integers

整数比較
........

整数データの比較は、ここで説明する述語を用いて行うことができます。より
一般的な比較述語も提供しています(*Note 比較とハッシュ: Comparison and
Hashing.)。ただし、ここで説明する述語とメソッドは、オペランドが整数で
あることが明らかな場合に使用すると、より効率的です。

 -- ガード述語 on builtin: > +X +Y
 -- ガード述語 on builtin: >= +X +Y
 -- ガード術語 on builtin: =:= +X +Y
 -- ガード述語 on builtin: =\= +X +Y
 -- ガード述語 on builtin: =< +X +Y
 -- ガード述語 on builtin: < +X +Y

     これらは 2 つの整数引数の比較演算を行います。
     値の同値関係のチェックには `=:=' と `=\=' を使用してください。
     比較の両側には算術式が指定できます。
     `:=' で用いたものと同じ演算子群が使えます。



File: KLICj.info, Node: Floating Points, Prev: Integers, Up: Atomic Data

浮動小数点数
------------

64 ビット精度の浮動小数点数を、ジェネリック・オブジェクトとして提供し
ます。次のメソッドと述語は、与えられたデータが浮動小数点数か否かを判定
します。

 -- ガード・メソッド on float: float +X
 -- ガード述語 on builtin: float +X
     X が浮動小数点数か否かをテストします。

* Menu:

* Notation of Floats::          浮動小数点数の生成
* Creating Floats::             新しい浮動小数点数の生成
* Floating Arith::              浮動小数点演算
* Floating Comp::               浮動小数点比較



File: KLICj.info, Node: Notation of Floats, Next: Creating Floats, Prev: Floating Points, Up: Floating Points

浮動小数点数の表記
..................

浮動小数点数は、次のような定数表記の構文を持っています。

     符号 整数 `.' 小数 `e' 符号 指数

ここで、整数、小数、および指数は、10進数の並びです。符号は、 `+' 、
`-' または 指定なし(この場合、 `+' を仮定する)となります。指数部は、文
字の `e'、符号、および指数で構成し、すべてを省略することも可能です。

浮動小数点定数の例を以下に示します。

     3.14159 -6.02e23  1234.5678e-25


File: KLICj.info, Node: Creating Floats, Next: Floating Arith, Prev: Notation of Floats, Up: Floating Points

新しい浮動小数点数の生成
........................

新しい浮動小数点数は、次のように生成できます。
*Note 浮動小数点演算: Floating Arithで説明する浮動小数点の演算用述語も、算術演算の結果として浮動小数点数を生成します。

 -- float on オブジェクト生成: new -FLOAT +INIT
     新しい浮動小数点数を生成し、 FLOAT で単一化します。引数の INIT に
     は、浮動小数点数の値として整数を指定する必要があります。例えば、
     `generic:new(float, F, 3)' では `F' を `3.0' で単一化します。



File: KLICj.info, Node: Floating Arith, Next: Floating Comp, Prev: Creating Floats, Up: Floating Points

浮動小数点演算
..............

 -- ボディ述語 on builtin: $:= -VAR +EXPR
     浮動小数点式の値 EXPR を計算して VAR で単一化します。次の演算子が
     利用可能です。

     X + Y
          加算
     X - Y
          減算
     X * Y
          乗算
     X / Y
          除算
     pow(X, Y)
          X の Y 乗
     sin(X), cos(X), tan(X)
          X の三角関数
     asin(X), acos(X), atan(X)
          X の逆三角関数
     sinh(X), cosh(X), tanh(X)
          X の双曲線関数
     exp(X)
          指数関数
     log(X)
          自然対数
     sqrt(X)
          平方根
     ceil(X)
          切り上げ関数(正の無限方向への切り上げ)
     floor(X)
          切り捨て関数(負の無限方向への切り捨て)
     float(X)
          整数の浮動小数点数への変換X は整数式で、結果は浮動小数点数に
          変換します(*Note 整数演算: Integer Arith.)。
     +X
          X が結果となります。
     -X
          符号の反転

     この述語は、節のガードとボディの両方で利用可能です。

     式中に、具体化されていないオペランドがある場合、すべてのオペラン
     ドが具体化されるまで計算は中断します。

     式中のいくつかのオペランドに対して、再帰的な式を指定できます。た
     だし、プログラム中で変数として書くオペランドは、`3.0 + 5.0' のよ
     うな合成項に具体化しては *なりません*。具体化するのは浮動小数点数
     だけにしてください。浮動小数点数以外に具体化すると、型不一致のエ
     ラーが発生します。

上記の演算は、浮動小数点数のジェネリック・メソッドとしても提供していま
す。

 -- ボディ・メソッド on float: add +X +Y -R
 -- ボディ・メソッド on float: subtract +X +Y -R
 -- ボディ・メソッド on float: multiply +X +Y -R
 -- ボディ・メソッド on float: divide +X +Y -R
 -- ボディ・メソッド on float: pow +X +Y -R
 -- ボディ・メソッド on float: sin +X -R
 -- ボディ・メソッド on float: cos +X -R
 -- ボディ・メソッド on float: tan +X -R
 -- ボディ・メソッド on float: asin +X -R
 -- ボディ・メソッド on float: acos +X -R
 -- ボディ・メソッド on float: atan +X -R
 -- ボディ・メソッド on float: sinh +X -R
 -- ボディ・メソッド on float: cosn +X -R
 -- ボディ・メソッド on float: tanh +X -R
 -- ボディ・メソッド on float: exp +X -R
 -- ボディ・メソッド on float: log +X -R
 -- ボディ・メソッド on float: sqrt +X -R
 -- ボディ・メソッド on float: ceil +X -R
 -- ボディ・メソッド on float: floor +X -R
     これらのメソッドは、メソッド名で規定した算術演算を実行します。オ
     ペランドを指定すると、その結果を R へ返します。



File: KLICj.info, Node: Floating Comp, Prev: Floating Arith, Up: Floating Points

浮動小数点比較
..............

浮動小数点データの比較は、ここで説明する述語を用いて行えます。より一般
的な比較述語も提供しています(*Note 比較とハッシュ: Comparison and
Hashing.)。ただし、ここで説明する述語とメソッドは、オペランドが浮動小
数点数であることが明らかな場合に使用すると、より効率的です。

 -- ガード述語 on builtin: $> +X +Y
 -- ガード述語 on builtin: $>= +X +Y
 -- ガード述語 on builtin: $=:= +X +Y
 -- ガード述語 on builtin: $=\= +X +Y
 -- ガード述語 on builtin: $=< +X +Y
 -- ガード述語 on builtin: $< +X +Y

     これらの述語は、2 つの浮動小数点引数の比較演算を行います。
     値の同値関係のチェックには(浮動小数点数の場合は、たいして意味のあることではありませんが)、 `=:=' と `=\=' を使用してください。
     比較の両側には浮動小数点式を指定できます。
      `$:=' で用いたものと同じ演算子群が使えます。

     *バグに注意*` '現在の版 (2.001) では、これらの述語に対して演算子
     付き式の使用は避けてください。単純な変数と定数だけを使用してくだ
     さい。

浮動小数点数の比較は、次のメソッドでも行えます。

 -- ガード・メソッド on float: less_than +X +Y
 -- ガード・メソッド on float: not_greater_than +X +Y
 -- ガード・メソッド on float: not_less_than +X +Y
 -- ガード・メソッド on float: greater_than +X +Y
 -- ガード・メソッド on float: equal +X +Y
 -- ガード・メソッド on float: not_equal +X +Y

     これらの方法では、X が Y より小さいか否か等をテストします。



File: KLICj.info, Node: Structured Data, Next: Executable Code, Prev: Atomic Data, Up: Builtin and Library

構造型データ
============

構造型データ・オブジェクトは、0 個以上の要素で構成します。

* Menu:

* Functors::                    ファンクタ構造
* Lists::                       リスト
* Vectors::                     ベクタ
* Strings::                     文字列
character codes



File: KLICj.info, Node: Functors, Next: Lists, Prev: Structured Data, Up: Structured Data

ファンクタ構造
--------------

ファンクタ構造は、与えられた名前と 1 個以上の任意の型の要素を持つ構造
です。ファンクタは、あらかじめ大きさが分かっているデータ構造を表すのに
向いています。ファンクタは、C 風言語のレコード構造に対応します。

* Menu:

* Notation of Functors::        ファンクタの表記
* Functor Operation::           ファンクタの操作



File: KLICj.info, Node: Notation of Functors, Next: functor Operation, Prev: Functors, Up: Functors

ファンクタの表記
................

ファンクタ定数は、主ファンクタ名、左括弧、コンマで区切られた要素、およ
び最後の右括弧で書くことができます。ファンクタ名は記号アトムと同じ構文
です。主ファンクタ名とそれに続く左括弧を、空白文字や区切り記号等で分け
ては*なりません*。要素には、変数やファンクタ自身を含む任意の型が指定で
きます。

例 :
     f(a, 3)   'a recursive functor structure'(X, 'child functor'(Y))



File: KLICj.info, Node: Functor Operation, Prev: Notation of Functors, Up: Functors

ファンクタの操作
................

ファンクタ構造を操作する述語は、以下に示すように組込み述語として提供し
たり、`functor_table' モジュール中に提供したりしています。

現在の実装では、次に示すボディ組込み述語のすべてが、`functor_table' モ
ジュールの述語に展開したマクロ形式で実装しています。この実装方法は、将
来のリリースで変更する可能性があります。

 -- ガード述語 on builtin: functor +X -FUNCTOR -ARITY
 -- ボディ述語 on builtin: functor +X -FUNCTOR -ARITY
      X は、主ファンクタ名が FUNCTOR で、引数個数が ARITY のファンクタ
     です。上記の述語は、主ファンクタ名とその引数個数、またはそれらの
     どちらか一方を得るために使用します。ガード述語として呼び出された
     場合には、X が名前 FUNCTOR と引数個数 ARITY を持つこと、またはそ
     れらのどちらか一方を持つこと、のテストにも使用できます。アトム・
     データ、文字列、ベクタなどの、ファンクタ構造でない具体化データは、
     引数個数が 0 となり、自分自身が主ファンクタ名になります。リスト構
     造は、ファンクタ `./2' で構成しているので注意してください。

     この述語では、新しいファンクタは生成できません。

 -- ガード述語 on builtin: arg +POS +TERM -ARG
 -- ボディ述語 on builtin: arg +POS +TERM -ARG
      TERM の POS 番目の引数は ARG です。引数は 1 から番号付けしていま
     す。ガード述語として呼び出された場合、 POS が範囲外なら単に失敗す
     るだけです。この述語をファンクタ構造以外のデータ構造に使用すると、
     それらのデータ構造は引数を持たないので、常に失敗します。

 -- ボディ述語 on builtin: new_functor -FUNCTOR +ATOM +ARITY
     主ファンクタ名が ATOM で引数個数が ARITY のファンクタ構造を、
     FUNCTOR へ返します。生成したファンクタの引数は、整数 `0' で初期化
     しています。

 -- ボディ述語 on builtin: setarg +POS +FNCT ?NEWE -NEWFNCT
 -- ボディ述語 on builtin: setarg +POS +FNCT ?OLDE ?NEWE -NEWFNCT
     POS番目の引数だけが FNCT と異なる新しいファンクタ構造を生成して、
     NEWFNCT へ返します。  NEWFNCT の POS 番目の要素は NEWEになります。
     5 個の引数を持つ述語の場合、FNCT の POS 番目の引数を、 OLDE へ返
     します。

 -- functor_table on 述語: =.. -NEWFNCT +LIST
     新しいファンクタを生成して、NEWFNCT へ返します。
     主ファンクタ名は、LIST の最初の要素に記号アトムで指定しなければなりません。
     引数は、LIST の残りの部分に指定します。
     LIST の要素が 1 個だけの場合、その要素を NEWFNCT へ返します。

     この述語は、ファンクタ構造をリストに分解するためには使え*ません*。



File: KLICj.info, Node: Lists, Next: Vectors, Prev: Functors, Up: Structured Data

リスト
------

リストは、任意の長さのデータ・オブジェクトの並びです。KL1 では、リスト
構造は、名前 `.' と 2 個の引数を持つファンクタ構造、 `./2' で構成しま
す。リスト構造は、これら`コンス・セル'とも呼ばれるファンクタ構造で構成
します。

コンス・セルの 1 番目の要素は、時にはセルの "car" とも呼ばれますが、リ
ストの 1 番目の要素を表します。セルの "cdr" である 2番目の要素は、リス
トの残りの部分を表します。リストの終端は、その cdr が記号アトム `[]'
であることで示します。

与えられた引数がリストか否かは、次のガード述語でテストできます。

 -- ガード述語 on builtin: list +X
     X がコンス・セルか否かをテストします。この述語は、X が空リスト
     `[]' であると、X の名前とは関係なく、失敗するので注意してください。

徐々に具体化されるリスト構造は、メッセージ・ストリームとして使用すると
便利です。

* Menu:

* Notation of Lists::           リストの表記
* Merging::                     メッセージストリームの操作



File: KLICj.info, Node: Notation of Lists, Next: Merging, Prev: Lists, Up: Lists

リストの表記
............

KL1 のリストは、Lisp のように*コンス*のデータ構造を用いて構築します。
コンスのデータ構造は、実際にはファンクタ構造 `./2' です。

リストの基本的な表記は、`[CAR|CDR]' です。すなわち、リストの最初の要素
が CAR で、末尾が CDR で構成します。これは、`.(CAR, CDR)' とまったく同
じ意味になります。空リストは、アトム `[]' で表します。

CDR が空の場合、つまり、リストが 1 個の要素 CAR だけで構成する場合、リ
ストは `.(CAR, [])' 、または `[CAR|[]]' と表記します。後者の場合、 リ
ストの末尾の `|[]' は省略できるので、 `[CAR]' と書くこともできます。つ
まり、car が CAR で、cdr が `[CADR, ...]' であるリストは、
`[CAR|[CADR, ...]]' と書けます。これは、`[CAR, CADR, ...]' のように省
略形でも書けます。例えば、4個の要素、`first'、`second'、`third'、
`fourth' からなるリストは、`[first, second, third, fourth]' と書けます。

4個以上の要素からなるリストで、最初の 4個の要素が `first'、`second'、
`third'、`fourth' の場合、`[first, second, third, fourth | Rest]' と書
けます。ここで、変数 `Rest' は、5番目の要素で始まるリストに対応します。
リスト全体が 4個の要素だけの場合には、`Rest' は空リストに対応します。

Edinburgh Prolog とは異なり、文字の並びの`,..'は `|'の代わりには使用で
きないので注意してください。



File: KLICj.info, Node: Merging, Prev: Notation of Lists, Up: Lists

メッセージ・ストリームの操作
............................

ストリーム・マージャは、メッセージのリストとして表現される複数のメッセー
ジ・ストリームを入力として受け取り、それらすべての入力ストリームのメッ
セージを、リストとして表現する単一の出力ストリームに渡すプロセスです。

出力は、入力中のすべてのメッセージを複製したものから成り立ちます。2 つ
のメッセージに対して、どれか 1 つの入力ストリームで順序付けを行うと、
それらのメッセージの順序は出力中でも変わることはありません。出力中のメッ
セージが複数の入力ストリームから渡される場合、メッセージの出力順序は予
測できません。その出力順序は、同じプログラムでも実行ごとに異なる可能性
があります。このように、マージャは非決定的な動作をします。

例えば、2つの入力ストリーム、`[1, 2, 3]' と `[a, b, c]' が存在する場合、
出力は、`[1, 2, a, b, 3, c]' や `[1, a, 2, b, c, 3]' にはなりますが、
決して `[1, a, 3, b, c, 2]' になることはありません。

KL1 では、2 入力のストリーム・マージャを、次のように定義できます。

     merge([M|In1], In2, Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge(In1, [M|In2], Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge([], In2, Out) :- Out=In2.
     merge(In1, [], Out) :- Out=In1.

   * 上記のマージャの定義において、1 番目の節（clause）は、最初の入力
      ストリームから、1 つのメッセージを出力ストリームに転送します。最
      初の入力ストリームは最初の引数であり、出力ストリームは述語の 3番
      目の引数です。続いて、繰返し実行のために再帰的に述語 `merge/3'
      を呼び出します。

   * 2 番目の節は、2番目の入力ストリームに対して、同じ処理を行います。

   * 3 番目の節は、最初の入力ストリーム中にメッセージが存在しない場合
     に使用します。この場合、2番目の入力ストリームを直接、出力に接続し
     ます。最初の入力ストリームから転送するメッセージはないので、マー
     ジの結果は 2番目の入力ストリームと同じになります。

   * 4 番目の節は、2番目の入力ストリーム中にメッセージが存在しない場合
     に使用します。

メッセージを同時に両方の入力ストリームから受け取る場合、1 番目か 2 番
目のどちらか一方の節が任意に選ばれます。このことがマージャの非決定性の
原因です。

2 入力のマージャは、KL1 では容易に定義できますが、任意の多入力ストリー
ムのマージャを定義することは、容易ではありません。新しい入力ストリーム
を動的に追加することも望まれますが、さらに難しくなります。また、マージャ
は KL1 プログラムで非常によく使用されるので、効率的である必要がありま
す。したがって、KLIC システムでは、マージャを標準的な機能として提供し
ます。

新しいマージャは、以下に示す疑似述語によって生成します。

 -- オブジェクト生成 on merge: new ?INPUT ?OUTPUT
     単一の入力ストリームを持つ新しいマージャを生成します。入力ストリー
     ムは INPUT で、出力ストリームは OUTPUT になります。

上記の疑似述語で生成したマージャ・プロセスは、実際には、生成直後はマー
ジを開始しません。単に INPUT からのメッセージを OUTPUT に、順序を変え
ずに転送するだけです。

新しい入力ストリームをマージャに追加するには、入力をベクタで単一化して
ください。そのベクタの要素が新たな入力ストリームになります。例えば、バ
イナリのマージャが必要な場合、次のようにしてください。

     generic:new(merge, INPUT, OUTPUT),
     INPUT = {IN1, IN2}

これは、次の処理と同じ意味になります。

     generic:new(merge, {IN1, IN2}, OUTPUT)

上記処理後、マージャは 2 個の入力ストリーム IN1 と IN2 からのメッセー
ジを、出力ストリーム OUTPUT へマージします。

マージャへの入力ストリームの追加は、生成直後だけでなく、要求に応じて任
意に行えます。例えば、2 個以上の入力ストリームを追加する例を、次に示し
ます。

     IN2 = {IN2A, IN2B, IN2C}

この結果、マージャは 4 個の入力ストリーム IN1、IN2A、IN2B、IN2Cを持つ
ことになります。

入力ストリームの 1 つが必要なくなった場合、その入力ストリームをアトム
`[]' で単一化するだけで、簡単に閉じることができます。

入力ストリームに単一化されるベクタのサイズは、任意に変更できます。ベク
タが 1 個の要素しか持っていない場合、入力ストリームの数は変更されませ
ん。ベクタが要素を持っていない場合、ベクタを単一化すると、ストリームを
閉じることになります。

すべての入力ストリームを閉じたとき、出力リストの末尾を `[]'と単一化す
るので、出力ストリームも閉じます。

マージャを使用する際のヒントを、次に示します。

   * マージするメッセージには、未束縛変数を含むデータ構造を許します。
     そのようなメッセージは、"不完全メッセージ" とも呼びます。不完全メッ
     セージは、クライアント/サーバのプロセス構造を構築する場合に向いて
     います。メッセージ中の変数に値を与えると、サーバからクライアント
     への返信に使用できます。

   * 逐次実装におけるマージは、決定的に見えるかも知れません。しかし、
     並列実装におけるマージは、非決定的になりますので、決して頼らない
     でください。



File: KLICj.info, Node: Vectors, Next: Strings, Prev: Lists, Up: Structured Data

ベクタ
------

ベクタは、固定長の 1 次元配列の KL1 データです。ベクタの長さは、生成の
際に決定します。要素には、任意の KL1 データを許し、データ構造を生成し
た時点で、未定義の状態でいることも許します。

要素は 0 から始まる整数によって、インデックス付けします。例えば、3 個
の要素を持つベクタは、0、1、2 と番号が付いた要素になります。

* Menu:

* Notation of Vectors::         ベクタの表記
* Creating Vectors::            ベクタの生成
* Predicates on Vectors::       ベクタの述語



File: KLICj.info, Node: Notation of Vectors, Next: Creating Vectors, Prev: Vectors, Up: Vectors

ベクタの表記
............

ベクタは、1 対の中括弧 (`{}') の中で、要素の並びをコンマで区切ることで
表します。

     { 1, a, f(b), X }

空ベクタ(要素のないベクタ)は 1 対の中括弧だけで表します。

     {}

中括弧は、Edinburgh Prolog とは完全に異なった意味で使用するので、注意
してください。Edinburgh Prolog では、`{}'はアトムを意味し、`{...}' は
ファンクタ構造 `{}((...))'を意味します。



File: KLICj.info, Node: Creating Vectors, Next: Predicates on Vectors, Prev: Notation of Vectors, Up: Vectors

ベクタの生成
............

前項で示した表記に加えて、ベクタをプログラムの実行中に動的に生成できま
す。次に示す述語は、新しいベクタを生成するために使えます。

 -- オブジェクト生成 on vector: new -VECTOR +INIT
 -- ボディ述語 on builtin: new_vector -VECTOR +INIT
     新しいベクタを生成して、VECTOR へ返します。

     引数 INIT が整数の場合、要素数を指定したことになります。この場合、
     要素を整数 `0' で初期化します。例えば、`generic: new(vector, V,
     2)' はベクタ `{0, 0}' を生成して、`V' へ単一化します。

     引数 INIT がリストの場合、新しく生成したベクタを、リストの要素に
     よって初期化します。当然、ベクタの要素数はリストの長さと同じにな
     ります。例えば、`generic:new(vector, V, [a, b, c])' は ベクタ
     `{a, b, c }'を生成して、`V' へ単一化します。



File: KLICj.info, Node: Predicates on Vectors, Prev: Creating Vectors, Up: Vectors

ベクタの述語
............

 -- ガード・メソッド on vector: vector +VECTOR -LENGTH
 -- ボディ・メソッド on vector: size +VECTOR -LENGTH
 -- ガード述語 on builtin: vector +VECTOR -LENGTH
     (ガード述語で呼び出された場合、)VECTOR がベクタ・オブジェクトか否
     かをテストします。要素数を LENGTH へ返します。

 -- ガード・メソッド on vector: element +VECTOR +INDEX -ELEMENT
 -- ボディ・メソッド on vector: element +VECTOR +INDEX -ELEMENT
 -- ガード述語 on builtin: vector_element +VECTOR +INDEX -ELEMENT
 -- ボディ述語 on builtin: vector_element +VECTOR +INDEX -ELEMENT
     ベクタ VECTOR の INDEX 番目の要素を、ELEMENTと単一化します。イン
     デックスは、ゼロから始まります。

 -- ボディ・メソッド on vector: set_element +ORIGINAL +INDEX ?NEWELEMENT -NEW
 -- ボディ述語 on builtin: set_vector_element +ORIGINAL +INDEX ?NEWELEMENT -NEW
     新しいベクタを NEW と単一化します。INDEX 番目の要素を更新して、
      NEWELEMENT にする他は、 ORIGINAL と同じ要素になります。オリジナ
      ルのベクタには影響しません。インデックスは、ゼロから始まります。

 -- ボディ・メソッド on vector: set_element +ORIGINAL +INDEX ?ELEMENT ?NEWELEMENT -NEW
 -- ボディ述語 on builtin: set_vector_element +ORIGINAL +INDEX ?ELEMENT ?NEWELEMENT -NEW
     新しいベクタを NEW と単一化します。
      INDEX 番目の要素を更新して、 NEWELEMENT にする他は、 ORIGINAL と同じ要素になります。
     オリジナルのベクタには影響しません。
     インデックスは、ゼロから始まります。
      INDEX 番目のオリジナルの要素を ELEMENT へ返します。

 -- ボディ・メソッド on vector: split +ORIGINAL +AT -LOWER -UPPER
     ベクタ ORIGINAL を AT 番目で分割し、2 つのベクタを LOWER と UPPER に単一化します。
     AT は、オリジナルのベクタのサイズ以下で、かつゼロ以上の整数です。
     LOWER は、0番目以上 `AT-1'番目以下の要素で構成します。
     UPPER は、AT 番目以上の要素で構成します。

 -- ボディ・メソッド on vector: join +LOWER +UPPER -JOINED
     LOWER と UPPER の 2 つのベクタを結合して、新しいベクタ JOINED にします。

KLIC では、既存のベクタと 1 要素だけが異なる新たなベクタの生成は、ベク
タのサイズとは関係なく、時間と領域がともに一定のオーバヘッドで済むマル
チバージョン配列表現を用いて実装しています。



File: KLICj.info, Node: Strings, Prev: Vectors, Up: Structured Data

文字列
------

文字列は、限定された範囲の整数の 1 次元配列です。現在の版では、0 〜
255 個の要素を持つ 8 ビット要素の文字列だけを提供しています。それらは、
文字の列を表す場合に向いています。異なるサイズの要素からなる文字列を、
将来計画しています。

Edinburgh Prolog とは異なり、文字列は、文字コードのリスト用の表記規約
では*ありません*。文字列は、それ自身のデータ型を持ちます。

* Menu:

* Notation of Strings::         文字列の表記
* Creating Strings::            文字列の生成
* Predicates on Strings::       文字列の述語



File: KLICj.info, Node: Notation of Strings, Next: Creating Strings, Prev: Strings, Up: Strings

文字列の表記
............

文字列定数は次のように、 1 対の二重引用符(")で囲まれた文字の並びで表し
ます。

     "A string of the characters written here"

次のエスケープ・シーケンスは、(ANSI C のように)二重引用符、バックスラッ
シュ、制御コードなどを文字列の要素として指定するために使います。

`\a'
     ビープ音
`\b'
     バックスペース
`\t'
     タブ
`\n'
     改行
`\v'
     垂直タブ
`\f'
     改ページ
`\r'
     復帰
`\''
     単一引用符
`\"'
     二重引用符
`\?'
     疑問符
`\\'
     バックスラッシュ　2 個の連続するバックスラッシュで文字列中の 1 個
      のバックスラッシュを指定する
`\ooo'
      8 進数 ooo で指定するコード最大 3 桁の 8 進数が指定できる
`\xhh'
      16 進数 hh で指定するコード任意桁の 16 進数が指定できる
`\NEWLINE'
     直後に改行コードの付いたバックスラッシュを無視する文字列中では、
     この並びには文字が無くなる

例:

     "The character \'\"\' (doublequote)"

上記の例では、次の文字を含む文字列として解釈します。

     The character '"' (doublequote)

文字列には、改行や二重引用符を直接含んではなりません。文字列内に改行を
含む標準的な方法は、行を `\n\' で終了させることです。この方法では、改
行コードを、`\n' で挿入し、2 番目の `\'に続くソース・コード中の実際の
改行を、無視します。

Edinburgh Prolog とは異なり、文字列は文字コードのリストでは*ありません
*。



File: KLICj.info, Node: Creating Strings, Next: Predicates on Strings, Prev: Notation of Strings, Up: Strings

文字列の生成
............

上記の文字列定数に加えて、文字列を実行中に動的に生成できます。次の述語
が新しい文字列を生成するために使えます。

 -- オブジェクト生成 on string: new -STRING +INIT +ELEMSIZE
 -- ボディ述語 on builtin: new_string -STRING +INIT +ELEMSIZE
     新しい文字列を生成して、STRING と単一化します。最後の引数
     ELEMSIZE には要素のビット幅を指定します。現在の版では、8 ビット文
     字列しか利用できないので、これは 8 になります。

     引数 INIT が整数の場合、要素数が指定されたことになります。この場
     合、要素を整数 `0'(ヌル・コード)で初期化します。例えば、
     `generic:new(string, S, 3, 8)' は `"\0\0\0"' を生成します。

     引数 INIT が整数のリストの場合、新しく生成された文字列を、リスト
     の要素によって初期化します。当然、文字列の要素数はリストの長さと
     同じになります。この場合、リストの要素は、与えられたビット幅に適
     合する値、つまり 8 ビット文字列で構成する場合、0 〜 255 の値にな
     ります。例えば、`generic:new(string, S, [0'a, 0'b, 0'c], 8)' は
     `"abc"' を生成します。



File: KLICj.info, Node: Predicates on Strings, Prev: Creating Strings, Up: Strings

文字列の述語
............

 -- ガード・メソッド on string: string +STRING -LENGTH -ELEMSIZE
 -- ボディ・メソッド on string: string +STRING -LENGTH -ELEMSIZE
 -- ガード述語 on builtin: string +STRING -LENGTH -ELEMSIZE
     (ガード述語で呼び出された場合)、STRING が文字列オブジェクトか否かをテストします。
     STRING の要素数を LENGTH へ、要素サイズ(現在の版では常に8)を ELEMSIZE へ返します。

 -- ボディ・メソッド on string: size +STRING -LENGTH
     STRING の要素数を LENGTH へ返します。

 -- ボディ・メソッド on string: element_size +STRING -ELEMSIZE
     STRING の要素サイズを ELEMSIZE へ返します。

 -- ガード・メソッド on string: element +STRING +INDEX -ELEMENT
 -- ボディ・メソッド on string: element +STRING +INDEX -ELEMENT
 -- ガード述語 on builtin: string_element +STRING +INDEX -ELEMENT
 -- ボディ述語 on builtin: string_element +STRING +INDEX -ELEMENT
     文字列 STRING の INDEX 番目の要素を ELEMENT と単一化します。イン
     デックスは、ゼロから始まります。

 -- ガード・メソッド on string: less_than +STRING1 +STRING2
 -- ガード述語 on builtin: string_less_than +STRING1 +STRING2
     辞書式順序で、STRING1 がSTRING2 より小さい場合だけ成功します。

 -- ガード・メソッド on string: not_less_than +STRING1 +STRING2
 -- ガード述語 on builtin: string_not_less_than +STRING1 +STRING2
     辞書式順序で、STRING1 が STRING2 以上の場合だけ成功します。

 -- ガード・メソッド on string: string +STRING -LENGTH -ELEMSIZE
 -- ガード述語 on builtin: string +STRING -LENGTH -ELEMSIZE
     STRING の要素数を LENGTH へ返し、要素サイズ(常に8)を ELEMSIZEへ返します。

 -- ボディ・メソッド on string: set_element +ORIGINAL +INDEX ?ELEMENT +NEW
 -- ボディ述語 on builtin: set_string_element +ORIGINAL +INDEX ?ELEMENT +NEW
     新しい文字列を NEW で単一化します。新しい文字列の、INDEX 番目の要
     素を更新して、 ELEMENT にする他は、ORIGINAL と同じ要素になります。
     オリジナルの文字列には影響しません。インデックスは、ゼロから始ま
     ります。

 -- ボディ・メソッド on string: split +ORIGINAL +AT -LOWER -UPPER
     文字列 ORIGINAL を、 AT 番目で分割し、 2 個の文字列を LOWER と UPPER に単一化します。
     AT は、オリジナルの文字列のサイズ以下で、かつゼロ以上の整数です。
     LOWER は、0 番目以上 `AT-1' 番目以下の要素で構成します。
     UPPER は、AT 番目以上の要素で構成します。

 -- ボディ・メソッド on string: join +LOWER +UPPER -JOINED
     LOWER と UPPER の 2 つの文字列を結合して、新しい文字列 JOINED にします。

 -- ボディ・メソッド on string: search_character +STRING +START +END +CHAR -WHERE
 -- ボディ述語 on builtin: search_character +STRING +START +END +CHAR -WHERE
     文字 CHAR を STRING 中で探索します。探索は、位置 START から開始し、
     END の前で終わります。探索する文字が見つかった場合、そのインデッ
     クスを、WHERE と単一化します。見つからなかった場合、WHERE を `-1'
     と単一化します。インデックスは、ゼロから始まります。

KLIC では、既存の文字列と 1 要素だけが異なる新たな文字列の生成は、文字
列のサイズとは関係なく、時間と領域がともに一定のオーバヘッドで済むマル
チバージョン配列表現を用いて実装しています。




File: KLICj.info, Node: Executable Code, Next: Unix, Prev: Structured Data, Up: Builtin and Library

プログラム・コードのデータとしての扱い
======================================

KLIC では、データ・オブジェクトとして、実行コードの高次な操作が可能で
す。プログラム・モジュールは、"モジュール"・データ・オブジェクトとして
扱い、個々の述語は、"述語"データ・オブジェクトとして扱います。

* Menu:

* Module Type::                 モジュール
* Predicate Type::              述語



File: KLICj.info, Node: Module Type, Next: Predicate Type, Prev: Executable Code, Up: Executable Code

モジュール
----------

プログラム・モジュールは、`module' 型のジェネリック・データ・オブジェ
クトによってデータとして扱います。

 -- オブジェクト生成 on module: new -MODULE +MODULENAME
     記号アトムの MODULENAME で指定されたプログラム・モジュールに対応する、新しいオブジェクト MODULE を生成します。
     指定されたモジュールが定義されていない場合、記号アトム自身を MODULE へ返します。
     オブジェクト生成ゴールのフォーマットについては、
     *Note ジェネリック・オブジェクトの生成: Creating Objects。

 -- ガード・メソッド on module: module +MODULE
     MODULE がモジュール・オブジェクトか否かをテストします。

 -- ボディ・メソッド on module: name +MODULE -MODULENAME
     MODULE のモジュール名を、記号アトムとして MODULENAME へ返します。



File: KLICj.info, Node: Predicate Type, Prev: Module Type, Up: Executable Code

述語
----

プログラムの述語は、述語(`predicate') 型のジェネリック・データ・オブジェ
クトによってデータとして扱います。

述語型データは、定数として表わすか、実行時に動的に生成するかのどちらか
です。ホスト・システムの機能の制約のため、ホスト・システムによっては、
動的な生成をサポートしない場合があります。

述語定数の構文は次のとおりです。

     `predicate'`#'`('MODULE`:'PREDICATE`/'ARITY`)'

ここで、MODULE と PREDICATE がモジュールと述語の名前アトムであり、
ARITY が整数(述語の引数個数)になります。例えば、

     predicate#(main:main/0)  predicate#(quicksort:partition/4)

これらは、プログラムで有効な述語定数です。

述語定数は、KLIC のパーサでなく、KLIC のコンパイラが認識するので注意し
てください(*Note Prolog 風のインタフェースを用いた入出力: Prolog I/O.)。
したがって、Prolog 風の I/O ストリームを用いて単に読み込むだけの場合、
上記の表記は、通常のデータ構造を意味します。

 -- オブジェクト生成 on predicate: new -PREDICATE +MODULE +PREDNAME +ARITY
     MODULE(モジュール・オブジェクト)、PREDNAME(記号アトム)、
     ARITY(整数)で指定する述語に対応する
     新しいオブジェクト PREDICATE を生成します。
     オブジェクト生成ゴールのフォーマットについては、
     *Note ジェネリック・オブジェクトの生成: Creating Objects。

 -- ガード・メソッド on predicate: predicate +PREDICATE
     PREDICATE が述語オブジェクトか否かをテストします。

 -- ガード・メソッド on predicate: arity +PREDICATE -ARITY
 -- ボディ・メソッド on predicate: arity +PREDICATE -ARITY
     述語PREDICATE の引数個数を ARITY へ返します。

 -- ボディ・メソッド on predicate: apply +PREDICATE +ARGVEC
     述語オブジェクトの PREDICATE で指定した述語を ARGVEC で指定した引
     数で呼び出します。ARGVEC は、PREDICATE に渡す引数のベクタです。し
     たがって、ベクタのサイズは、述語の引数個数と一致させる必要があり
     ます。

 -- ボディ・メソッド on predicate: call +PREDICATE +ARGS...
     述語オブジェクトの PREDICATE で指定した述語を `ARGS...' で指定し
     た引数で呼び出します。引数の数は、述語の引数個数と一致させる必要
     があります。

 -- ボディ・メソッド on predicate: module +PREDICATE -MODULE
     PREDICATE が属するプログラム・モジュールを、モジュール・データ・オブジェクトとして MODULE へ返します。

 -- ボディ・メソッド on predicate: name +PREDICATE -NAME
     述語 PREDICATE の名前を、記号アトムとして NAME へ返します。



File: KLICj.info, Node: Unix, Next: Input and Output, Prev: Executable Code, Up: Builtin and Library

Unix インタフェース
===================

`unix' という名前のモジュールによって、ホスト・オペレーティング・システム(代表例として `Unix')の機能を KL1 プログラムから利用できるようになります。

機能のほとんどは、 `unix' モジュールが提供する述語 `unix/1' で獲得した
ストリームに対するメッセージとして利用可能です。いくつかの機能は、述語
として提供しています。

* Menu:

* Unix Stream::                 Unix インタフェース・ストリームの獲得
* I/O Opening::                 入出力用ストリームのオープン
* Sockets::                     ソケットの使い方
* Files & Dirs::                ファイルとディレクトリ
* Signals::                     シグナル割込みの処理
* Misc Unix Messages::          Unix ストリームへのシュシュのメッセージ
* Predicate Interface::         述語インタフェース



File: KLICj.info, Node: Unix Stream, Next: I/O Opening, Prev: Unix, Up: Unix

Unix インタフェース・ストリームの獲得
-------------------------------------

ユーザは、unix モジュールをメッセージ・ストリームを介して利用します。
そのストリームは、次の述語を呼び出すことによって得られます。

 -- predicate on unix: unix ?STREAM
     Unix インタフェースに対応するメッセージ・ストリームを STREAM へ返
     します。

述語の呼出し順序は、保証できないため、Unix インタフェース機能のほとん
どは、述語として提供*しません*。仮に、Unix インタフェースが述語として
提供されるとしたら、次に示す例の `ls' の結果は、実行順序に依存すること
になります。
     unix:cd("a", 0),
     unix:cd("b", 0),
     unix:system("ls", 0)

つまり、実行順序によっては、ディレクトリ `a' を表示したり、 `b' を表示
したり、または、2 つの `cd' を実行する前にどこかのディレクトリを表示し
たりするかもしれません。一方、次に示す例の場合は、実行順序によってでは
なく、リスト中に並んだ要素の順序に従って、2 つの `cd' と、`ls' を実行
します。

     unix:unix([cd("a", 0),
                cd("b", 0),
                system("ls", 0)])

@noindent

並列実装では、KLIC は複数プロセスを構成します。すべてのメッセージは、
unix ストリームを獲得するプロセスで処理します。例えば、`cd(Path)' メッ
セージは、単一プロセスのワーク・ディレクトリと、他に何も存在しないワー
ク・ディレクトリを変更します。

複数のメッセージ・ストリームを獲得した場合、異なるストリームへ送られた
メッセージ間の同期はとりません。



File: KLICj.info, Node: I/O Opening, Next: Sockets, Prev: Unix Stream, Up: Unix

入出力用ストリームのオープン
----------------------------

Unix ストリームに、次のメッセージを送って、Unix I/O ストリームをオープンします。
入出力を実行するために(Unix ストリーム自身ではなく) Unix I/O ストリームに
送るメッセージについては、別の場所で説明します
(*Note C 風のインタフェースを用いた入出力: C-like I/O,
*Note Prolog 風のインタフェースを用いた入出力: Prolog I/O)。

次に示す例は、「hello world」と出力する KLIC プログラムです。

     main :- unix:unix([stdout(R)]), check_and_write(R).

     check_and_write(normal(R)) :- R = [fwrite("hello world\n")].

 -- メッセージ on unix ストリーム: stdin -RESULT
 -- メッセージ on unix ストリーム: stdout -RESULT
 -- メッセージ on unix ストリーム: stderr -RESULT

     これらのメッセージによって、プロセスの標準入力、標準出力、および
     標準エラー・ファイルと関連する個々のストリームをオープンし、
     RESULT へ`normal(STRING)'を返します。

 -- メッセージ on unix ストリーム: read_open +PATH -RESULT
 -- メッセージ on unix ストリーム: write_open +PATH -RESULT
 -- メッセージ on unix ストリーム: append_open +PATH -RESULT
 -- メッセージ on unix ストリーム: update_open +PATH -RESULT
     これらのメッセージによって、文字列の PATH に指定したファイルをオー
     プンし、RESULT へ `normal(STRING)'を返します。オープン・モードは、
     入力、出力、追加、および入力/出力の各モードです。ファイルのオープ
     ンに失敗した場合、 `abnormal' を返します。



File: KLICj.info, Node: Sockets, Next: Files & Dirs, Prev: I/O Opening, Up: Unix

ソケットの使い方
----------------

Unix ストリームに以下のメッセージを送って、Unix とインターネットのプロ
トコルのソケットを獲得します。SOCK_STREAM 型のソケットだけを提供してい
ます。

 -- メッセージ on unix ストリーム: connect +SPEC -RESULT
     ソケットを生成し、Spec で指定されたソケット・アドレスと接続し、RESULT へ `normal(STRING) 'を返します。
     SPECは、以下に示す形式のいずれかです。

     unix(PATH)パス名 PATH を持つ Unix ドメインのソケットをオープンし
          ます。inet(HOSTNAME, PORT)ホスト名 HOSTNAME とポート番号
          PORT で指定したホストのインターネット・ドメインのソケットを
          オープンします。inet({B1, B2, B3, B4}, PORT)インターネット・
          ドメインのソケットをオープンし、インターネット・アドレスの
          B1 から B4 で指定したホストをオープンします。獲得したストリー
          ムで、入力と出力の両方のメッセージを処理します。

 -- メッセージ on unix ストリーム: bind +SPEC -RESULT
     ソケットを生成し、SPEC で指定したソケット・アドレスへバインドしま
     す。SPEC の形式は、インターネット・ドメインのソケットに対する
     HOSTNAME を省略している他は、 `connect' の場合と同じです。
     `normal(STREAM)' を RESULT へ返します。この STREAM はバインドされ
     たソケット・ストリームであるため、直接 I/O メッセージを処理しませ
     ん。I/O メッセージ・ストリームを得るためには、さらに `accept' メッ
     セージを使用します。ソケットが `unix' ドメインの場合、バインドさ
     れたソケット・ストリームを閉じ、SPEC 中の PATH で指定された名前付
     きソケットをアンリンクします。

 -- メッセージ on バウンド・ソケット: accept -RESULT
     ソケットへの接続を受け入れ、RESULT へ `normal(STREAM)' を返します。
     ここで、STREAM は入力と出力の両メッセージ用のI/O メッセージ・スト
     リームです。

ソケットは、非同期 I/O を提供します。すなわち、KLIC システムでは、接続
待ちや接続の受け入れ時に他のプロセスを中断することはありません。ソケッ
トに対して、空のバッファから読み込んだり、満杯のバッファに書き出したり
しても全体の演算実行は中断しません。そのような入出力操作は、操作が可能
になるまで延期します。

*制限事項*:ソケットへの操作を延期した場合、ソケットに対する残りの操作
のすべても、延期した操作が完了するまで延期します。このことは、入力と出
力の双方をポーリングする必要がある場合に問題です。この問題は、将来のリ
リースで解決する予定です。

*Linux に関する制限事項*:現在の版では、非同期 I/O は(少なくとも
Slackware 1.2.0 の)Linuxに対しては機能しません。



File: KLICj.info, Node: Files & Dirs, Next: Signals, Prev: Sockets, Up: Unix

ファイルとディレクトリ
----------------------

unix ストリームに次のメッセージを送り、ファイルとディレクトリを処理し
ます。

 -- メッセージ on unix ストリーム: cd +PATH -RESULT
     ワーク・ディレクトリを PATH に変更します。変更が成功した場合、
     RESULT へ `0' を返し、それ以外の場合、`-1' を返します。これは、シ
     ステム・コールの `chdir' に相当します。

 -- メッセージ on unix ストリーム: unlink +PATH -RESULT
     PATH で指定されたディレクトリの登録を削除します。削除が成功した場
     合、RESULT へ `0' を返し、それ以外の場合、`-1' を返します。これは、
     システム・コールの `unlink' に相当します。

 -- メッセージ on unix ストリーム: mktemp +TEMPLATE -FILENAME
     指定された TEMPLATE からユニークなファイル名を生成し、FILENAME へ
     返します。これは、C ライブラリ・ルーチンの `mktemp' に相当します。
     ただし、ライブラリ・ルーチンとは異なり、テンプレートは 6 個の終了
     文字 X を持つ必要がありません。何らかの理由で、ユニークなファイル
     名が作成できない場合、FILENAME へ空文字列を返します。

 -- メッセージ on unix ストリーム: access +PATH +MODE -RESULT
     パス名 PATH のファイルに、モード MODE でアクセス可能か否かをチェッ
     クします。その結果を RESULT へ返します。これは、C ライブラリ・ルー
     チンの `access' に相当します。ファイルがアクセス可能な場合、`0'
     を返し、それ以外の場合、`-1' を返します。

     MODE は、各ビットが以下に示す意味を持つ整数です。
     MODE に 0 を指定した時は、ファイルが存在するか否かだけを調べます。
     4
          読み込み可
     2
          書き出し可
     1
          実行可

 -- メッセージ on unix ストリーム: chmod +PATH +MODE -RESULT
     パス名 PATH を持つファイルの許可モードを MODE に変更します。
     これは、システム・コールの `chmod' に相当します。
     モードの変更が成功した場合、RESULT へ `0' を返し、それ以外の場合、`-1' を返します。
     MODEは、標準的な Unix の許可ビットを持つ整数です。

 -- メッセージ on unix ストリーム: umask -OLDMASK
 -- メッセージ on unix ストリーム: umask -OLDMASK +NEWMASK
     現在のファイルの生成マスクを OLDMASK へ返します。引数が 2 個の場
     合、ファイル作成マスクに NEWMASK を設定します。これは、システム・
     コールの `umask' に相当します。



File: KLICj.info, Node: Signals, Next: Misc Unix Messages, Prev: Files & Dirs, Up: Unix

シグナル割込みの処理
--------------------
Unixシグナルは、 unix ストリームに対して次のようなメッセージを使用して、
整数のリストに変更します。

 -- メッセージ on unix ストリーム: signal_stream +SIGNAL -RESULT
     SIGNAL(整数値)で指定された unixシグナルを捕捉して報告します。引数
     RESULT は `normal(STREAM)'になり、指定された種類のシグナルが到着
     したとき、そのシグナル番号を Stream に送ります。例えば、シグナル
     2( BSD と SVR4 での SIGINT )が見つかると、Stream は`[2|REST]' に
     なります。その後、到着したシグナルは、REST に報告されます。

*制限事項*: Unix の制限によって、シグナルを捕捉する前に同じシグナルの
発生が 2 回を超えると、シグナルは無視することがあります。



File: KLICj.info, Node: Misc Unix Messages, Next: Predicate Interface, Prev: Signals, Up: Unix

Unix ストリームへの種々のメッセージ
-----------------------------------

Unix ストリームに次のメッセージを送り、Unix の種々の機能を利用します。

 -- メッセージ on unix ストリーム: system +COMMAND -RESULT
     新たに生成したサブシェルで、 COMMAND(文字列)を実行し、終了コード
     を RESULT へ返します。これは、システム・コールの `system' に相当
     します。

 -- メッセージ on unix ストリーム: getenv +NAME -VALUE
     名前 NAME の環境変数の値を VALUE へ返します。これは、ライブラリ・
     ルーチンの `getenv' に相当します。そのような環境変数が存在しない
     場合、整数 `0' を VALUE へ返します。

 -- メッセージ on unix ストリーム: putenv +STRING -RESULT
     最初の引数 STRING は、`NAME = VALUE' の形式にしてください。環境変
     数 NAME を VALUE で追加または更新します。これは、ライブラリ・ルー
     チンの `putenv' に相当します。追加または更新が成功した場合、
     RESULT へ `0' を返し、それ以外の場合、0 以外の整数値を返します。

 -- メッセージ on unix ストリーム: kill +PID +SIG -RESULT
     PID で指定した 1 つのプロセスまたはプロセス・グループへシグナル SIG を送り、送信が成功した場合、RESULT へ `0' を返し、失敗した場合、`-1' を返します。

 -- メッセージ on unix ストリーム: fork -PID
     現行プロセスのコピーである新しいプロセスを、フォークします。これ
     は、システム・コールの `fork' に相当します。子プロセスの生成が成
     功した場合、親プロセスの PID へ子プロセスのプロセス ID を返し、子
     プロセスへ `0' を返します。

 -- メッセージ on unix ストリーム: fork_with_pipes -RESULT
     パイプを生成して、新しいプロセスをフォークします。新しいプロセス
     は、現行プロセスのコピーです。親プロセスでは、RESULT を
     `parent(PID,IN,OUT)' で単一化します。ここで、PID は新たに作成され
     たプロセスのプロセス ID です。新たに生成した子プロセスでは、
     RESULT を `child(IN,OUT)' で単一化します。

     IN と OUT は パイプへの Unix I/O ストリームです。ここで、親の OUT
     は出力ストリームであり、子の入力ストリーム IN に接続し、子の OUT
     は親の INに接続しています。



File: KLICj.info, Node: Predicate Interface, Prev: Misc Unix Messages, Up: Unix

述語インタフェース
------------------

いくつかの unix インタフェースを、 `unix' モジュール中で定義した述語と
して提供しています。

 -- unix on predicate: argc -ARGC
     KLIC で使用しないコマンド行引数の数を ARGC へ返します。そのような
     引数は、`-'で始まらない最初の引数や、コマンド行の`--'の後から始ま
     る引数です。

 -- predicate on unix: argv -ARGLIST
     KLIC で使用しないコマンド行引数を、文字列のリストとして ARGLIST
     へ返します。

 -- predicate on unix: exit +EXITCODE
     直ちに、終了コードの EXITCODE でプロセスを終了します。

 -- predicate on unix: times -UTIME -STIME -CUTIME -CSTIME
     ミリ秒単位でプロセス・タイムを返します。
     UTIME はユーザ・タイムであり、STIME はシステム・タイムです。
     CUTIME と CSTIME は、それぞれ子プロセス用のものです。

     `HZ'(秒当たりのクロック数) が標準的な場所で定義されていない場合、システムは 60 を仮定します。



File: KLICj.info, Node: Input and Output, Next: System Control, Prev: Unix, Up: Builtin and Library

入出力
======
KLIC は 2 種類の入出力操作群を提供しています。1 つは C 風のインタフェー
ス、もう 1 つは Prolog 風のインタフェースです。

C 風の機能は低レベルであり、速度とコード・サイズの両面で高性能です。し
かし、プロトタイプとデバッグのフェーズでは、Prolog 風の高レベルなイン
タフェースの方が、データ構造の入出力が直接可能なので有利になります。

* Menu:

* C-like I/O::                  C 風のインタフェースを用いた入出力
* Prolog I/O::                  Prolog 風のインタフェースを用いた入出力



File: KLICj.info, Node: C-like I/O, Next: Prolog I/O, Prev: Input and Output, Up: Input and Output

C 風のインタフェースを用いた入出力
----------------------------------

この節では、C 風のインタフェースを用いた入出力操作を説明します。

このインタフェースは、ファイル、ソケット、パイプなどへのストリームに対
するメッセージとして提供しています。これらのストリームは、Unix ストリー
ムへメッセージを送って獲得します(*Note 入出力用ストリームのオープン:
I/O Opening.)。

* Menu:

* Common Msgs (C style)::       C 風のインタフェースを用いた共通メッセージ
* Input Msgs (C style)::        C 風のインタフェースを用いた入力メッセージ
* Output Msgs (C style)::       C 風のインタフェースを用いた出力メッセージ



File: KLICj.info, Node: Common Msgs (C style), Next: Input Msgs (C style), Prev: C-like I/O, Up: C-like I/O

C 風のインタフェースを用いた共通メッセージ
..........................................

次に示すメッセージは、C 風の入出力用の入力ストリームと出力ストリームの
両方に利用できます。

 -- メッセージ on C 風の I/O : feof -RESULT
     ストリームがファイルの終端の場合、RESULTへ `1' を返し、それ以外の
     場合、`0'を返します。これは、ライブラリ・ルーチンの `feof' に相当
     します。

 -- メッセージ on C 風の I/O : fseek +OFFSET +PTRNAME -RESULT
     オフセットとポインタ名を、それぞれ OFFSET と PTRNAME に指定してス
     トリームの位置を変更します。PTRNAME が0のときファイルの先頭からの、
     1のとき現在位置からの、2のときファイルの末尾からのオフセットを、
     符合付き整数で指定します。変更が成功した場合、RESULTへ `0' を返し、
     それ以外の場合、`-1' を返します。

     あまり大きなファイル(long int が32ビットのシステムでは128MBより大)を
     対象とした場合、整数型の値の範囲による制限のため、このメッセージ
     では任意位置への移動はできない場合があることに注意して下さい。

 -- メッセージ on C 風の I/O : ftell -RESULT
     現在の位置(バイト単位)のオフセットを、 RESULT へ返します。

     あまり大きなファイル(long int が32ビットのシステムでは128MBより大)を
     対象とした場合、整数型の値の範囲による制限のため、得られた位置が
     誤っている場合があることに注意して下さい。

 -- メッセージ on C 風の I/O : fclose -RESULT
     ストリームをクローズします。クローズが成功した場合、RESULTへ `0'
     を返し、それ以外の場合、`-1' を返します。クローズの後、`sync/1'
     の他はストリームにメッセージを送ってはなりません。

 -- メッセージ on C 風の I/O : sync -RESULT
     RESULT へ `0' を返します。先行するすべてのメッセージが、既に処理
     済みであることを確認するのに有効です。



File: KLICj.info, Node: Input Msgs (C style), Next: Output Msgs (C style), Prev: Common Msgs (C style), Up: C-like I/O

C 風のインタフェースを用いた入力メッセージ
..........................................
次のメッセージが C 風の入出力用の入力ストリームに利用できます。

 -- メッセージ on C 風の I/O : getc -C
     ストリームから 1 バイトを読み込み、C へ返します。ファイルの終端の
     場合、`-1' を返します。

 -- メッセージ on C 風の I/O : ungetc +C
      1 バイトの C を、ストリームにプッシュ・バックします。

 -- メッセージ on C 風の I/O : fread +MAX -STRING
     ストリームから最大 MAX バイトを読み込み、そのデータを、バイト文字
     列として STRING へ返します。現在の実装では、4,096 バイトまでしか
     処理できません。読み込んだ文字列の長さが、指定した最大値 MAX より
     小さい場合がありますので、注意してください。この現象は、標準ファ
     イルではファイルの終端で発生し、パイプやソケットではいつでも発生
     する可能性があります。

 -- メッセージ on C 風の I/O : linecount -COUNT
     これまでに検出した改行文字の数を、COUNT へ返します。ファイルの第
     1 行では、まだ改行文字を検出していないので `0' を返します。行数の
     カウントが 1 で始まる場合(通常)は、改行文字の数に 1 を加えること
     で行数が計算できます。

     ただし、`fseek/2' メッセージを使用する場合、この行数は正しく計算
     されません。



File: KLICj.info, Node: Output Msgs (C style), Prev: Input Msgs (C style), Up: C-like I/O

C 風のインタフェースを用いた出力メッセージ
..........................................
次のメッセージが C 風の入出力用の出力ストリームに利用できます。

 -- メッセージ on C 風の I/O : putc +C
      1 バイトの C をストリームに書き出します。

 -- メッセージ on C 風の I/O : NUMBER
      1 バイトの NUMBER をストリームに書き出します。これは、
     `putc(NUMBER)' に相当します。

 -- メッセージ on C 風の I/O : fwrite +STRING -RESULT
     バイト文字列 STRING の内容をストリームに書き出します。実際に書き
     出したバイト数を RESULT へ返します。実際に書き出したバイト数は、
     STRING の長さより短くなる場合があります。

 -- メッセージ on C 風の I/O : fwrite +STRING
     バイト文字列の STRING の内容をストリームに書き出します。引数
     RESULT を持つ `fwrite' のメッセージと違って、STRING 中のすべての
     バイトが出力されるまで待ちます。これは、インターネットのソケット
     やパイプのような、出力に予測できない時間を必要とするストリーム用
     には望ましくありません。

 -- メッセージ on C 風の I/O : fflush -RESULT
     ストリームに残っている出力をフラッシュします。フラッシュが成功し
     た場合、RESULT へ `0' を返し、それ以外の場合、`-1' を返します。



File: KLICj.info, Node: Prolog I/O, Prev: C-like I/O, Up: Input and Output

Prolog 風のインタフェースを用いた入出力
---------------------------------------

演算子順位文法に基づく Prolog 風の項の処理機能を持つ Unix インタフェー
スのストリームは、以下に示すモジュールの `klicio' 述語によって獲得でき
ます。

KLIC の項の構文は、Edinburgh Prolog によく似ていますが、細かい点で異なっ
ています。詳細については、*Note 記号アトムの表記: Notation of Atoms、
*Note 整数の表記: Notation of Integers、*Note 浮動小数点数の表記:
Notation of Floats、*Note ファンクタの表記: Notation of Functors、
*Note リストの表記: Notation of Lists、*Note ベクタの表記: Notation of
Vectors、*Note 文字列の表記: Notation of Stringsなどを参照してください。

* Menu:

* Opening Prolog I/O::          Prolog 風の I/O ストリームのオープン
* Common Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Input Msgs (Prolog style)::   Prolog 風のインタフェースを用いたメッセージ
* Output Msgs (Prolog style)::  Prolog 風のインタフェースを用いたメッセージ
* Wrapped Terms::               ラップした項



File: KLICj.info, Node: Opening Prolog I/O, Next: Common Msgs (Prolog style), Prev: Prolog I/O, Up: Prolog I/O

Prolog 風の I/O ストリームのオープン
....................................

 -- klicio  on predicate: klicio ?STREAM
     Prolog 風の項のインタフェースに対応するメッセージ・ストリームを
     STREAM へ返します。獲得したストリームは、 Unix のインタフェース・
     ストリームのように機能します。つまり、このストリームは、実際に入
     出力を行うメッセージ・ストリームを獲得するために使用します。この
     ストリームを介して獲得した I/O ストリームは、通常の C 風の I/O メッ
     セージに加えて、この節で説明する Prolog 風の項の 入出力に対するメッ
     セージも受け取ります。

     パーシングやアンパーシング用のモジュールは、無視できない大きさな
     ので、Prolog 風の項の入出力を必要としないプログラムに対して、その
     モジュール*なし*で実行できるように、別モジュールとして提供します。

 -- メッセージ on klicio ストリーム: stdin -RESULT
 -- メッセージ on klicio ストリーム: stdout -RESULT
 -- メッセージ on klicio ストリーム: stderr -RESULT
 -- メッセージ on klicio ストリーム: read_open +PATH -RESULT
 -- メッセージ on klicio ストリーム: write_open +PATH -RESULT
 -- メッセージ on klicio ストリーム: append_open +PATH -RESULT
 -- メッセージ on klicio ストリーム: update_open +PATH -RESULT

     これらのメッセージは、Prolog 風の I/O ストリームをオープンします。
     実際に入出力を実行するために、(`klicio' ストリーム自身では*ない*)
     Prolog 風の I/O ストリームに送るメッセージについては、次に述べま
     す。

     これらのメッセージは、返された I/O ストリームが C 風の I/O ストリー
     ム用メッセージに*加えて*、Prolog 風の項の入出力用メッセージも解釈
     する他は、 `Unix' ストリームに対するメッセージと全く同じように機
     能します。

     Prolog 風の I/O ストリームは、演算子定義を持ちます。さらに、各ス
     トリームは異なる演算子定義を持つことができます。したがって、演算
     子をあるストリームに追加したり、あるストリームから取り除いたりし
     ても、他のストリームで使用する演算子には、影響*しません*。各スト
     リームは、生成後すぐにデフォルトの演算子の集合を持ちます。



File: KLICj.info, Node: Common Msgs (Prolog style), Next: Input Msgs (Prolog style), Prev: Opening Prolog I/O, Up: Prolog I/O

Prolog 風のインタフェースを用いた共通メッセージ
...............................................

以下に示す、C 風の I/O ストリーム用メッセージは、Prolog 風の I/O スト
リームに使用できます。

 -- メッセージ on Prolog 風の I/O : feof -RESULT
 -- メッセージ on Prolog 風の I/O : fseek +OFFSET +PTRNAME -RESULT
 -- メッセージ on Prolog 風の I/O : ftell -RESULT
 -- メッセージ on Prolog 風の I/O : fclose -RESULT
 -- メッセージ on Prolog 風の I/O : sync -RESULT
     詳細については、*Note C 風のインタフェースを用いた共通メッセージ:
     Common Msgs (C style)。

 -- メッセージ on Prolog 風の I/O : addop +OP +TYPE +PREC
     優先順位 PREC を持つ型 TYPE の演算子 OP を追加します。

 -- メッセージ on Prolog 風の I/O : rmop +OP +TYPE
     型 TYPE の演算子 OP を取り除きます。



File: KLICj.info, Node: Input Msgs (Prolog style), Next: Output Msgs (Prolog style), Prev: Common Msgs (Prolog style), Up: Prolog I/O

Prolog 風のインタフェースを用いた入力メッセージ
...............................................

 -- メッセージ on Prolog 風の I/O : gett -TERM
     関連する入力ストリームから KLIC の構文項の形で TERM へ読み込みま
     す。構文解析に失敗した場合、メッセージを `stderr' に出力した後、
     別の項を読み込みます。ファイルの終了時には、アトム `end_of_file'
     を返します。

 -- メッセージ on Prolog 風の I/O : getwt -RESULT
     関連する入力ストリームから KLIC の構文項の形で TERM へ読み込み、
     結果をRESULT へ返します。構文解析が成功した場合、RESULT は、
     `normal(WRAPPEDTERM) 'の形式になります。ここで、WRAPPEDTERM とは、
     読み込んだ項の基底項表現のことです。変数は、変数名の情報を持つ基
     底項として表現します。構文解析が失敗した場合、メッセージを
     `stderr' に出力した後、別の項を読み込みます。ファイルの終了時には、
     `normal(end_of_file) 'を返します。

     ラップした項の操作については、*Note ラップした項: Wrapped Terms。

以下に示す、C 風の I/O ストリーム用メッセージは、Prolog 風の I/O スト
リームに使用できます。

 -- メッセージ on Prolog 風の I/O : getc -C
 -- メッセージ on Prolog 風の I/O : ungetc +C
 -- メッセージ on Prolog 風の I/O : fread +MAX -STRING
 -- メッセージ on Prolog 風の I/O : linecount -COUNT
     詳細については、*Note C 風のインタフェースを用いた入力メッセージ:
     Input Msgs (C style)。



File: KLICj.info, Node: Output Msgs (Prolog style), Next: Wrapped Terms, Prev: Input Msgs (Prolog style), Up: Prolog I/O

Prolog 風のインタフェースを用いた出力メッセージ
...............................................

 -- メッセージ on Prolog 風の I/O : putt +TERM
 -- メッセージ on Prolog 風の I/O : puttq +TERM
 -- メッセージ on Prolog 風の I/O : putwt +WRAPPEDTERM
 -- メッセージ on Prolog 風の I/O : putwtq +WRAPPEDTERM

     項 TERM やラップした項 WRAPPEDTERMを、関連する出力ストリームへ書
     き出します。

     文字 `q' の付いて*いない*メッセージは、再び、読み込みをする必要が
     ある場合でも、記号アトムを 2 つの引用符で囲みません。しかし、現在
     のところでは `q' の付いたメッセージと全く同じように機能します。

     現在の版の出力フォーマットは、マシンが読めるだけで、人間が読める
     形式ではありません。つまり、演算子を全く使用しないですべてのアト
     ムを括弧で囲んでいます。

     ラップした項の操作については、*Note ラップした項: Wrapped Terms。

以下に示す、C 風の I/O ストリーム用メッセージは、Prolog 風の I/O スト
リームに使用できます。

 -- メッセージ on Prolog 風の I/O : putc +C
 -- メッセージ on Prolog 風の I/O : NUMBER
 -- メッセージ on Prolog 風の I/O : fwrite +STRING -RESULT
 -- メッセージ on Prolog 風の I/O : fwrite +STRING
 -- メッセージ on Prolog 風の I/O : fflush -RESULT
     詳細については、*Note C 風のインタフェースを用いた出力メッセージ:
     Output Msgs (C style)。

項を終了させるピリオドは、これらのメッセージでは書き出せないので注意し
てください。ピリオドと空白や改行文字は通常、再び、読み込みをするために
書き出す必要があります。以下に示すゴール列は、`/tmp/foo.bar'という名前
のファイルをオープンして、変数X の完全な具体化を待ち、後にピリオドと改
行が続く Prolog 風の形式で出力します。

     klicio:klicio([write_open("/tmp/foo.bar", normal(S))]),
     S = [putt(X), putc(0'.), nl].

 -- メッセージ on Prolog 風の I/O : nl
     改行コードを出力します。メッセージの `putc(10)' を同じストリーム
     に送ることと、同じ意味になります。

Prolog 風のI/Oストリームも、`putc/1' や `getc/1' といった C 風の入出力
が受け取るメッセージのすべてを受け取るので注意してください(*Note C 風
のインタフェースを用いた入出力: C-like I/O.)。



File: KLICj.info, Node: Wrapped Terms, Prev: Output Msgs (Prolog style), Up: Prolog I/O

ラップした項
............

変数を含む項のメタレベルの操作を可能にするため、KLIC では "ラップした
項(wrapped term)" と呼ばれるデータ表現を提供しています。ラップした項は、
その中に変数を含まない基底項です。ラップした項は、以下に示す形式を持っ
ています。

variable(VARNAME)
     VARNAME という名前文字列を持つ変数
atom(ATOM)
     記号アトム ATOM
integer(INT)
     整数 INT
floating_point(FLOAT)
     浮動小数点数 FLOAT
list([CAR|CDR])
     CAR と CDR で構成される コンス・セル；CAR と CDR は自己再帰的なラップした項
functor(FUNCTOR(ARG, ...)
     ファンクタの構造；その引数の(ARG, ...)は自己再帰的なラップした項
vector({ELEM, ...})
     ベクタ；その要素の(ELEM, ...)は自己再帰的なラップした項
string(STR)
     文字列 STR
unknown(TERM)
     不明データ；この場合ラッピングが不正確になることがあります

例えば、以下の項

     f(a, X, {3, ["abc"|X]}, 3.14)  を

ラップした表現は、以下のようになります。

     functor(f(atom(a),
             variable("X"),
             vector({integer(3), list([string("abc")|variable("X")])}),
             floating_point(3.14))).

次の述語は、ラップした項を通常の項に変換します。

 -- predicate on 変換: unwrap -WRAPPED ?TERM
     ラップした項 WRAPPED を通常の項 TERM に変換します。

ラップした項は、通常、入力操作の結果として獲得します(*Note Prolog 風の
インタフェースを用いた入力メッセージ: Input Msgs (Prolog style).)。

ラップした項も、通常の KL1 の項と変わりがないので、通常のユーザ・プロ
グラムで作成できます。通常の項を、ラップした項に変換する次の述語も、あ
る場合には有効です。

 -- predicate on variable: wrap ?TERM -WRAPPED
     通常の項 TERM を、ラップした項 WRAPPED に変換します。

     現在の版では、すべての変数に同じ名前の `_' を与えています。したがっ
     て、ある項をラップし、その結果をアンラップすると、元の項の中のす
     べての変数が、同じ名前で参照できるようになってしまいます。これは
     バグですので、将来のバージョンでは修復する予定です。

     TERM が同じ変数を複数個含んでいるとき、並行して演算を続けていると、
     変数を具体化することがあります。このような場合、同じ変数を 2 つ含
     む項は、1 つは変数のまま、もう 1 つは変数でない項を含む形でラップ
     した項に変換されるかもしれません。このことは、この述語の仕様が内
     包する特有の問題ですので、おそらく修復は無理でしょう。したがって、
     この述語を非基底項 (non-ground terms) に適用する場合、デバッギン
     グ・ユーティリティといった、メタレベルのプログラムに限定すべきで
     す。



File: KLICj.info, Node: System Control, Prev: Input and Output, Up: Builtin and Library

システム動作の制御
==================

以下に示す述語は、`system_control' モジュール中に提供しています。

 -- predicate on system_control: postmortem +MODULE +GOAL -RESULT
     メイン・プログラムの正常終了や異常終了の後に実行する後処理を、登
     録します。GOAL は、ゴールの後処理の述語と引数を指定するファンクタ
     構造にする必要があります。  MODULE は、後処理を行う述語のモジュー
     ルを指定する記号アトムにする必要があります。1 つのゴールだけを指
     定できます。この場合、コンマで区切られたゴールの並びは許していま
     せん。

     登録が終了したら RESULT を `[]' で単一化します。登録の完了まで待
     ち状態になるので、他の処理は実行しません。

     この述語が何度も呼び出された場合、最後の登録が有効となります。

 -- predicate on system_control: gc -BEFORE -AFTER
     ガーベージ・コレクションを要求し、ガーベージ・コレクションの前後
     のヒープ・サイズを、それぞれワード単位で、BEFORE と AFTER へ返し
     ます。ワードのサイズは、インストールで使用した C 言語システムの
     `long' 型のサイズと同じです。

     並列実装では、局所的な記憶域に対するガーベージ・コレクションだけ
     が要求されます。大域的なガーベージ・コレクションの要求はできませ
     ん。



File: KLICj.info, Node: Timer, Next: Random Numbers, Prev: System Control, Up: Builtin and Library

タイマ
======

KLIC では実時間タイマを提供しています。Unix では 1 プロセスにつき 1 タ
イマしか提供されていませんが、KLIC ではこの機構を仮想化して必要な個数
のタイマを使用できます。

実時間タイマが利用できないホストシステム上の実装では、この機能は提供し
ていません。

時間の値は(時刻、時間間隔ともに) `time(DAY, SEC, USEC)' の形式の項で表
現します。ここで、 DAY, SEC and USEC はそれぞれ日、秒、マイクロ秒を表
す負でない整数です。また、SEC は 86,000 ( 1 日)未満、 USEC は
1,000,000 (1 秒)未満でなければなりません。

次の述語は、モジュール `timer' 中に提供しています。

 -- 述語 on timer: get_time_of_day -TIME
     1970 年 1 月 1 日の真夜中を起点とし、秒とマイクロ秒で表現した現在
     の時刻を、 TIME に返します。

     得られる時刻は、この述語が実際に実行されたときの時刻です。ゴール
     の実行順序は KLIC のシステムによることに注意して下さい。報告され
     る時間は、このゴールの親ゴールがリダクションされてから、TIME の値
     が検査されるまでの間であることのみ、保証されています。

     また、報告される時間は、この述語を実行するタスクが動作している OS
     が、返すものであることに注意して下さい。分散システムにおいては、
     各システム構成要素の時刻は完全に一致しているとは限りません。

 -- 述語 on timer: add TIME1 TIME2 -TIME
 -- 述語 on timer: sub TIME1 TIME2 -TIME
     それぞれ、二つの時間値の加算および減算を行います。

 -- 述語 on timer: compare TIME1 TIME2 -RESULT
     二つの時間値 TIME1 および TIME2 を比較し、
     結果を RESULT に返します。
     結果は、TIME1 が TIME2 より小さい(早い)場合は `<'、
     等しい場合は `='、
     TIME1 が TIME2 より大きい(遅い)場合は `>' になります。

 -- 述語 on timer: instantiate_at TIME -VAR
 -- 述語 on timer: instantiate_after INTERVAL -VAR
     指定された時間に、VAR を記号アトム `[]' と単一化します。前者の述
     語は指定された*時刻に*この動作を行いますが、後者は指定された*時間
     間隔後に*この動作を行います。指定時間をすでに過ぎていた場合は、変
     数はただちに単一化される場合があります。

     単一化操作には、任意時間の遅れが生じる可能性があることに注意して
     下さい。合理的な実装では、この遅れは短いはずです。

 -- 述語 on timer: instantiate_every INTERVAL STOP -VAR
     VAR を記号アトム `[]' のリストで順に単一化していきます。リストの
     最初の要素は指定した時間間隔後に単一化され、第二要素はさらに同じ
     時間間隔を経て単一化されます。この操作は引数 STOP が単一化される
     まで繰り返され、リストの終端を生成して終了します。

     単一化操作には、任意時間の遅れが生じる可能性があることに注意して
     下さい。合理的な実装では、この遅れは短いはずです。



File: KLICj.info, Node: Random Numbers, Prev: Timer, Up: Builtin and Library

乱数生成器
==========

オブジェクトクラス `random_numbers' により、疑似乱数を生成することがで
きます。この乱数生成器は `nrand48' によるものであり、ホストシステムに
`nrand48' がない場合はこの機能は利用できません。

 -- オブジェクト生成 on random_numbers: new -RANDOMS RANGE
 -- オブジェクト生成 on random_numbers: new -RANDOMS RANGE SEED
     0 から RANGE - 1 を含んだ範囲をとる整数の疑似乱数からなる、
     無限長のリストを RANDOMS に返します。 
     RANGE は正の整数です。

     任意指定の引数 SEED には乱数生成の種を指定します。同じ種を与えた
     場合、リストの要素は同じになることが保証されています。

     リストは仮想的に無限ですが、リスト要素はプログラムでその値を検査
     することによって、遅延的に計算されることに注意して下さい。



File: KLICj.info, Node: Using KLIC, Next: Type Index, Prev: Builtin and Library, Up: Top

KLIC の使い方
*************

この章では、KLIC システムの使い方について説明します。

* Menu:

* Compiling::                   KLIC におけるプログラムのコンパイル
* Running::                     KLIC におけるプログラムの実行
* Tracing::                     プログラム実行のトレース
* Install::                     インストール
* Distributed KLIC::            分散 KLIC
* Shared-Memory KLIC::          共有メモリ KLIC



File: KLICj.info, Node: Compiling, Next: Running, Prev: Using KLIC, Up: Using KLIC

KLIC におけるプログラムのコンパイル
===================================

インストールが完了すると、`klic' コマンドでKL1 プログラムを C 言語プロ
グラムへコンパイルし、実行可能コードを生成することが可能になります。
`klic' というプログラムは、様々なオプションが可能なコンパイラ・ドライ
バです。

* Menu:

* Command for Compilation::     コンパイル用コマンド
* Compiler Options::            コンパイラ・オプション
* Mechanism of Compilation::    KLIC コンパイラの動作内容



File: KLICj.info, Node: Command for Compilation, Next: Compiler Options, Prev: Compiling, Up: Compiling

コンパイル用コマンド
--------------------

引数に、拡張子 `.kl1' が付いた KL1 ソース・プログラム・ファイル名を指
定して、`klic' コマンドを実行すると、 KL1 プログラムは C 言語にコンパ
イルされ、実行可能コードが生成されます。

例えば、 XXX.kl1 をコンパイルしてコードを生成する場合、次のように入力
します:

     % klic XXX.kl1

実行結果は `a.out' となります。実行結果の名前を `YYY' としたい場合、次
のように入力します。

     % klic -o YYY XXX.kl1

例えば、プログラムが `XXX.kl1' 、`YYY.kl1' 、`ZZZ.kl1' のように複数個
のソース・ファイルに分割されている場合、次のように入力すると、一括して
コンパイルとリンクができます。

     % klic XXX.kl1 YYY.kl1 ZZZ.kl1

複数個の KL1 ソース・ファイルを別個にコンパイルして、後でリンクするこ
ともできます。リンケージ・エラーを避けるために、次のように `-c' オプショ
ンを指定して、リンク前にコンパイル・コマンドの実行を終わらせる必要があ
ります。

     % klic -c XXX.kl1
     % klic -c YYY.kl1
     % klic -c ZZZ.kl1

最後に、次のように入力して、複数のコンパイル結果をリンクすることができ
ます。

     % klic XXX.o YYY.o ZZZ.o

コンパイラ・オプションの詳細については、*Note コンパイラ・オプション:
Compiler Options。

直接 C でかかれたプログラム(例えば `CCC.c' と `DDD.c')をKL1 で書かれた
プログラム(例えば `XXX.kl1' と `YYY.kl1')のリンクは、次のように入力す
るだけで実行できます。

     % klic CCC.c DDD.c XXX.kl1 YYY.kl1

ファイル指定の順番は影響しません。C の関数は KL1 のインライン展開コー
 ド(*Note C 言語コードのインライン挿入: Inline C Code.) から呼び出すこ
 とが出来ます。



File: KLICj.info, Node: Compiler Options, Next: Mechanism of Compilation, Prev: Command for Compilation, Up: Compiling

コンパイラ・オプション
----------------------

コンパイル・コマンド klic のオプションの利用方法を、以下に示します。

-c
     再配置可能オブジェクトを生成し、klic コマンドを終了します。リンク
     は行ないません。

-C
      C 言語への変換を終了し、klic コマンドを終了します。

-d
     実際に実行するコマンド列を表示します。表示するだけで実行はしませ
     ん。 `-v' を仮定します。

-D DATABASE_MANAGER
     指定されたデータベース管理プログラムを使用します。

-g
      dbx 、 gdb などのデバッガ用の情報を含んだ実行可能コードを生成し
      ます。

-I DIRECTORY
     指定されたインクルード・パスを C コンパイル時に使用します。

-K KLIC_COMPILER
     指定された変換プログラムを KL1 から C への変換時に使用します。

-l LIBRARY
     指定されたライブラリをリンク時に使用します。

-L DIRECTORY
     指定されたライブラリ・パスをリンク時に使用します。

-o FILE
     指定された実行可能コードファイルの名前を生成します。

-O
-OLEVEL
     指定された最適化レベルで、コンパイルします。ゼロ以外の最適化レベ
     ルが指定されたとき、いくつかの付加的な最適化フラグも C コンパイラ
     に渡します。そのような付加的な最適化フラグは、システムに依存する
     ため、 KLIC システムのインストール手続きの際に決定されます。

     このオプションでは、 `-O' と LEVEL の間に空白があってはなりません。

-P PARALLEL
     サブタスク( C コンパイラなど)を並列で実行します。最大時には、並列
     のサブタスクを同時にフォークします。

-R
     ファイルの日付とは無関係に、再コンパイルをします。

-S
     アセンブリ・コードを生成し、klic コマンドを終了します。

-n
     デバッグなし実行時ライブラリをリンクします。このオプションが省略
     された場合、デバッグあり実行時ライブラリをリンクします。

-v
     実際に実行したすべてのコマンドを、標準エラー出力に出力します。

-xDIRECTORY
     指定されたディレクトリ中のデータベース・ファイル `klic.db' を使用
     します。また、 `atom.c' 、 `funct.c' 、 `predicates.c' や対応する
     オブジェクトも指定されたディレクトリに置きます。このオプションは、
     リンクするプログラムが複数のディレクトリに分散している場合に便利
     です。

-XDIRECTORY
     データベース・ファイル `klic.db' が存在しない場合、指定されたディ
     レクトリ下のデータベース初期化ファイル `klicdb.init' から
     `klic.db' を作成します。このオプションが省略された場合、デフォル
     トのライブラリ・ディレクトリを仮定します。

次に示す環境変数によって、コンパイラのデフォルトの動作を変えることがで
きます。コンパイル時に指定されたオプションの方は、環境変数の値よりも優
先します。

KLIC_LIBRARY
     実行時ライブラリ用のディレクトリです。
      `-X' オプションの方を優先します。

KLIC_DBINIT
     初期データベース用のディレクトリです。デフォルトは実行時ライブラ
     リ用のディレクトリです。

KLIC_COMPILER
      KL1 から C への変換プログラムです。
      `-K' オプションの方を優先します。

KLIC_DBMAKER
     データベース管理プログラムです。
      `-D' オプションの方を優先します。

KLIC_INCLUDE
     コンパイル時のインクルード・パスです。
      `-I' オプションの方を優先します。

KLIC_CC
     使用する C コンパイラです。

KLIC_CC_OPTIONS
     コンパイラ・オプションです。

KLIC_LD
     使用するリンカです。

KLIC_LD_OPTIONS
     リンカ・オプションです。



File: KLICj.info, Node: Mechanism of Compilation, Prev: Compiler Options, Up: Compiling

KLIC コンパイラの動作内容
-------------------------

KL1 プログラムのコンパイル過程や実行可能コードの生成過程を知ることによっ
て、 KLIC の使い方の理解を深めることができます。

KLIC システムは、以下のように 3 個のモジュールで構成されます。

   *  KLIC コンパイラ
   *  KLIC データベース管理プログラム
   *  KLIC 実行時ライブラリ

KLIC コンパイラは、KL1 プログラムを C 言語プログラムにコンパイルします。
KLIC コンパイラは同時に、`.extファイル' も生成します。このファイルは、
プログラムで使用しているアトムとファンクタの情報などを持ちます 。リン
クする個々のプログラムの `.ext' ファイル中にある情報は、後でデータベー
ス管理プログラムによってマージされ、 `atom.h' 、 `funct.h' 、 `atom.c'
、 `funct.c' 、 `predicates.c' になります。

 C コンパイラは、KLIC コンパイラが生成した C プログラムをコンパイルします。
その際、ヘッダ・ファイル `atom.h' 、 `funct.h' を使用します。
 `atom.c' 、 `funct.c' 、`predicates.c' もコンパイルして、実行時ライブラリとリンクします( `predicates.c' は、デバッグあり実行時ライブラリを使用するときだけリンクします)。

コンパイル、データベース管理、およびリンクは、コンパイラ・ドライバ・プログラム `klic' が制御します。
この klic プログラムは、 `cc' と `make' を組み合わせた機能に類似した機能を持っています。
 `cc' は、 C プリプロセッサ、 C コンパイラ・カーネル、およびリンカを制御します。
同様に、 `klic' は、 KL1 から C へのコンパイラ、 C コンパイラ、 KL1 プログラムのデータベース管理プログラム、およびリンカを制御します。
 `make' は、ファイルの日付をチェックし、コンパイルが必要なファイルだけをコンパイルします。
 `klic' も `make' と同様の処理を行います。



File: KLICj.info, Node: Running, Next: Tracing, Prev: Compiling, Up: Using KLIC

KLIC におけるプログラムの実行
=============================

生成された実行可能コードは、簡単に動かせます。KL1 プログラムをコンパイ
 ルして、実行可能コードを `a.out' に出力した場合、ファイル名 `./a.out'
 を使用中のシェルに渡すだけで実行できます。

`main' モジュール中の引数なし述語 `main' が、最初に実行されるゴールになります(*Note 初期ゴール: Initial Goal.)。

* Menu:

* Runtime Switches::            実行時オプション



File: KLICj.info, Node: Runtime Switches, Prev: Running, Up: Running

実行時オプション
----------------

実行可能コードを動かす際、以下に示すオプションが利用できます。

-h size
     ワード単位のヒープの初期サイズです。コピー方式のガーベージ・コレ
     クションを採用しているので、実際に使用するヒープ・サイズは、この
     2 倍になります。ヒープ・サイズは、(例えば、`2097152' のように)数
     値を直接指定したり、2^10 単位や 2^20 単位で `k' や `m' を数字の後
     ろに付けて(`2048k' や `2m' のように)指定したりできます。このオプ
     ションが省略された場合、初期サイズはマクロの `HEAPSIZE' によって
     決定します。配布版では、 HEAPSIZE は 24k になっています。1 ワード
     の長さは、C の`long int'型と同じです。実際の長さは、使用するハー
     ドウェアや C コンパイラに依存します。ヒープ・サイズは、 `-H' や
     `-a' オプションに従って自動的に増加します。

-H SIZE
     ワード単位の最大のヒープ・サイズです。ヒープは、指定されたサイズ
     までは自動的に拡張します。このオプションが省略された場合、無限大
     を仮定します。

-a RATIO
     ヒープ領域中でアクティブ・セル(ゴミでないセル)が占める割合の上限
     です。浮動小数点数で指定してください。アクティブ・セルの占有する
     割合が、指定された上限値を超えると、 `-H' オプションで指定された
     最大サイズを超えない限り、ヒープ・サイズを、次回のガーベージ・コ
     レクションで 2 倍にします。このオプションが省略された場合、0.5 を
     仮定します。

-g
     ガーベージ・コレクションに要した時間を計測します。ヒープが小さい
     とガーベージ・コレクションは非常に短い時間で行うので、計測オーバ
     ヘッドの方が大きくなってしまう可能性が高くなります。このオプショ
     ンが省略された場合、ガーベージ・コレクションの計測は行いません。

-s
     中断情報を計測します。プログラムの実行が終了すると、中断した述語
     とその中断回数を報告します。このオプションは、デバッグあり実行時
     ライブラリをリンクした場合にだけ有効です。このオプションを省略し
     ても、デバッグあり実行時ライブラリがリンクされるので、中断情報を
     計測します(*Note コンパイラ・オプション: Compiler Options.)。

-t
     トレース状態で、プログラムの実行を開始します(*Note プログラム実行
     のトレース: Tracing.)。このオプションは、デバッグあり実行時ライブ
     ラリをリンクした場合にだけ有効です。このオプションを省略しても、
     デバッグあり実行時ライブラリがリンクされるので、トレース状態にな
     ります。デバッグなし実行時ライブラリをリンクさせる場合には、コン
     パイル時のオプションで指定します(*Note コンパイラ・オプション:
     Compiler Options.)。

すべての実行可能ゴールが実行を終了すると、プログラムは停止します。デバッ
グあり実行時ライブラリがリンクされている場合、(実行可能ゴールは存在し
ないが)、入力データを待って中断しているゴールが存在した場合、中断の原
因となっているゴールが探索されて報告されます。デバッグなし実行時ライブ
ラリがリンクされている場合は、中断しているゴールの数だけが報告されます。




File: KLICj.info, Node: Tracing, Next: Install, Prev: Running, Up: Using KLIC

プログラム実行のトレース
========================

KLIC では、"スパイ"(ブレーク・ポイント)機能を持つデバッグ・トレーサを
提供します。

* Menu:

* Preparing for Trace::         トレース実行の準備
* Trace Ports::                 トレース・ポート
* Output of Tracer::            トレース表示のフォーマット
* Controlling Trace::           トレース制御コマンド
* Spying::                      スパイ
* Port Control::                トレース・ポートのコマンド
* Display Control::             表示を制御するコマンド
* Dumping Goals::               ゴールのダンプ
* Misc Trace Commands::         その他のコマンド
* Perpetual Suspension::        永久中断の探索



File: KLICj.info, Node: Preparing for Trace, Next: Trace Ports, Prev: Tracing, Up: Tracing

トレース実行の準備
------------------

トレース機能を使うには、プログラムをデバッグありの実行時ライブラリでリ
ンクする必要があります。特に指定がなければ、デバッグありの実行時ライブ
ラリがリンクされますが、コンパイル・コマンドの `klic' に `-n' オプショ
ンを指定すれば、トレースは行われません。

トレース対象のプログラムを、既に、`-n' オプションでコンパイル・リンク
している場合でも、プログラムを、初めから再コンパイルする必要はありませ
ん。このような場合、 `-n' オプションなしで再度 `klic' コマンドを実行す
ると、オブジェクトをデバッグありの実行時ライブラリとリンクするだけなの
で、短時間の操作で済みます。

プログラムの実行をトレースするには、`-t' オプションを付けてプログラム
を実行するだけです(*Note 実行時オプション: Runtime Switches.)。



File: KLICj.info, Node: Trace Ports, Next: Output of Tracer, Prev: Preparing for Trace, Up: Tracing

トレース・ポート
----------------

 KL1 プログラムの実行の様子を以下に示します。

  1. 初期ゴールの `main：main' は、実行するゴールを貯めておくためのゴー
     ル・プールに入れられます。

  2. 1 つのゴールがゴール・プールから取り出されます( `CALL' ポート)。

  3. ゴールは、プログラム節とマッチングされます。

  4. ゴールと一致する節があれば、ゴールはサブゴールにリダクションし、
     それらのサブゴールはゴール・プールに戻されます( `REDUCE' ポート)。

  5. ゴールと一致する節がない場合は、計算全体が放棄されます( `FAIL' ポー
     ト)。

  6. ゴール引数の値やそれらの構造が確定していないため、ゴールと一致す
     る節があるか否かを決定できない場合、ゴールは必要な値が揃うまで、
     ゴールを貯めておくための別のゴール・プールに入れられます(
     `SUSPEND' ポート)。

  7. ゴール・プールにゴールが残っていれば、ステップ 2 にループします。

ゴールの実行は、上記した 4 つのポイント、すなわち 2 、 4 、 5 、 6 番
がトレースされます。このような対象ポイントは "トレース・ポート"と呼ば
れ、それぞれ `CALL' 、 `REDUCE' 、 `FAIL' 、`SUSPEND' ポートと呼びます。

Prolog の 4 ポート・トレース・モデルに慣れ親しんでいれば、 Prolog の他
 の 2 つのポートの `EXIT' と `REDO' がないことを疑問に思うかもしれませ
 ん。KL1 プログラムは、バックトラックをしないので `REDO' ポートは存在
 しません。`EXIT' ポートは、次の 2 つの理由によってトレースされません。
 1 つは、ゴール - サブゴール階層のすべてについて、実行履歴を維持するこ
 とは、 Prolog のような逐次処理言語に比べて、 KL1 のような並列処理言語
 の方が負担が重くなるからです。これは、階層における多くの異なるサブツ
 リーが、データフローの同期機能のために、互いにインタリーブで動くため
 です。他の 1 つは、 KL1 プログラムがしばしば、同じ述語を末尾再帰呼出
 しの形式で呼び出すゴールとして各々が定義された、通信プロセスの集合と
 して書かれているためです。そのようなプロセス("永久プロセス":
 perpetual processes と呼ばれる場合がある)は、ほとんど終了することがな
 いので、終了を探索することはProlog の場合に比べ、意味がないためです。



File: KLICj.info, Node: Output of Tracer, Next: Controlling Trace, Prev: Trace Ports, Up: Tracing

トレース表示のフォーマット
--------------------------

以下に、サンプル・プログラムを示します。

     :- module main.

     main :- nrev([1,2],X), builtin:print(X).

     nrev([], R) :- R = [].
     nrev([W｜X], R) :- nrev(X, XR), append(XR, [W], R).

     append([], Y, Z)  :- Z = Y.
     append([W｜X], Y, WZ)  :- WZ = [W｜Z], append(X, Y, Z).

以下に、サンプル・プログラムの実行をすべてトレースした出力結果を示しま
す。

     1 CALL:main:main?
     1 REDU:main:main :-
     2   0:+nrev([1,2],_4)
     3   1:+builtin:print(_4)?
     2 CALL:main:nrev([1,2],_4)?
     2 REDU:main:nrev([1,2],_4) :-
     4   0:+nrev([2],_D)
     5   1:+append(_D,[1],_4)?
     4 CALL:main:nrev([2],_D)?
     4 REDU:main:nrev([2],_D) :-
     6    0:+nrev([],_18)
     7    1:+append(_18,[2],_D)?
     6 CALL:main:nrev([],_18)?
     6 REDU:main:nrev([],[])?
     7 CALL:main:append([],[],_D)?
     7 REDU:main:append([],[2],[2])?
     5 CALL:main:append([2],[1],_4)?
     5 REDU:main:append([2],[1],[2｜_1F]) :-
     8   0:+append([],[1],_1F)?
     8 CALL:main:append([],[1],_1F)?
     8 REDU:main:append([],[1],[1])?
     3 CALL:builtin:print([2,1])?
     [2,1]
     3 REDU:builtin:print([2,1])?

このプログラムでは、中断や失敗がないので、すべてのトレース出力は、
CALL ポートか REDUCE ポート( トレース例では、`REDU' と出力されている)
のどちらかになります。上記の 1 行目は、初期ゴール `main:main' の CALL
ポートのトレースです。

     1 CALL:main:main?

トレースされたすべてのゴールには、ゴール間で区別するために、一意な識別
子（整数値）が与えられています。1 カラム目の番号 `1' は、初期ゴールの
識別子です。

初期ゴールは、プログラムで定義した最初の節と一致するので、プログラム節
中で定義しているように、サブゴールにリダクションします。このリダクショ
ンは、以下のようにトレースされます。

     1 REDU:main:main :-
     2   0:+nrev([1,2],_4)
     3   1:+builtin:print(_4)?

これは、識別子 1 を持つオリジナル・ゴール `main:main' が、2 つの新しい
ゴールにリダクションしていることを示しています。この 2 つの新しいゴー
ルは、 `main:nrev([1,2],_4)' と `builtin:print(_4)' で、それぞれ識別子
2 と 3 を持ちます。

新しいゴールの識別子 2 と 3 に続く、番号の 0 と 1 は、リダクションによっ
て生成されたサブゴールのシーケンス番号です。これらのシーケンス番号は、
コマンドを適用するサブゴールを識別するために、トレーサ・コマンドによっ
て使用されます。グローバルな意味を持つ一意なゴール識別子と違って、これ
らのサブゴール番号は、この特定のポートでしか意味を持ちません。

次に続く `:' は、サブゴールが、親ゴールの通常のサブゴールであることを意味しています。
`:' 以外にも、次に示すものがトレース表示されます。
 `*' の場合は、 `*' に続くゴールもサブゴールですが、親とは異なる優先順位が与えられていることを意味します。
優先順位は疑似プラグマ形式で表示されます。
 `!' の場合は、 `!' に続くゴールは、実際に親からリダクションしたサブゴールではなく、このリダクションによって、具体的な値が変数に与えられたことで、実行可能となったゴールであることを意味します。

次に `+' か `-' のどちらかが続きます。ただ実行を継続するだけの場合、
`+' は、サブゴールをトレースし、 `-' は、トレースしないことを意味しま
す。これは、あとの項で述べるトレース・コマンドを指定することで変更でき
ます。上記の例では、すべてのサブゴールに `+' が付いているので、すべて
のサブゴールがトレースされます。

続いて、モジュール名、コロン（:） 、そしてサブゴールの述語名が表示され
ます。サブゴールの述語のモジュール名は、その述語が親ゴールの述語と同じ
モジュールに定義されている場合は、（:）とともに省略されます。上記の例
では、サブゴール `nrev' (モジュール名 `main' )は、親ゴールの
`main:main' と同じモジュール名なので、モジュール名は表示されません。

最後には、括弧の中にコンマ（,）で区切られた引数リストが続きます。nrev
 の第 2 引数と print の引数は `_4' です。これは、ソース・プログラム中
 の `X' と対応する変数に相当します。変数は、述語節の適用ごとに新しく割
 り当てられ、また、2 つ以上の変数は単一化できるので、ソース・プログラ
 ム中のオリジナルな名前を表示することは意味がありません。このような理
 由で、`_4' のような一意な名前が与えられています。

実際、この番号 `4' は、変数の物理メモリ・アドレスと関連します。そのた
め、この番号は、ガーベージ・コレクションによって変更されます。しかし、
ガーベージ・コレクションは、それほど頻繁には行われないので、アドレス情
報は、デバッグでは有効です。

トレースは、すべてのサブゴールと疑問符（?）を表示したあと、停止します。
ここで、次に示すトレース・コマンドを入力できます。



File: KLICj.info, Node: Controlling Trace, Next: Spying, Prev: Output of Tracer, Up: Tracing

トレース制御コマンド
--------------------

トレースは、 *leashed* された各ポートで制御します(*Note トレース・ポー
トの制御: Port Control.)。トレースは、トレース対象のゴール全体や、リダ
クション・ポートにおいて新しく生成された各サブゴールを制御します。各述
語ごとに、ゴールをトレースするか否かのデフォルト値を設定することもでき
ます。

* Menu:

* Goal Control::                トレース対象ゴールのトレース制御
* Subgoal Control::             新しく生成されたサブゴールのトレース制御
* Predicate Control::           述語毎のトレース・スイッチのデフォルト値の変更



File: KLICj.info, Node: Goal Control, Next: Subgoal Control, Prev: Controlling Trace, Up: Controlling Trace

トレース対象ゴールのトレース制御
................................

以下に示すコマンドは、プログラムの実行を制御するために利用します。

Continue : `c' または単に`リターン'
     ステップ実行します。
      `-' が付いたサブゴールは、ステップ・モードでもトレースしません。

Leap : `l'
     スパイ・ポイントに達するまで、トレースしないで実行を継続します。
     詳細については、*Note スパイ: Spying。

Skip : `s'
     トレース対象のゴールとすべてのサブゴールを、トレースしないで実行
     します。スパイ・ポイントがあっても無視します。

Abort : `a'
     プログラム全体の実行を放棄します。

これらのコマンドには、引数はありません。



File: KLICj.info, Node: Subgoal Control, Next: Predicate Control, Prev: Goal Control, Up: Controlling Trace

新しく生成されたサブゴールのトレース制御
........................................

各サブゴール( `+' や `-' で表示されている)のトレースは、以下に示すコマ
ンドで変更できます。

Trace : `+' SUBGOAL_NUMBER ...
     指定したサブゴールのトレースのスイッチをオンにします。複数のサブ
     ゴール番号を指定する場合、空白で区切ります。サブゴール番号を指定
     しない場合、すべてのサブゴールがトレースされます。

No Trace : `-' SUBGOAL_NUMBER ...
     指定したサブゴールのトレースのスイッチをオフにします。複数のサブ
     ゴール番号を指定する場合、空白で区切ります。サブゴール番号を指定
     しない場合、すべてのサブゴールはトレースされません。

Toggle Trace : SUBGOAL_NUMBER ...
     指定したサブゴールのトレース・スイッチを切り替えます。トレースの
     スイッチがオンならオフに、オフならオンになります。複数のサブゴー
     ル番号を指定する場合、空白で区切ります。



File: KLICj.info, Node: Predicate Control, Prev: Subgoal Control, Up: Controlling Trace

述語ごとのトレース・スイッチのデフォルト値の変更
................................................

デフォルトでは、ゴールのすべてのサブゴールに対して、トレース・スイッチ
は、最初の reduce ポートではオン( `+' )の状態です。このデフォルトの設
定は、この項で説明するコマンドを使えば述語ごとに変更できます。変更の結
果、トレース・スイッチがオフ( `-' )となった述語は、デフォルトではトレー
スされません。

コマンドの引数 <述語> は、以下の形式のいずれかになります。

MODULE:PREDICATE/ARITY
     明示的に、1 つの述語を指定します。例えば、 `main:nrev/2' のように
     指定します。

MODULE:PREDICATE
     引数個数に関係なく、モジュール 内のすべての述語を指定します。

MODULE:
     モジュールで定義されたすべての述語を指定します。述語名と区別する
     ため、モジュール名のあとにはコロン（:）が必要です。

PREDICATE/ARITY
     与えられた名前と引数個数を持つ現在トレース対象であるゴールの述語
     と同じモジュールで定義された述語を指定します。

PREDICATE
     与えられた名前を持つ現在トレース対象であるゴールの述語と同じモジュー
     ルで定義された述語を指定します。

与えられた述語のトレース・スイッチのデフォルトを変更するコマンドを、以
下に示します。

No Trace Default: `n' `Predicate' ...
     述語のトレース・スイッチのデフォルトをオフに設定します。引数に述
     語を指定しない場合、トレース対象ゴールの述語が指定されたものと仮
     定されます。

Trace Default: `t' `Predicate' ...
     述語のトレース・スイッチのデフォルトをオンに設定します。引数に述
     語を指定しない場合、トレース対象ゴールの述語が指定されたものと仮
     定されます。



File: KLICj.info, Node: Spying, Next: Port Control, Prev: Controlling Trace, Up: Tracing

スパイ
------

特定の述語だけをデバッグ対象にすることはよくあることです。そのような場
合、その述語のポートを "スパイ・ポイント" として指定できます。leap
(`l') コマンドを使って、任意のスパイ・ポイントに達するまで、プログラム
をトレースせずに実行させることができます。詳細については、*Note トレー
ス対象ゴールのトレース制御: Goal Control。

この項で説明するコマンドは、スパイ・ポイントの設定や解除を行います。

Spy: `S' PREDICATE ...
     述語をスパイします。引数に述語が指定されない場合、トレース対象ゴー
     ルの述語をスパイします。

No Spy: `N' PREDICATE ...
     述語に設定されているスパイ・ポイントを解除します。引数に述語が指
     定されない場合、トレース対象ゴールの述語のスパイ・ポイントを解除
     します。



File: KLICj.info, Node: Port Control, Next: Display Control, Prev: Spying, Up: Tracing

トレース・ポートの制御
----------------------

4 つのトレース・ポートを使用可能状態( enabled )にしたり、使用禁止状態(
disabled )にしたりできます。使用禁止状態になったポートはトレースされま
せん。

さらに各ポートに対して、停止状態になってコマンド入力を待つか否かを指定
できます。実行を停止して、コマンドを待つポートのことを "leashed" と呼
びます。使用可能状態で leashed されていないポートの場合、トレース結果
の出力表示後すぐに continue コマンド(キャリッジ・リターン)が入力された
ように、実行が継続されます。スパイ対象の述語の場合、 unleashed なポー
トも leashed になります。

この項で説明するコマンドは、そのようなポートの属性を制御するために使用
されます。これらのコマンドでは、以下に示す方法で引数にポート名を指定し
ます。

Call:
     `c', `call'
Reduce:
     `r', `redu', `reduce'
Suspend:
     `s', `susp', `suspend'
Fail:
     `f', `fail'
All ports:
     `a', `all'

ポートを制御するコマンドを以下に示します。

Enable Port: `E' PORT ...
     指定されたポート(群)を使用可能状態にします。

Disable Port: `D' PORT ...
     指定されたポート(群)を使用禁止状態にします。

Leash Port: `L' PORT ...
     指定されたポート(群)を leashed にします。

Unleash Port: `U' PORT ...
     指定されたポート(群)を unleashed にします。



File: KLICj.info, Node: Display Control, Next: Dumping Goals, Prev: Port Control, Up: Tracing

表示を制御するコマンド
----------------------

トレース対象ゴールの完全情報が常に必要であるとは限りません。逆にそういっ
た過剰な完全情報がプログラム動作の理解を妨げる場合さえあります。そういっ
た場合のために、トレース・ポートで表示される情報量を制御するコマンドが、
提供されています。

表示量は、以下に示すオプションの組合せで制御されます。

   * 表示の深さ制限：深さ制限以下の引数構造は、次に示す省略形で表示します。

          f(a,b,c,d,e)    ==>    f(..)
          [a,b,c,d,e]     ==>    [..]

   * 表示の長さ制限：長さ制限を超えた引数リストの構造や文字列は、次に示す省略形で表示します。

          f(a,b,c,d,e)    ==>    f(a,b,c,..)
          [a,b,c,d,e]     ==>    [a,b,c,..]
          "abcde"         ==>    "abc.."

   * サブタームの表示指定 : 指定されたトレース対象ゴールの特定の部分だけを表示します。

以下に示すコマンドは、オプション制御のために使用できます。

Set Print Depth: `pd' DEPTH
     データ構造の表示の深さ制限に DEPTH を設定します。引数なしの場合、
     現在の深さ制限値で表示します。

Set Print Length: `pl' LENGTH
     データ構造の表示の長さ制限に LENGTH を設定します。引数なしの場合、
     現在の長さ制限値で表示します。

Toggle Verbose Print: `pv'
     詳細表示モードのスイッチを切り替えます。詳細表示モードでは、ゴー
     ルの実行を中断している変数を表示する際に、そのゴールも一緒に表示
     します。

Set Subterm: `^' N
Reset Subterm:`^'

     トレース対象ゴールの N 番目のサブタームを表示します。N に 0 が指
      定された場合、サブタームは 1 レベル上がります。N が省略された場
      合、サブタームの表示を解除します。リスト構造の場合、 1 は car 、
      2 は cdr を意味します。

     このコマンド実行中は、トレース対象ゴールのサブタームだけが表示さ
     れます。表示されているサブタームの前には、タームのどの部分が表示
     されているのかを示す位置情報が表示されます。以下に例を示します。

            10 CALL: foo:bar(f(a,g(..),[..]))? ^1 10 CALL: ^1
            f(a,g(b,c),[d,e])? ^2 10 CALL: ^1^2 g(b,c)? ^0 10 CALL: ^1
            f(a,g(b,c),[d,e])? ^3 10 CALL: ^1^3 [d,e]? ^2 10 CALL:
            ^1^3^2 [e]? ^ 10 CALL: foo:bar(f(a,g(..),[..]))?  REDUCE
            ポートでは、サブタームを指定していると、リダクションで生成
            されたサブゴールは、表示されません。指定した親ゴールのサブ
            タームだけが表示されます。現在の版では、ベクタ要素はサブター
            ムとして指定できません。

深さ制限と長さ制限の初期設定値は、それぞれ 3 と 7 です。詳細表示モード
のスイッチは、最初はオフに設定されています。



File: KLICj.info, Node: Dumping Goals, Next: Misc Trace Commands, Prev: Display Control, Up: Tracing

ゴールのダンプ
--------------

最後の手段として、システム中のすべてのゴールをダンプすることが望ましい
場合があります。ダンプする場合のコマンドを以下に示します。

レディ・キューのダンプ : `Q'
     レディ・キュー(ゴール・プール)中のすべてのゴールを、優先順位とと
     もに表示します。

中断(待ち状態)ゴールのダンプ : `W'
     システム中のすべての中断ゴールを、優先順位とともに表示します。



File: KLICj.info, Node: Misc Trace Commands, Next: Perpetual Suspension, Prev: Dumping Goals, Up: Tracing

その他のコマンド
----------------

ステータスの問合せ : `='
     トレーサのステータス情報を、以下のように表示します。
             port: Call Susp Redu Fail
          enabled:  +    +    +    +
          leashed:  +    +    +    +
          print terse; depth = 3; length = 7

モジュール表示 : `lm'
     現在実行しているプログラムの、すべてのモジュールを表示します。

述語表示 : `lp'
     現在実行しているプログラムの、すべての述語とデフォルトのトレース
     状態を表示します。

キュー表示 : `Q'
     レディ・キュー(ゴール・プール)の内容を表示します。

ヘルプ : `?'または`h'
     現在のポートで利用できる、すべてのコマンドとその簡略説明を表示し
     ます。



File: KLICj.info, Node: Perpetual Suspension, Prev: Misc Trace Commands, Up: Tracing

永久中断の探索
--------------

あるゴールが、他のどのゴールからも具体化されない変数の具体化を待ち続け
る場合、そのゴールは永久に先に進めなくなります。このような状態を、"永
久中断"( perpetual suspention )と呼びます。永久中断は、 KLIC のガーベー
ジ・コレクタが見つけ出すので、プログラム実行中に、ガーベージ・コレクショ
ンが発生すると、永久中断が見つけ出されることがあります。

システムは中断ゴールの数を管理しています。実行できるゴールが全くない状
態で中断ゴールが残っている場合、システムは永久中断を見つけ出すためにガー
ベージ・コレクションを試みます。

永久中断は、以下のように報告されます。

     !!! Perpetual Suspention Detected !!!
        3 PSUS: MODULE:PREDICATE(ARGS...)? 

ここでは、 FAIL ポートと同じコマンド群が利用できます。



File: KLICj.info, Node: Install, Next: Distributed KLIC, Prev: Tracing, Up: Using KLIC

インストール
============

KLIC のインストールは、比較的簡単に行えます。

ホスト依存とユーザの選択に基づくカスタマイズは、配布された構成スクリプ
トを実行させて行います。その後、 `make all' でシステム全体をコンパイル
してください。次に、 `make tests' の実行によって、システムが問題なくコ
ンパイルされたことが確認できます。続いて、 `make install' でシステムの
インストールができます。

* Menu:

* Configuration::               コンフィギュレーション
* Make All::                    KLIC システムのコンパイル
* Make Tests::                  コンパイル結果のテスト
* Make Install::                オブジェクトのインストール
* Make Distclean::              インストールディレクトリのクリーン・アップ
* Troubles::                    うまく行かない場合



File: KLICj.info, Node: Configuration, Next: Make All, Prev: Install, Up: Install

コンフィギュレーション
----------------------

KLIC のインストールで最初に行うことは、ホスト・コンピュータ・システム
と、ユーザの選択に依存した KLIC システムを構成することです。

配布物のルート・ディレクトリ(以下、 ROOT と呼びます)に進んでください。
その後、 `./Configure' コマンドで構成スクリプトを実行してください。ス
クリプトが、利用できるソフトウェア・ツールを、システムから探索して、選
択の問合せをしてきます。

一部の BSD 4.2 をベースとする Unix システムでは、この構成スクリプトの
構文の一部が、デフォルトで用意されたシェルでは実行できないことがありま
す。その場合は、新しいシェル(GNU `bash' など)を入手して、次のようにス
クリプトを実行して下さい。

     % bash Configure

KLIC システムを前に構成したことがあり、同じディレクトリで再構成を行う
場合は、前回指定した値をデフォルト値にするかどうか、問い合わせてきます。

次の(初めてシステムを構成する場合は最初の)問い合わせは、KLIC の並列版を
構成するか否かというものです。
逐次システムだけをインストールしたい場合は、 `no' と答えてください。
並列版システムの構成の詳細については、
*Note 分散 KLIC: Distributed KLIC ,
*Note 共有メモリ KLIC: Shared-Memory KLIC。

構成スクリプトは、以下の 3 個のファイルを作成します。

     `ROOT/Makefile'
     `ROOT/include/klic/config.h'
     `ROOT/config.sh'

最後のファイルは、システム再構成に備えて今回指定したオプションを保存し
ます。

構成スクリプトは、
インストール手続きで使用される並列機能(parallelism)について問い合わせてきます。
このとき、システムを負荷の軽いマルチプロセッサ・システムに
インストール中であれば、ここでゼロ以外の並列機能を指定できます。
 `make' の並列実行機能を使用しては*なりません*。



File: KLICj.info, Node: Make All, Next: Make Tests, Prev: Configuration, Up: Install

KLIC システムのコンパイル
-------------------------

システムの構成後は、 `make all' と入力して、 KL1 から C へのコンパイラ
と、実行時ライブラリを含む KLIC システム全体をコンパイルしてください。



File: KLICj.info, Node: Make Tests, Next: Make Install, Prev: Make All, Up: Install

コンパイル結果のテスト
----------------------

システム全体のコンパイルが終了した後は、コンパイルが問題なく終了したか
否かをテストすることをお勧めします。テストする場合には、提供されたルー
ト・ディレクトリ内(そのサブディレクトリ `test' ではありません)で `make
test' と入力してください。何本かの KL1 テスト・プログラムがコンパイル・
実行されて、出力結果と予想結果が比較されます。



File: KLICj.info, Node: Make Install, Next: Make Distclean, Prev: Make Tests, Up: Install

オブジェクトのインストール
--------------------------

コンパイルが終了したあと、 `make install' と入力すると、コンパイラ、ヘッ
ダ・ファイル、および実行時ライブラリが、コンフィギュレーションで指定し
たディレクトリにインストールされます(*Note コンフィギュレーション:
Configuration.)。



File: KLICj.info, Node: Make Distclean, Next: Troubles, Prev: Make Install, Up: Install

インストール・ディレクトリのクリーン・アップ
--------------------------------------------

インストールが終了したあと、 `make distclean' と入力すると、配布物中に
含まれて *いない* すべてのファイルが削除されます。

一般ユーザは、`make realclean' を試しては *なりません*。このコマンドは、
KL1 から生成された C プログラムのソース・ファイルを削除します。削除し
た C プログラムのソース・ファイルを再生成するには、既に動いている KL1
から C へのコンパイラが必要です。



File: KLICj.info, Node: Troubles, Prev: Make Distclean, Up: Install

うまく行かない場合
------------------

構成ミスのために、インストール手続きがうまく行かない場合は、コンフィギュ
レーションからやり直した方がよいでしょう(*Note コンフィギュレーション:
Configuration.)。構成スクリプトは、コンフィギュレーションのやり直しの
ために、システムをクリーン・アップするか否かを問い合わせてきます。その
ときには yes と答えてください。

Makefile に書かれる依存ルールは、`make' のいくつかのバージョンで提供さ
れる make の並列機能を使用する場合には適切ではありません。アトムとファ
ンクタのデータベースが単調に増大しているという事実に依存しているので、
それらのデータベースに依存するようには書けません。代わりに、コンパイラ・
ドライバ `klic' の並列実行機能を使用してください。使用する並列機能は、
コンフィギュレーションの段階で指定します(*Note コンフィギュレーション:
Configuration.)。

配布されたコードに問題があると思われる場合は、以下に示すアドレスまでご
報告ください。

     `klic-bugs@icot.or.jp'

その際、ホスト・システム(ハードウェアとオペレーティング・システム)と構
成(トップレベルの `Makefile' と `include/klic/config.h' ファイル)に関
する情報があると、問題分析に役立ちます。



File: KLICj.info, Node: Distributed KLIC, Next: Shared-Memory KLIC, Prev: Install, Up: Using KLIC

分散 KLIC
=========

KLIC の分散並列実装版も、配布される KLIC に含まれています。この分散実
装は PVM3.3 に基づいています。MPI 等の並列処理ライブラリや、システム固
有のプロセス間通信ライブラリに基づく実装も行われていますが、この配布版
にはまだ統合されていません。

PVM に基づいていますが、現在の版では異種構成をサポートしていません。複
数のアーキテクチャを持つプロセッサで構成されるシステムや、異なるオペレー
ティング・システムを動かすシステムでは機能しません。現時点では、異種シ
ステムをサポートする計画は全くありません。

* Menu:

* Installation of Distributed KLIC::        分散 KLIC のインストール
* Compiling Programs for Distributed KLIC:: 分散 KLIC 向けプログラムのコンパイル
* Running Programs of Distributed KLIC::    分散 KLIC のプログラム実行



File: KLICj.info, Node: Installation of Distributed KLIC, Next: Compiling Programs for Distributed KLIC, Prev: Distributed KLIC, Up: Distributed KLIC

分散 KLIC のインストール
------------------------

分散 KLIC の PVM 版をインストールする場合、まず並列版を構成するか否か
を構成スクリプトが最初に問い合わせてくるので、yes と答えてください。次
に分散 KLIC を構成するか否かを、問い合わせてくるので、これにも yes と
答えてください。そのあと、 PVM が利用できる場合は、 PVM システムのイン
ストール先のディレクトリや、使用する PVM ライブラリなどについて、問い
合わせてきます。

問合せの内容を、以下に示します。

   *  PVM システムのルート・ディレクトリ
   * システムのアーキテクチャのキーワード(例えば、 `SUNMP' など)
   * PVM ライブラリの名前(例えば、 `pvm3' など)

現在の版では、デーモンプロセスを使用しない PVM の実装には、問題があり
ます。例えば、 Solaris2 が動いている共有メモリ・マルチプロセッサの
Sparc システムの場合、ライブラリの `pvm3' が機能しません。プロセス間通
信には、共有メモリの代わりにソケットを使う `pvm3s' を使用してください。

インストール手続きの残りの部分は、分散 KLIC をインストールしない場合の
手続きと同じです。

分散処理のオプション( `-dp' )が、コンパイル時に指定されていない場合、
分散 KLIC システムは、逐次版と全く同じように動作します。



File: KLICj.info, Node: Compiling Programs for Distributed KLIC, Next: Running Programs of Distributed KLIC, Prev: Installation of Distributed KLIC, Up: Distributed KLIC

分散 KLIC 向けプログラムのコンパイル
------------------------------------

コンパイル手続きは、以下に示すオプションが利用できる他は、逐次版とほぼ
同じです。

-dp
     分散 KLIC システムを用いたコンパイルを指定します。このオプション
     の指定がない場合、コンパイルされるオブジェクト・コードは、逐次処
     理でしか動きません。



File: KLICj.info, Node: Running Programs of Distributed KLIC, Prev: Compiling Programs for Distributed KLIC, Up: Distributed KLIC

分散 KLIC のプログラム実行
--------------------------

* Menu:

* Setting Up PVM::                          PVM のセット・アップ
* Runtime Options for Distributed KLIC::    分散 KLIC の実行時オプション
* Known Bugs of Distributed KLIC::          分散 KLIC の既知のバグ



File: KLICj.info, Node: Setting Up PVM, Next: Runtime Options for Distributed KLIC, Prev: Running Programs of Distributed KLIC, Up: Running Programs of Distributed KLIC

PVM のセット・アップ
....................

分散実行用にコンパイルされたプログラムを実行する前に、 PVM システムが
システム上で稼働している必要があります。以下に示すセット・アップが必要
です。

   * 次の環境変数を設定してください。

     PVM_ROOT
          システムにインストールした PVM システムのルート・ディレクトリ

     PVM_ARCH
          システムのアーキテクチャを指定するキーワード


     これらは、分散 KLIC システムをインストールした時に指定したものと
     同じものを指定してください。

   *  PVM のデーモンを開始してください。デーモンは、 PVM コンソールを
     起動することで開始できます。PVM コンソールは、
     `$PVM_ROOT/lib/$PVM_ARCH/pvm' に存在します。このコンソール用のウィ
     ンドウがあると便利です。

他のパラメタの設定と PVM コンソールの操作の詳細については、専用のマニュ
アルをご覧ください。



File: KLICj.info, Node: Runtime Options for Distributed KLIC, Next: Known Bugs of Distributed KLIC, Prev: Setting Up PVM, Up: Running Programs of Distributed KLIC

分散 KLIC の実行時オプション
............................

分散 KLIC システムでプログラムを動かす場合、逐次版で利用できるオプショ
ンに加えて、以下のオプションが利用できます。

-p N
     プログラムを動かすための疑似プロセッサ( Unix プロセス)の数を指定
      します。klic 2.0 版ではパラメータが -dp から -p に変更になってい
      ます.

-e
     バッチ転送モードに切り替えます。通常、 KLIC は要求時にプロセッサ
     間でデータ構造を転送します。ネストしたデータ構造は通常、1 度に 1
     レベルずつ転送します。バッチ転送では、ネストしたデータ構造を 1 度
     に転送します。これは、いくつかのプログラムに対して、より効率的に
     実行します。しかし、他のプログラムの性能を劣化させることもありま
     す。

-E LEVEL
     ネストしたデータ構造について、何レベルまで一度に送信するかを指定
     します。

-I MICROSEC
     プロセッサ間通信のポーリング間隔を指定します。このポーリングが必
     要かどうか、またどのような値が適切であるかは、ホストシステムと物
     理通信層の実装に依存します。多くの場合は、デフォルト値である
     10000 が適切です。

-n
     実行時の統計情報を表示します。

-notimer
     タイマ駆動の通信ポーリングを行いません。このポーリングが必須かど
     うかは、物理通信層の実装に依存します。

-relsp
     疑似プロセッサプロセスを生成する時の実行ファイルを、相対パスで探
     します。

-S
     通信パケットの受信側プロセスに対し、シグナル送信による通知を行い
     ません。実装によっては、この指定によりシグナル送信のオーバヘッド
     が減るため、実行速度が向上する場合があります。



File: KLICj.info, Node: Known Bugs of Distributed KLIC, Prev: Runtime Options for Distributed KLIC, Up: Running Programs of Distributed KLIC

分散 KLIC の既知のバグ
......................

   * 新しく登録されたアトムとファンクタは、プログラムの実行中に、正常
     に処理されないことがあります。

   * スパイの指定(*Note スパイ: Spying.)は、指定した計算ノードの内部だ
     けに効果があります。



File: KLICj.info, Node: Shared-Memory KLIC, Prev: Distributed KLIC, Up: Using KLIC

共有メモリ KLIC
===============

KLIC の共有メモリ並列実装版も、配布される KLIC に含まれています。この
実装は、ハードウェア、 OS 、 C コンパイラの各々に依存する部分から成り
ます。このバージョンでは、SunOS 5.3 が動作している Sparc ベースのシス
テム、および DEC OSF/1 が動作している Alpha ベースのシステムに対応して
います。コンパイルには、 Gnu CC が必要です。

* Menu:

* Installation of Shared-Memory KLIC::          共有メモリ KLIC のインストール
* Compiling Programs for Shared-Memory KLIC::   共有メモリ KLIC 向けプログラムのコンパイル
* Running Programs of Shared-Memory KLIC::      共有メモリ KLIC のプログラム実行



File: KLICj.info, Node: Installation of Shared-Memory KLIC, Next: Compiling Programs for Shared-Memory KLIC, Prev: Shared-Memory KLIC, Up: Shared-Memory KLIC

共有メモリ KLIC のインストール
------------------------------

共有メモリ版の KLIC をインストールする場合、まず共有メモリ KLIC を構成
するか否かを問い合わせてくるので、yes と答えてください

インストール手続きの残りの部分は、共有メモリ KLIC をインストールしない
場合の手続きと同じです。

共有メモリ並列処理のオプション( `-shm' )が、コンパイル時に指定されてい
ない場合、共有メモリ KLIC システムは、逐次版と全く同じように動作します。



File: KLICj.info, Node: Compiling Programs for Shared-Memory KLIC, Next: Running Programs of Shared-Memory KLIC, Prev: Installation of Shared-Memory KLIC, Up: Shared-Memory KLIC

共有メモリ KLIC 向けプログラムのコンパイル
------------------------------------------

コンパイル手続きは、以下に示すオプションが利用できる他は、逐次版とほぼ
同じです。

-shm
     共有メモリ KLIC システムを用いたコンパイルを指定します。このオプ
     ションの指定がない場合、コンパイルされるオブジェクト・コードは、
     逐次処理でしか動きません。



File: KLICj.info, Node: Running Programs of Shared-Memory KLIC, Prev: Compiling Programs for Shared-Memory KLIC, Up: Shared-Memory KLIC

共有メモリ KLIC のプログラム実行
--------------------------------

* Menu:

* Runtime Options for Shared-Memory KLIC::  共有メモリ KLIC の実行時オプション
* Known Bugs of Shared-Memory KLIC::        共有メモリ KLIC の既知のバグ



File: KLICj.info, Node: Runtime Options for Shared-Memory KLIC, Next: Known Bugs of Shared-Memory KLIC, Prev: Running Programs of Shared-Memory KLIC, Up: Running Programs of Shared-Memory KLIC

共有メモリ KLIC の実行時オプション
..................................

共有メモリ KLIC システムでプログラムを動かす場合、逐次版で利用できるオ
プションに加えて、以下のオプションが利用できます。

-p N
     プログラムを動かすための疑似プロセッサ( Unix プロセス)の数を指定
     します。

-D
     子である疑似プロセッサのプロセス番号を報告します。低レベルのデバッ
     グで便利かもしれません。

-S SIZE
     共有ヒープ領域の大きさを指定します。現在の実装では、共有ヒープ領
     域は初期化の際に確保され、以後拡張されることはありません。



File: KLICj.info, Node: Known Bugs of Shared-Memory KLIC, Prev: Runtime Options for Shared-Memory KLIC, Up: Running Programs of Shared-Memory KLIC

共有メモリ KLIC の既知のバグ
............................

   * トレーサが正しく動かないことがあります。



File: KLICj.info, Node: Type Index, Next: Predicate Index, Prev: Using KLIC, Up: Top

データ型索引
************

* Menu:

* 浮動小数点数[ふどうしょうすうてんすう]: Floating Points.  (line   5)
* ファンクタ[ふぁんくた]:       Functors.               (line   5)
* 整数[せいすう]:               Integers.               (line   5)
* リスト[りすと]:               Lists.                  (line   5)
* マージャ[まーじゃ]:           Merging.                (line  59)
* モジュール[もじゅーる]:       Module Type.            (line   5)
* 述語[じゅつご]:               Predicate Type.         (line   5)
* 文字列[もじれつ]:             Strings.                (line   5)
* アトム[あとむ]:               Symbolic Atoms.         (line   5)
* ベクタ[べくた]:               Vectors.                (line   5)



File: KLICj.info, Node: Predicate Index, Next: Module Index, Prev: Type Index, Up: Top

述語、メソッド、メッセージ名索引
********************************

* Menu:

* NUMBER on C 風の I/O :        Output Msgs (C style).  (line  12)
* NUMBER on Prolog 風の I/O :   Output Msgs (Prolog style).  (line  30)
* accept on バウンド・ソケット: Sockets.                (line  35)
* access on unix ストリーム:    Files & Dirs.           (line  28)
* acos on float:                Floating Arith.         (line  69)
* add on float:                 Floating Arith.         (line  60)
* add on timer:                 Timer.                  (line  35)
* addop on Prolog 風の I/O :    Common Msgs (Prolog style).  (line  19)
* append_open on klicio ストリーム: Opening Prolog I/O.  (line  26)
* append_open on unix ストリーム: I/O Opening.          (line  30)
* apply on predicate:           Predicate Type.         (line  45)
* arg on builtin:               Functor Operation.      (line  28)
* arg on builtin:               Functor Operation.      (line  29)
* argc on predicate:            Predicate Interface.    (line  11)
* argv on unix:                 Predicate Interface.    (line  16)
* arity on predicate:           Predicate Type.         (line  41)
* arity on predicate:           Predicate Type.         (line  42)
* asin on float:                Floating Arith.         (line  68)
* atan on float:                Floating Arith.         (line  70)
* atom_number on atom_table:    Symbolic Atom Operation.  (line  22)
* atom on builtin:              Symbolic Atom Operation.  (line  10)
* atomic on builtin:            Atomic Data.            (line  19)
* bind on unix ストリーム:      Sockets.                (line  24)
* call on predicate:            Predicate Type.         (line  51)
* cd on unix ストリーム:        Files & Dirs.           (line  11)
* ceil on float:                Floating Arith.         (line  77)
* chmod on unix ストリーム:     Files & Dirs.           (line  43)
* compare on builtin:           Comparison and Hashing.  (line   7)
* compare on timer:             Timer.                  (line  39)
* connect on unix ストリーム:   Sockets.                (line  12)
* cos on float:                 Floating Arith.         (line  66)
* cosn on float:                Floating Arith.         (line  72)
* current_node on builtin:      Execution Status.       (line  12)
* current_priority on builtin:  Execution Status.       (line   8)
* divide on float:              Floating Arith.         (line  63)
* element on string:            Predicates and Methods.  (line  18)
* element on string:            Predicates on Strings.  (line  20)
* element on string:            Predicates on Strings.  (line  21)
* element on vector:            Predicates on Vectors.  (line  14)
* element on vector:            Predicates on Vectors.  (line  15)
* element_size on string:       Predicates on Strings.  (line  17)
* equal on float:               Floating Comp.          (line  35)
* exit on unix:                 Predicate Interface.    (line  20)
* exp on float:                 Floating Arith.         (line  74)
* fclose on C 風の I/O :        Common Msgs (C style).  (line  34)
* fclose on Prolog 風の I/O :   Common Msgs (Prolog style).  (line  14)
* feof on C 風の I/O :          Common Msgs (C style).  (line  11)
* feof on Prolog 風の I/O :     Common Msgs (Prolog style).  (line  11)
* fflush on C 風の I/O :        Output Msgs (C style).  (line  28)
* fflush on Prolog 風の I/O :   Output Msgs (Prolog style).  (line  33)
* float on builtin:             Floating Points.        (line  13)
* float on float:               Floating Points.        (line  12)
* floor on float:               Floating Arith.         (line  78)
* fork on unix ストリーム:      Misc Unix Messages.     (line  29)
* fork_with_pipes on unix ストリーム: Misc Unix Messages.  (line  35)
* fread on C 風の I/O :         Input Msgs (C style).   (line  16)
* fread on Prolog 風の I/O :    Input Msgs (Prolog style).  (line  30)
* fseek on C 風の I/O :         Common Msgs (C style).  (line  16)
* fseek on Prolog 風の I/O :    Common Msgs (Prolog style).  (line  12)
* ftell on C 風の I/O :         Common Msgs (C style).  (line  27)
* ftell on Prolog 風の I/O :    Common Msgs (Prolog style).  (line  13)
* functor on builtin:           Functor Operation.      (line  15)
* functor on builtin:           Functor Operation.      (line  16)
* fwrite on C 風の I/O :        Output Msgs (C style).  (line  16)
* fwrite on C 風の I/O :        Output Msgs (C style).  (line  21)
* fwrite on Prolog 風の I/O :   Output Msgs (Prolog style).  (line  31)
* fwrite on Prolog 風の I/O :   Output Msgs (Prolog style).  (line  32)
* gc on system_control:         System Control.         (line  23)
* get_atom_name on atom_table:  Symbolic Atom Operation.  (line  32)
* get_atom_string on atom_table: Symbolic Atom Operation.  (line  25)
* get_time_of_day on timer:     Timer.                  (line  22)
* getc on C 風の I/O :          Input Msgs (C style).   (line   9)
* getc on Prolog 風の I/O :     Input Msgs (Prolog style).  (line  28)
* getenv on unix ストリーム:    Misc Unix Messages.     (line  15)
* gett on Prolog 風の I/O :     Input Msgs (Prolog style).  (line   8)
* getwt on Prolog 風の I/O :    Input Msgs (Prolog style).  (line  14)
* greater_than on float:        Floating Comp.          (line  34)
* hash on builtin:              Comparison and Hashing.  (line  61)
* instantiate_after on timer:   Timer.                  (line  47)
* instantiate_at on timer:      Timer.                  (line  46)
* instantiate_every on timer:   Timer.                  (line  56)
* integer on builtin:           Integers.               (line  12)
* intern on atom_table:         Symbolic Atom Operation.  (line  28)
* join on string:               Predicates on Strings.  (line  52)
* join on vector:               Predicates on Vectors.  (line  41)
* kill on unix ストリーム:      Misc Unix Messages.     (line  26)
* klicio on predicate:          Opening Prolog I/O.     (line   8)
* less_than on float:           Floating Comp.          (line  31)
* less_than on string:          Predicates on Strings.  (line  27)
* linecount on C 風の I/O :     Input Msgs (C style).   (line  24)
* linecount on Prolog 風の I/O : Input Msgs (Prolog style).  (line  31)
* list on builtin:              Lists.                  (line  20)
* log on float:                 Floating Arith.         (line  75)
* make_atom on atom_table:      Symbolic Atom Operation.  (line  18)
* mktemp on unix ストリーム:    Files & Dirs.           (line  21)
* module on module:             Module Type.            (line  17)
* module on predicate:          Predicate Type.         (line  56)
* multiply on float:            Floating Arith.         (line  62)
* name on module:               Module Type.            (line  20)
* name on predicate:            Predicate Type.         (line  59)
* new_functor on builtin:       Functor Operation.      (line  35)
* new on オブジェクト生成:      Creating Floats.        (line  11)
* new on merge:                 Merging.                (line  59)
* new on module:                Module Type.            (line  11)
* new on predicate:             Predicate Type.         (line  31)
* new on random_numbers:        Random Numbers.         (line  12)
* new on random_numbers:        Random Numbers.         (line  13)
* new on string:                Creating Strings.       (line  11)
* new on vector:                Creating Vectors.       (line  11)
* new_string on builtin:        Creating Strings.       (line  12)
* new_vector on builtin:        Creating Vectors.       (line  12)
* nl on Prolog 風の I/O :       Output Msgs (Prolog style).  (line  46)
* not_equal on float:           Floating Comp.          (line  36)
* not_greater_than on float:    Floating Comp.          (line  32)
* not_less_than on float:       Floating Comp.          (line  33)
* not_less_than on string:      Predicates on Strings.  (line  31)
* =.. on 述語:                  Functor Operation.      (line  47)
* @< on builtin:                Comparison and Hashing.  (line  41)
* @=< on builtin:               Comparison and Hashing.  (line  42)
* @>= on builtin:               Comparison and Hashing.  (line  43)
* @> on builtin:                Comparison and Hashing.  (line  44)
* \= on builtin:                Comparison and Hashing.  (line  48)
* $:= on builtin:               Floating Arith.         (line   8)
* $> on builtin:                Floating Comp.          (line  13)
* $>= on builtin:               Floating Comp.          (line  14)
* $=:= on builtin:              Floating Comp.          (line  15)
* $=\= on builtin:              Floating Comp.          (line  16)
* $=< on builtin:               Floating Comp.          (line  17)
* $< on builtin:                Floating Comp.          (line  18)
* := on builtin:                Integer Arith.          (line   8)
* := on builtin:                Integer Arith.          (line   9)
* > on builtin:                 Integer Comp.           (line  13)
* >= on builtin:                Integer Comp.           (line  14)
* =:= on builtin:               Integer Comp.           (line  15)
* =\= on builtin:               Integer Comp.           (line  16)
* =< on builtin:                Integer Comp.           (line  17)
* < on builtin:                 Integer Comp.           (line  18)
* = on builtin:                 Unification.            (line  11)
* = on builtin:                 Unification.            (line   7)
* postmortem on system_control: System Control.         (line  10)
* pow on float:                 Floating Arith.         (line  64)
* predicate on predicate:       Predicate Type.         (line  38)
* putc on C 風の I/O :          Output Msgs (C style).  (line   9)
* putc on C 風の入出力:         Messages.               (line  20)
* putc on Prolog 風の I/O :     Output Msgs (Prolog style).  (line  29)
* putenv on unix ストリーム:    Misc Unix Messages.     (line  20)
* putt on Prolog 風の I/O :     Output Msgs (Prolog style).  (line   8)
* puttq on Prolog 風の I/O :    Output Msgs (Prolog style).  (line   9)
* putwt on Prolog 風の I/O :    Output Msgs (Prolog style).  (line  10)
* putwtq on Prolog 風の I/O :   Output Msgs (Prolog style).  (line  11)
* read_open on klicio ストリーム: Opening Prolog I/O.   (line  24)
* read_open on unix ストリーム: I/O Opening.            (line  28)
* rmop on Prolog 風の I/O :     Common Msgs (Prolog style).  (line  22)
* search_character on builtin:  Predicates on Strings.  (line  56)
* search_character on string:   Predicates on Strings.  (line  55)
* set_element on string:        Predicates on Strings.  (line  39)
* set_element on vector:        Predicates on Vectors.  (line  21)
* set_element on vector:        Predicates on Vectors.  (line  27)
* set_string_element on builtin: Predicates on Strings.  (line  40)
* set_vector_element on builtin: Predicates on Vectors.  (line  22)
* set_vector_element on builtin: Predicates on Vectors.  (line  28)
* setarg on builtin:            Functor Operation.      (line  40)
* setarg on builtin:            Functor Operation.      (line  41)
* signal_stream on unix ストリーム: Signals.            (line  10)
* sin on float:                 Floating Arith.         (line  65)
* sinh on float:                Floating Arith.         (line  71)
* size on string:               Predicates on Strings.  (line  14)
* size on vector:               Predicates on Vectors.  (line   9)
* split on string:              Predicates on Strings.  (line  46)
* split on vector:              Predicates on Vectors.  (line  35)
* sqrt on float:                Floating Arith.         (line  76)
* stderr on klicio ストリーム:  Opening Prolog I/O.     (line  23)
* stderr on unix ストリーム:    I/O Opening.            (line  22)
* stdin on klicio ストリーム:   Opening Prolog I/O.     (line  21)
* stdin on unix ストリーム:     I/O Opening.            (line  20)
* stdout on klicio ストリーム:  Opening Prolog I/O.     (line  22)
* stdout on unix ストリーム:    I/O Opening.            (line  21)
* string_element on builtin:    Predicates and Methods.  (line  17)
* string_element on builtin:    Predicates on Strings.  (line  22)
* string_element on builtin:    Predicates on Strings.  (line  23)
* string_less_than on builtin:  Predicates on Strings.  (line  28)
* string_not_less_than on builtin: Predicates on Strings.  (line  32)
* string on builtin:            Predicates on Strings.  (line  10)
* string on builtin:            Predicates on Strings.  (line  36)
* string on string:             Predicates on Strings.  (line  35)
* string on string:             Predicates on Strings.  (line   8)
* string on string:             Predicates on Strings.  (line   9)
* sub on timer:                 Timer.                  (line  36)
* subtract on float:            Floating Arith.         (line  61)
* sync on C 風の I/O :          Common Msgs (C style).  (line  39)
* sync on Prolog 風の I/O :     Common Msgs (Prolog style).  (line  15)
* system on unix ストリーム:    Misc Unix Messages.     (line  10)
* tan on float:                 Floating Arith.         (line  67)
* tanh on float:                Floating Arith.         (line  73)
* times on unix:                Predicate Interface.    (line  23)
* umask on unix ストリーム:     Files & Dirs.           (line  49)
* umask on unix ストリーム:     Files & Dirs.           (line  50)
* unbound on builtin:           Debugging.              (line   8)
* ungetc on C 風の I/O :        Input Msgs (C style).   (line  13)
* ungetc on Prolog 風の I/O :   Input Msgs (Prolog style).  (line  29)
* unix on unix:                 Unix Stream.            (line  11)
* unlink on unix ストリーム:    Files & Dirs.           (line  16)
* unwrap on 変換:               Wrapped Terms.          (line  45)
* update_open on klicio ストリーム: Opening Prolog I/O.  (line  27)
* update_open on unix ストリーム: I/O Opening.          (line  31)
* vector_element on builtin:    Predicates on Vectors.  (line  16)
* vector_element on builtin:    Predicates on Vectors.  (line  17)
* vector on builtin:            Predicates on Vectors.  (line  10)
* vector on vector:             Predicates on Vectors.  (line   8)
* wait on builtin:              Synchronization.        (line   7)
* wrap on variable:             Wrapped Terms.          (line  55)
* write_open on klicio ストリーム: Opening Prolog I/O.  (line  25)
* write_open on unix ストリーム: I/O Opening.           (line  29)

@node Module Index, Concepts, Predicate Index, Top
@unnumbered モジュール名索引
@printindex pg
@comment % CIJ @printindex pg

@node Concepts,  , Module Index, Top
@unnumbered 索引
@printindex cp
@comment % CIJ @printindex cp

@contents

