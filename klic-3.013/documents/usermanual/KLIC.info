This is KLIC.info, produced by makeinfo version 6.5 from klic.tex.

This file documents KLIC, a portable implementation of KL1.  The
contents of this manual correspond to KLIC version 3.002.

   Copyright 1994, 1995 Institute for New Generation Computer
Technology\\ (Read COPYRIGHT for detailed information.)\\ (C)1996, 1997,
1998, 1999 Japan Information Processing Development Center\\ (Read
COPYRIGHT-JIPDEC for detailed information.)


File: KLIC.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

KLIC
****

KLIC is a portable implementation of KL1.  KL1 is a concurrent logic
programming language based on Guarded Horn Clauses (GHC, in short).  KL1
has very simple and concise syntax and semantics and yet provides very
powerful features for concurrent computation.

* Menu:

* Copying::                     Copyright notices
* Introduction::                How to read this manual
* Language::                    Features of KLIC KL1 language
* Builtin and Library::         Builtin and library features
* Using KLIC::                  How to use the KLIC system
* Type Index::                  Index of data types
* Predicate Index::             Index of predicates, methods and messages
* Module Index::                Index of program modules
* Concepts::                    Index of various concepts

 -- The Detailed Node Listing --

Introduction

* Description::                 Description of predicates &c
* Reporting Bugs::              Reporting system problems

Description of Predicates and Methods

* Predicates and Methods::      Two forms of procedures
* Messages::                    Messages to processes
* Argument Modes::              Input/output modes of arguments

KL1 Language

* Basics::                      Basic execution mechanism of the language
* Predicates::                  Predicates correspond to subroutines
* Modules::                     Module is a set of predicates
* Goals::                       Goals are units of execution of KL1
* Initial Goal::                How program execution starts
* Generic Objects::             Generic objects extends features of KLIC
* Priority::                    Specifying scheduling preference
* Alternatively::               Preference among clauses
* Argument Pair Notation::
* Inline C Code::               Inserting C code inline

Generic Objects

* Creating Objects::            How to create generic objects
* Guard Methods::               Operations on data objects in guards
* Body Methods::                Operations on data objects in bodies

Shorthand Notation for Argument Pairs

* Paired Arguments::
* Macros for Paired Arguments::
* Usage of Paired Arguments::

Inserting C Language Code Inline

* Top Insertion::               Inserting C program text at the top
* Guard Insertion::             Inserting C program text in guards
* C-Level Rep::                 C-level representation of KL1 terms
* Examples of Inline::          Some examples of inline C code
* Hints of Inline::             Some hints on using inline C code

Builtin and Library Features

* Common Operations::           Operations common to all the data types
* Atomic Data::                 Atomic data and their operation
* Structured Data::             Structured data and their operation
* Executable Code::             Higher order manipulation of executable code
* Unix::                        Interfacing with the operating system
* Input and Output::            Input and output from and to files &c
* System Control::              Controlling system behavior
* Timer::                       Timing and interval timer
* Random Numbers::              Random number generator

Common Operations

* Unification::                 Unifying two terms
* Synchronization::             Waiting for data availability
* Comparison and Hashing::      Comparing and hashing terms
* Execution Status::            Knowing about execution status
* Debugging::                   Debugging support

Atomic Data

* Symbolic Atoms::              Symbolic atoms give names to various concepts
* Integers::                    Integer data and their operations
* Floating Points::             Floating point data and their operations

Symbolic Atoms

* Notation of Atoms::           Notation of symbolic atoms
* Symbolic Atom Operation::     Operations on symbolic atoms

Integer Atoms

* Notation of Integers::        Notation of integers
* Integer Arith::               Integer arithmetics
* Integer Comp::                Integer comparison

Floating Point Numbers

* Notation of Floats::          Notation of floating point numbers
* Creating Floats::
* Floating Arith::              Floating point arithmetics
* Floating Comp::               Floating comparison

Structured Data

* Functors::                    Named data structures
* Lists::                       Linear list of elements
* Vectors::                     One-dimensional arrays of any data
* Strings::                     Array of small integers such as character codes

Functor Structures

* Notation of Functors::        Notation of functors
* Functor Operation::           Operation on fucntor structures

Lists

* Notation of Lists::           Notation of Lists
* Merging::                     Merging messages from multiple streams

Vectors

* Notation of Vectors::         Constant notation of vectors
* Creating Vectors::            Creating new vectors
* Predicates on Vectors::       Vector manipulation predicates

Strings

* Notation of Strings::         Constant notation of strings
* Creating Strings::            Creating new strings
* Predicates on Strings::       String manipulation predicates

Handling Program Code as Data

* Module Type::                 Program modules as data
* Predicate Type::              Predicates as data

Unix Interface

* Unix Stream::                 Obtaining Unix interface stream
* I/O Opening::                 Opening input/output streams
* Sockets::                     Internet- and Unix-domain protocol sockets
* Files & Dirs::                Manipulation of files and directories
* Signals::                     Signal interrupt handling
* Misc Unix Messages::          Miscellaneous messages to the Unix stream
* Predicate Interface::         Predicate interface for command line args &c

Input and Output

* C-like I/O::                  I/O with C language-like interface
* Prolog I/O::                  I/O with Prolog language-like interface

Input and Output with C-like Interface

* Common Msgs (C style)::       Messages common to both input and output
* Input Msgs (C style)::        Messages for C-like input streams
* Output Msgs (C style)::       Messages for C-like output streams

Input and Output with Prolog-like Interface

* Opening Prolog I/O::          Opening Prolog-like I/O streams
* Common Msgs (Prolog style)::  Message common to input and output streams
* Input Msgs (Prolog style)::   Input messages with Prolog-like interface
* Output Msgs (Prolog style)::  Output messages with Prolog-like interface
* Wrapped Terms::               Manipulation of wrapped terms

Using KLIC

* Compiling::                   How to compile KL1 programs
* Running::                     How to run programs compiled with KLIC
* Tracing::                     Tracing execution for debugging
* Install::                     Installation of KLIC
* Distributed KLIC::            Distributed memory parallel implementation
* Shared-Memory KLIC::          Shared-memory parallel implementation

Compiling Programs with KLIC

* Command for Compilation::     Program compilation command
* Compiler Options::            Compiler options
* Mechanism of Compilation::    How programs are compiled

Running Programs Compiled with KLIC

* Runtime Switches::            Runtime command line switches

Tracing Program Execution

* Preparing for Trace::         Compiling your program to be traced
* Trace Ports::                 Places you stop at stepping execution
* Output of Tracer::            How your program execution process is displayed
* Controlling Trace::           Controlling which are traced and which are not
* Spying::                      Setting spypoints = break points
* Port Control::                Enabling and disabling tracing of each port
* Display Control::             Controlling the verbosity of trace display
* Dumping Goals::               Displaying all ready or suspended goals
* Misc Trace Commands::         Miscellaneous commands
* Perpetual Suspension::        Detecting goals that can never proceed

Trace Controlling Commands

* Goal Control::                Controlling trace of the traced goal
* Subgoal Control::             Controlling trace of newly created subgoals
* Predicate Control::           Changing default trace of predicates

Installation

* Configuration::               Configuration script
* Make All::                    Compiling the system
* Make Tests::                  Testing the compilation
* Make Install::                Actually installing the system
* Make Distclean::              Cleaning up after installation
* Troubles::                    What to do when you have some trouble

Distributed Memory Parallel Implementation of KLIC

* Installation of Distributed KLIC::
* Compiling Programs for Distributed KLIC::
* Running Programs of Distributed KLIC::

Running Programs of Distributed KLIC

* Setting Up PVM::
* Runtime Options for Distributed KLIC::
* Known Bugs of Distributed KLIC::

Shared-Memory Implementation of KLIC

* Installation of Shared-Memory KLIC::
* Compiling Programs for Shared-Memory KLIC::
* Running Programs of Shared-Memory KLIC::

Running Programs of Shared-Memory KLIC

* Runtime Options for Shared-Memory KLIC::
* Known Bugs of Shared-Memory KLIC::


File: KLIC.info,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

Terms and Conditions for Use of ICOT Free Software
**************************************************

*1.  Purposes and Background of ICOT Free Software.*

   The Institute for New Generation Computer Technology ("ICOT") had
been promoting the Fifth Generation Computer Systems project under the
commitment of the Ministry of International Trade and Industry of Japan
(the "MITI"). Since April 1993, ICOT has been promoting the Follow-on
project to the FGCS project.  This follow-on project aims to disseminate
and further develop FGCS technology.  The FGCS project and the Follow-on
project (collectively, the "Project") have been aimed at creating basic
technology for novel computers that realizes parallel inference
processing as their core mechanism, and contributing toward the progress
of computer science by sharing innovative knowledge and technology with
the research community worldwide.

   Innovative hardware and software parallel inference technology has
been under development through the Project, which involves varieties of
advanced software for experiments and evaluation.  This software, being
at a basic stage of research and development, should be disseminated
widely to the research community.

   According to the aims of the Project, ICOT has made this software,
the copyright of which does not belong to the government but to ICOT
itself, available to the public in order to contribute to the world,
and, moreover, has removed all restrictions on its usage that may have
impeded further research and development in order that large number of
researchers can use it freely to begin a new era of computer science.

   This program together with any attached documentation (collectively,
the "Program") is being distributed by ICOT free of charge as "ICOT Free
Software".

*2.  Free Use, Modification, Copying and Distribution*

   Persons wanting to use the Program ("Users") may freely do so and may
also freely modify and copy the Program.  The term "modify," as used
here, includes, but is not limited to, any act to improve or expand the
Program for the purposes of enhancing and/or improving its function,
performance and/or quality as well as to add one or more programs or
documents developed by Users of the Program.

   Each User may also freely distribute the Program, whether in its
original form or modified, to any third party or parties, *PROVIDED*
that the provisions of Section 3 (*NO WARRANTY*) will *ALWAYS* appear
on, or be attached to, the Program, which is distributed substantially
in the same form as set out herein and that such intended distribution,
if actually made, will neither violate or otherwise contravene any of
the laws and regulations of the countries having jurisdiction over the
User or the intended distribution itself.

*3.  NO WARRANTY*

   The program was produced on an experimental basis in the course of
the research and development conducted during the project and is
provided to users as so produced on an experimental basis.  Accordingly,
the program is provided without any warranty whatsoever, whether
express, implied, statutory or otherwise.  The term "warranty" used
herein includes, but is not limited to, any warranty of the quality,
performance, merchantability and fitness for a particular purpose of the
program and the nonexistence of any infringement or violation of any
right of any third party.

   Each user of the program will agree and understand, and be deemed to
have agreed and understood, that there is no warranty whatsoever for the
program and, accordingly, the entire risk arising from or otherwise
connected with the program is assumed by the user.

   Therefore, neither ICOT, the copyright holder, or any other
organization that participated in or was otherwise related to the
development of the program and their respective officials, directors,
officers and other employees shall be held liable for any and all
damages, including, without limitation, general, special, incidental and
consequential damages, arising out of or otherwise in connection with
the use or inability to use the program or any product, material or
result produced or otherwise obtained by using the program, regardless
of whether they have been advised of, or otherwise had knowledge of, the
possibility of such damages at any time during the project or
thereafter.  Each user will be deemed to have agreed to the foregoing by
his or her commencement of use of the program.  The term "use" as used
herein includes, but is not limited to, the use, modification, copying
and distribution of the program and the production of secondary products
from the program.

   In the case where the program, whether in its original form or
modified, was distributed or delivered to or received by a user from any
person, organization or entity other than ICOT, unless it makes or
grants independently of ICOT any specific warranty to the user in
writing, such person, organization or entity, will also be exempted from
and not be held liable to the user for any such damages as noted above
as far as the program is concerned.


File: KLIC.info,  Node: Introduction,  Next: Language,  Prev: Copying,  Up: Top

1 Introduction
**************

This manual describes a portable implementation of KL1 called KLIC,
developed at Institute for New Generation Computer Technology as a part
of the Fifth Generation Computer national project of Japan and its
follow-on project.

   KL1 is a concurrent logic programming language based on Guarded Horn
Clauses (GHC, in short).  KL1 has very simple and concise syntax and
semantics and yet provides very powerful features for concurrent
computation.

   KLIC compiles KL1 programs to C programs.  A C compiler of the host
system then compiles the C programs to relocatable objects, which will
then be linked together with the runtime library of KLIC (*note How KLIC
Compiler Works: Mechanism of Compilation.).  Thus, the system is
independent from the hardware architecture of the host system.  Also,
the system is written so that only minimal features of Unix are used to
assure portability.

* Menu:

* Description::                 Description of predicates &c
* Reporting Bugs::              Reporting system problems


File: KLIC.info,  Node: Description,  Next: Reporting Bugs,  Prev: Introduction,  Up: Introduction

1.1 Description of Predicates and Methods
=========================================

* Menu:

* Predicates and Methods::      Two forms of procedures
* Messages::                    Messages to processes
* Argument Modes::              Input/output modes of arguments


File: KLIC.info,  Node: Predicates and Methods,  Next: Messages,  Prev: Description,  Up: Description

1.1.1 Predicates and Methods
----------------------------

Unlike other logic programming language systems, KLIC provides two kinds
of procedures, predicates and generic methods.  Predicates define
relations on their arguments and their semantics is fixed.  Generic
methods, (or methods, simply) are defined by _objects_ they are applied
to.  Thus, their semantics depends on the object applied.

   Sometimes the same operation is provided by both predicates and
methods.  For example, obtaining an element of a string can be done by
either of the following two.

 -- Body Predicate on builtin: string_element +String +Index -Element
 -- Body Method on string: element +String +Index -Element

The former is a builtin predicate of the system.  Predicate invocations
are written as follows.

     MODULENAME:PREDICATENAME(ARGUMENTS, ...)

In case of the predicate 'string_element' mentioned above, it is defined
as a builtin predicate and thus no module name is needed in its
invocation.  Thus, an invocation is written as follows.

     string_element(STRING, INDEX, ELEMENT)

In general, a module name may come first with a colon before the
predicate name.  Some predicates do not have any arguments.  In such
cases, parentheses enclosing arguments are also omitted.

   The latter is a generic method defined on the objects of class
'string'.  Method invocation is written as follows.

     generic:METHODNAME(OBJECT, OTHERARGUMENTS, ...)

In case of the method 'element' mentioned above, its invocation is
written as follows.

     generic:element(STRING, INDEX, ELEMENT)

   The same operation may be effected using either a predicate or a
method.  For example, obtaining the third element (element number 2) of
a string S into E can be done by either of the following invocations.

     string_element(S, 2, E)
     generic:element(S, 2, E)

Note that, while the predicate 'string_element' is only for obtaining an
element of a string, a generic method invocation can also be used to
obtain an element of _similar_ object.  For example, an element of a
vector (one-dimensional array) can also be obtained by the same
invocation.


File: KLIC.info,  Node: Messages,  Next: Argument Modes,  Prev: Predicates and Methods,  Up: Description

1.1.2 Messages
--------------

KL1 programs often consist of many _processes_.  Processes often
communicate one another using _streams_.  Streams are actually lists of
_messages_.  Lists are made of cells called _cons_ cells with two fields
_car_ and _cdr_, just as in Lisp or similar languages.  Thus, when used
as message streams, the car part of a cons cell contains the message and
the cdr contains the rest of the stream.

   Some standard features of the KLIC system are also provided as
processes with message stream interface.  An example of such message
described in this manual follows.

 -- Message on C-like I/O: putc +C

This means that a message named 'putc' is accepted as a message to a
C-like I/O process interface stream.  The message has one argument
called C in this case.

   To send a message to a message stream, the variable referring to the
message stream should be instantiated with a cons cell whose car
contains the message and cdr contains the rest of the stream.  Thus,
when 'S' is a stream to C-like I/O and character with code 10 is to be
output, the following unification should be made.

     S = [putc(10)|T]

Here, the variable 'T' is given the rest of the stream and thus any
following messages to the stream should be sent to this variable.


File: KLIC.info,  Node: Argument Modes,  Prev: Messages,  Up: Description

1.1.3 Argument Modes
--------------------

Arguments of predicates, methods or messages may have specific
input/output mode.  Input arguments are read by invocation of predicates
or methods; the invocation will be suspended if any of the input
arguments are left undefined.  Output arguments are given a value by the
invocation.

   In the description of predicates and methods, input arguments are
marked with a '+' and output arguments are marked with a '-'.  Some
arguments are not either read or given value.  Such arguments are marked
with a '?'.


File: KLIC.info,  Node: Reporting Bugs,  Prev: Description,  Up: Introduction

1.2 Reporting Bugs and Sending Comments
=======================================

Please report bugs and comments on the KLIC system and this document to
the following mail address.

     klic-bugs@icot.or.jp.

   There is a mailing list for users of KLIC. This mailing list is used
for announcement from the developers on known bugs, fixes or
availability of new releases.  The same mailing list can also be used
for communication among users.  To subscribe to the mailing list, please
send your request to the following address.

     klic-requests@icot.or.jp


File: KLIC.info,  Node: Language,  Next: Builtin and Library,  Prev: Introduction,  Up: Top

2 KL1 Language
**************

KL1 is a programming language for describing concurrent computation
based on Guarded Horn Clauses (GHC, in short).  GHC belongs to a family
of languages called concurrent logic programming languages or
committed-choice logic programming languages.  Languages that belong to
the family are, for example, Concurrent Prolog, Parlog, Fleng, Strand
and Janus.  These languages have simple and concise syntax and semantics
and yet provide very powerful features for concurrent computation.

   Here, a very rough and informal description of the KL1 language is
given.  More detailed and accurate specification are planned to be
supplied in future (hopefully).

* Menu:

* Basics::                      Basic execution mechanism of the language
* Predicates::                  Predicates correspond to subroutines
* Modules::                     Module is a set of predicates
* Goals::                       Goals are units of execution of KL1
* Initial Goal::                How program execution starts
* Generic Objects::             Generic objects extends features of KLIC
* Priority::                    Specifying scheduling preference
* Alternatively::               Preference among clauses
* Argument Pair Notation::
* Inline C Code::               Inserting C code inline


File: KLIC.info,  Node: Basics,  Next: Predicates,  Prev: Language,  Up: Language

2.1 Basic Execution Mechanism
=============================

The following is an example of a small KL1 program that defines a part
of quicksort program.

   Example 1: Quicksort

     :- module quicksort.

     sort(X, Y) :- sort(X, Y, []).

     sort([], Y, Z) :- Y = Z.
     sort([P|X], Y, Z) :-
         partition(P, X, X1, X2),
         sort(X1, Y, [P|Y1]),
         sort(X2, Y1, Z).

     partition(_, [], S, L) :-
         S = [],
         L = [].
     partition(P, [W|X], S, L) :- W =< P |
         S = [W|S1],
         partition(P, X, S1, L).
     partition(P, [W|X], S, L) :- W >= P |
         L = [W|L1],
         partition(P, X, S, L1).

   The first line, ':- module quicksort' declares that this program
module will be called 'quicksort' (*note Modules::).

   Execution of a KL1 program is a (possibly parallel) repetitive
reduction of given "goals" using program "clauses".  Each clause has the
following form.

     PREDICATENAME(ARGUMENT PATTERN ...) :- GUARD | BODY.

   When a goal is to be reduced, clauses for the predicate of the goal
will be inspected.  For clauses with matching argument pattern, their
guard parts are tested.  All the clauses with matching argument pattern
and satisfied guard conditions are candidates to be used in the
reduction.  Only one of them, _arbitrarily chosen,_ will be used and the
original goal will be replaced by the goals in the body of the clause
chosen.

   If no guard condition tests are required, the guard part along with
the vertical bar can be omitted.


File: KLIC.info,  Node: Predicates,  Next: Modules,  Prev: Basics,  Up: Language

2.2 Predicates
==============

"Predicates" of KL1 corresponds to subroutines of Fortran or functions
of C. Predicates are defined by a collection of clauses with the same
predicate name and the same number of arguments in their heads.  Unlike
in some other languages, predicates are identified not only by their
names but also by their "arities" (numbers of arguments).  To identify
predicates with the same name but different arities, the notation
'PREDICATE/ARITY' is used in this manual.

   In the example of the quicksort program, two predicates with the same
name 'sort', with 2 and 3 arguments respectively, are defined (*note
Basic Execution Mechanism: Basics.).  Such predicates are referred to as
'sort/2' and 'sort/3' respectively.

   The order of clauses defining a predicate does not affect the
meaning.  For example, a predicate for computing maximum of two integer
values can be defined as follows.
     max(X, Y, M) :- X >= Y | M = X.
     max(X, Y, M) :- X =< Y | M = Y.

   Exactly the same predicate can be defined by reversing the order of
the clauses as follows.
     max(X, Y, M) :- X =< Y | M = Y.
     max(X, Y, M) :- X >= Y | M = X.

   When a set of clauses are to be used _only when_ another set of
clauses are known not to be applicable, the keyword 'otherwise' should
be put in between the two sets of clauses.  For example, the above 'max'
predicate may be defined as follows.
     max(X, Y, M) :- X >= Y | M = X.
     otherwise.
     max(X, Y, M) :- M = Y.

The meaning of the predicate is almost the same except that this version
succeeds after unifying 'M' with 'Y' even when 'X' or 'Y' does not have
an integer value, while the two previous versions will fail.

   The 'otherwise' directive specifies that clauses after the directive
should not be applied unless all the clauses preceding the directive are
known not to be applicable, even with any information (variable
bindings) may become available afterwards.  This feature should _not_ be
confounded with the 'alternatively' directive, which specifies that
clauses preceding the directive should be given priority to the clauses
following (*note Clause Preference: Alternatively.).


File: KLIC.info,  Node: Modules,  Next: Goals,  Prev: Predicates,  Up: Language

2.3 Modules
===========

KL1 provides "module" structure for dividing large programs into many
modules.  A module consists of one or more predicates.  Definition of a
module starts with a module declaration of the form ':- module MODULE.'
Clauses defining predicates in the module will follow.  The end of the
file or another module declaration ends the definition of the module.

   In the quicksort example, the first line:

     :- module quicksort

declares that this program module is called 'quicksort' (*note Basic
Execution Mechanism: Basics.).

   Predicates defined with the same name and arity but in different
modules are considered to be different predicates.  Thus, when
necessary, the notation 'MODULE:PREDICATE/ARITY' is used to explicitly
specify the module name.


File: KLIC.info,  Node: Goals,  Next: Initial Goal,  Prev: Modules,  Up: Language

2.4 Goals
=========

A Goal is a unit of execution of KL1.  Goals are associated with a
predicate.  A goal is reduced to zero or more simpler goals by applying
one of the clauses defining the predicate.

   Goals are written as:

     PREDICATE(ARGUMENTS, ...)

or simply as the following.

     PREDICATE

when the predicate has no arguments.

   When the predicate is not in the same module, the syntax is either:

     MODULE:PREDICATE(ARGUMENTS, ...)

or as the following.

     MODULE:PREDICATE

   For example, a module named 'main' that uses the quicksort module
might be defined as follows (*note Basic Execution Mechanism: Basics.).

   Example 2: Module using 'quicksort'

     :- module main.

     main :-
         X = [9,2,8,3,6,7,4,1,5],
         builtin:print(X),
         quicksort:sort(X, Y),
         builtin:print(Y).

Here, the body goal 'quicksort:sort(X, Y)' is associated with the
predicate 'sort/2' of the module 'quicksort'.


File: KLIC.info,  Node: Initial Goal,  Next: Generic Objects,  Prev: Goals,  Up: Language

2.5 Initial Goal
================

All KLIC programs start from the initial goal 'main:main', i.e., the
predicate 'main' with no arguments defined in the module 'main'.  The
example of the module 'main' (*note Goals::) is an example of a main
program.

   Command line arguments are not passed to the initial goal.
Predicates to access command line arguments are provided separately
(*note Predicate Interface::).


File: KLIC.info,  Node: Generic Objects,  Next: Priority,  Prev: Initial Goal,  Up: Language

2.6 Generic Objects
===================

"Generic objects" provide a framework to extend the KL1 language with
new data types and their operations.  There are three kinds of generic
objects, namely, "data objects", "consumer objects" and "generator
objects".

   Generic objects are created by pseudo-predicates 'generic:new'.
Generic data objects are similar to usual KL1 data.  Operations on data
objects are defined by their "generic methods".  Methods are invoked by
pseudo-predicates 'generic:METHOD'.  Consumer and generator objects look
like variables to normal KL1 programs and operations on them are
implicit by unification.

   Many of the standard types of KLIC, vectors and strings, for example,
are actually implemented as generic data objects.  For them, builtin
predicates can also be used as aliases for generic methods.  For
example, 'set_vector_element(ORIGINAL, INDEX, NEWELEMENT, NEW)' means
the same as 'generic:set_element(ORIGINAL, INDEX, NEWELEMENT, NEW)'.

* Menu:

* Creating Objects::            How to create generic objects
* Guard Methods::               Operations on data objects in guards
* Body Methods::                Operations on data objects in bodies


File: KLIC.info,  Node: Creating Objects,  Next: Guard Methods,  Prev: Generic Objects,  Up: Generic Objects

2.6.1 Creating Generic Objects
------------------------------

Generic objects are created by the following pseudo-predicate.

     generic:new(CLASSNAME, OBJECT, ARGS, ...)

CLASSNAME should be a symbolic atom which names the object class.  By
this invocation, a new generic object is created and associated with
OBJECT.  Parameters for creation can be specified by ARGS.  The meaning
of ARGS depends on each object class.


File: KLIC.info,  Node: Guard Methods,  Next: Body Methods,  Prev: Creating Objects,  Up: Generic Objects

2.6.2 Guard Methods of Generic Data Objects
-------------------------------------------

Clause selection depending on generic data objects can be done by
calling guard methods.  Guard methods have the following format.

     generic:METHOD(OBJECT, INPUT, ...):OUTPUT:...

   'INPUT, ...' specify input arguments.  If any of the input arguments
are left undefined, this invocation will be suspended.  'OUTPUT:...'
specify output arguments, which are returned from the method.  If some
concrete value is specified as an OUTPUT, guard unification of the
specified and returned values will be made.  Some guard methods have no
output arguments, in which case colon and following OUTPUT are omitted.


File: KLIC.info,  Node: Body Methods,  Prev: Guard Methods,  Up: Generic Objects

2.6.3 Body Methods of Generic Data Objects
------------------------------------------

Operations on generic data objects can be done by calling body methods.
Body methods have the following format.

     generic:METHOD(OBJECT, ARGS, ...)

Unlike guard methods, input and output arguments are not syntactically
distinguished.  The method to be called can be determined in runtime.
To do that, an alternative format is provided.

     generic:generic(OBJECT, FUNCTOR)

With this format, FUNCTOR should be (or become in runtime) a functor
structure of the format 'METHOD(ARGS, ...)'.  Invocation will be
suspended until FUNCTOR will become instantiated.


File: KLIC.info,  Node: Priority,  Next: Alternatively,  Prev: Generic Objects,  Up: Language

2.7 Priority Specification
==========================

Goals have execution priority associated with them.  Execution priority
is specified by a positive integer value.  Goals with larger priority
values are (usually) executed earlier than goals with smaller priority
values.  However, priority specifications are no more than suggestions
and actual implementations may or may not strictly obey them.

   Body goals can have execution priority specification in one of the
following formats.

     'GOAL@priority(ABSPRIO)'
     'GOAL@lower_priority(RELPRIO)'
     'GOAL@lower_priority'

Here, ABSPRIO and RELPRIO should be a non-negative integer constant, or
a variable which should be instantiated to a non-negative integer later.
In the current implementation, negative priority values are interpreted
as zero.

   With the absolute priority specification, the goal with the
specification will have the priority value specified by ABSPRIO.  With
the relative priority specification, the goal will have priority less
than the priority of the parent goal by the amount specified by RELPRIO.
The specification 'GOAL@lower_priority' has the same effect as
'GOAL@lower_priority(1)'.  Goals without any priority specifications
will have the same priority as their parents.

   The highest possible priority is the largest possible integer value,
which depends on host systems (*note Integer Atoms: Integers.).  The
initial goal 'main:main' has the maximum priority possible for the host
system (*note Initial Goal::).


File: KLIC.info,  Node: Alternatively,  Next: Argument Pair Notation,  Prev: Priority,  Up: Language

2.8 Clause Preference
=====================

Predicates of KL1 may have nondeterminacy; more than one clause may be
applicable.  In such cases, preference among clauses may be specified
using the 'alternatively' directive.

   When the keyword 'alternatively' is put in between two sets of
clauses, clauses preceding it are _preferred_ to those following it.
However, when clauses preceding the 'alternatively' directive cannot be
applied directly due to lack of information (insufficient instantiation
of variable values), the clauses following it may be used.  This feature
is often useful in controlling speculative computation depending on
progress of computation.

   The feature is not be confounded with the 'otherwise' feature (*note
Predicates::).  For example, consider the following two predicates.

     p(1, Y, R) :- R = a.
     alternatively.
     p(X, 2, R) :- R = b.

     q(1, Y, R) :- R = a.
     otherwise.
     q(X, 2, R) :- R = b.

When the first argument is still undefined and the second is '2', the
predicate 'p' may return 'b' to the third argument using its second
clause.  The predicate 'q' will wait until the value of the first
argument becomes available.  Thus, if the first argument eventually
becomes '1', the predicate 'q' is guaranteed to return 'a', but the
predicate 'p' may return either 'a' or 'b'.


File: KLIC.info,  Node: Argument Pair Notation,  Next: Inline C Code,  Prev: Alternatively,  Up: Language

2.9 Shorthand Notation for Argument Pairs
=========================================

KL1 programs often require passing two arguments as a pair to a
predicate: one as input and the other as output.  KLIC provides a
shorthand notation for such cases.

* Menu:

* Paired Arguments::
* Macros for Paired Arguments::
* Usage of Paired Arguments::


File: KLIC.info,  Node: Paired Arguments,  Next: Macros for Paired Arguments,  Prev: Argument Pair Notation,  Up: Argument Pair Notation

2.9.1 Paired Arguments and their Expansion
------------------------------------------

The head and goals in both guard and body parts of a clause can have
argument pairs specified by a single variable name attached to the head
or goals by a hyphen character.  We call such pseudo variable an
"argument pair name".  An example is shown here.

     p(X,Y)-Pair :- q(X)-Pair, s(Z)-Pair, r(Pair,Y), t(Z)-Pair.

The pseudo-variable 'Pair' is an argument pair name.  Such a clause is
interpreted the same as the following clause.

     p(X,Y,P0,P) :- q(X,P0,P1), s(Z,P1,P2), r(P2,Y), t(Z,P2,P).

Occurrences of argument pair names attached to the head or goals by a
hyphen character are interpreted as a pair of two different variables
added at the end of the argument lists.  In what follows, we call the
two variables generated from an paired argument an "expanded pair".

   The second of an expanded pair of a goal is the same as the first of
the expanded pair of the next goal with the same argument pair name.  In
the example above, 'P1' appearing as the third argument of the goal of
'q/3' also appears as the second argument of 's/3', as originally they
both have the same argument pair name 'Pair'.

   The first of an expanded pair in the head will be the same as the
first of the expanded pair in the first goal in the clause with the same
argument pair name.  The second of an expanded pair in the head will be
the same as the second of the expanded pair in the last goal with the
same argument pair name.

   In the above example, the first of the expanded pair 'P0' in the head
appears again as the second argument of the first goal calling 'q/3',
and 'P', the second of the expanded pair in the head, appears again as
the third argument of the last goal of 't/3'.

   If the argument pair name appears only in the head, two variables of
the expanded pair are unified in the body.  For example, a clause:

     p(X)-Y :- q(X).

is expanded into the following.

     p(X,Y0,Y) :- Y0=Y, q(X).

   An argument pair name may appear at a usual argument position rather
than being attached to the head or goals, as does the first argument of
the goal for 'r/2' in the above example.  In such a case, it is expanded
to a single variable.  This variable is the same as the second of the
last expanded pair and is also the same as the first of the next
expanded pair.  Thus, in the above example, 'Pair' appearing as the
first argument of 'r/2' is expanded into 'P2', which is the same as the
third argument of 's/3' and the second argument of 't/3'.

   Arbitrarily many argument pair names can be specified for a head or a
goal.  For example, a clause such as:

     p-X-Y :- q-X, r-Y, s-Y-X.

is interpreted as follows.

     p(X0,X,Y0,Y) :- q(X0,X1), r(Y0,Y1), s(Y1,Y,X1,X).

   Sometimes, specifying normal arguments after some argument pair names
is desirable.  This can be done by connecting them with a plus ('+')
character.  For example:

     p-X+Y :- q-X+35, r(Y), s+Y-X.

is interpreted as follows.

     p(X0,X,Y) :- q(X0,X1,35), r(Y), s(Y,X1,X).

   Note that the expansion rules for paired arguments described above
are position sensitive for goals.  However, this does _not_ at all mean
that the execution order of body goals are constrained anyhow.

   Also note that the argument pair notation is no more than macro
expansion of clauses.  One predicate may have clauses some of which
written in the argument pair notation and others in the usual notation.


File: KLIC.info,  Node: Macros for Paired Arguments,  Next: Usage of Paired Arguments,  Prev: Paired Arguments,  Up: Argument Pair Notation

2.9.2 Macros for Paired Arguments
---------------------------------

To fascilitate the usage of paired arguments, KLIC provides the
following macros to be used in place of a goal.

S <= M
     Expanded to 'S0 = [M|S1]' where S0 and S1 are expanded pair for the
     argument pair name S.

M => S
     Expanded to '[M|S0] = S1' where S0 and S1 are the expanded pair for
     the argument pair name S.

S += E
S -= E
S *= E
S /= E
     Expanded to 'S1 := S0 + E0' etc, where S0 and S1 are the expanded
     pair for the argument pair name S.

S <== X
     Expanded to 'S1 = X', where S0 and S1 are the expanded pair for the
     argument pair name S.  S0 does not appear in the expansion; the
     original value of the paired argument for S will be lost, and the
     next occurrence of S will mean X instead.  This feature is normally
     used with a non-paired occurrence of the argument pair name.  For
     example:

          ..., p-S, q(S), S <== X, r-S, ...

     means the following.

          ..., p(S0,S1), q(S1), S2 = X, r(S2,S3), ...


File: KLIC.info,  Node: Usage of Paired Arguments,  Prev: Macros for Paired Arguments,  Up: Argument Pair Notation

2.9.3 Usage of Paired Arguments
-------------------------------

Some examples of typical usage of paired arguments are given here.

   The following program is for summing up elements of a list of
integers.

     sum(List,Sum) :- sum(List)+0+Sum.

     sum([])-Acc.
     sum([H|T])-Acc :- Acc += H, sum(T)-Acc.

Here, the paired argument 'Acc' plays the role of an accumulator.

   The following program inverts the sign of the elements of a list of
integers.

     inv(List,Inv) :- inv(List)+Inv-[].

     inv([])-Inv.
     inv([H|T])-Inv :- MH := -H, Inv <= MH, inv(T)-Inv.


File: KLIC.info,  Node: Inline C Code,  Prev: Argument Pair Notation,  Up: Language

2.10 Inserting C Language Code Inline
=====================================

The inline C code feature allows specifying C programs to be inserted in
the object code within KL1 programs.  This feature is somewhat similar
to the 'asm' statements of C.

   Appropriateness of inserted C code totally depends on internal
implementation schemes of the KLIC system, which may be altered in
future.  Thus, *general users are not recommended to use this feature.*

* Menu:

* Top Insertion::               Inserting C program text at the top
* Guard Insertion::             Inserting C program text in guards
* C-Level Rep::                 C-level representation of KL1 terms
* Examples of Inline::          Some examples of inline C code
* Hints of Inline::             Some hints on using inline C code


File: KLIC.info,  Node: Top Insertion,  Next: Guard Insertion,  Prev: Inline C Code,  Up: Inline C Code

2.10.1 Inline Insertion at the Top of Files
-------------------------------------------

At the top of a source file, strings to be inserted in the object C
program can be specified in the following way.

     :- inline:"C PROGRAM TEXT TO BE INSERTED".

   The specified text is inserted in the object C program after standard
declarations and before any user-defined modules.

   There can be any number of such inline specification.  A typical
example is as follows.

     :- inline:"#include <stdio.h>"

   As inserted C programs are written as string constants of KLIC,
doubleqoute characters have to be escaped with a backslash character.  A
typical example is as follows.

     :- inline:"#include \"myheader.h\""

   It might also be a good idea to define macros and functions here,
that are invoked from the inline code in clause guards.


File: KLIC.info,  Node: Guard Insertion,  Next: C-Level Rep,  Prev: Top Insertion,  Up: Inline C Code

2.10.2 Inline Insertion in the Guard
------------------------------------

Inline insertion specification can also appear as a guard goal with one
of the following forms.

     inline:"C PROGRAM TEXT"
     inline:"C PROGRAM TEXT":[ARGSPEC, ...]

   With either format, the C program text is literally inserted in the
object code corresponding to the guard part, except that percent signs
('%') in the program text string specify special formatting.  The
following table lists special format characters after percent signs and
what they mean.

<digit>
     The name of the C variable corresponding to the <digit>-th ARGSPEC
     (zero origin).  Note that only up to 10 such arguments are allowed.

f
     The name of the C label to 'goto' when this clause should fail or
     suspend.

%
     The percent character itself, i.e., percent characters should be
     doubled.  Be careful when you specify format strings for 'printf'.

ARGSPEC has one of the following formats.

VARIABLE+TYPE
     Specifies that the value of the variable is used within the
     inserted program text.  Object code for synchronization with
     availability of the variable value and checking of the value type
     is generated by the compiler.

VARIABLE-TYPE
     Specifies that variable is given a value within the inserted
     program text.  This has to be the first occurence of the variable.
     The compiler assumes that, after executing the inserted code, the
     variable will have value of TYPE.

The Type field should be one of the following.

any
     Anything, including uninstantiated variables
bound
     Any bound value
atomic
     An atomic value (a symbolic atom or an integer)
int
     An integer
atom
     An symbolic atom
list
     A list structure
functor
     A functor structure (including generic object)
object
     A generic data object
object(CLASS)
     A generic data object of CLASS

   Values are referenced without any indirections for all types except
for 'any'.  For an input ('+') mode argument, the generated code makes
sure that, before executing the inserted program text, the argument will
have the value of the specified type directly, without indirect
references.  For an output ('-') mode argument, the compiler assumes
that, after executing the inserted program text, the variable will have
the value of the specified type directly, without any indirect
references, and uses that information for optimization.  If you cannot
be sure of this for output mode arguments, specify 'any', which may be
less efficient but safe.


File: KLIC.info,  Node: C-Level Rep,  Next: Examples of Inline,  Prev: Guard Insertion,  Up: Inline C Code

2.10.3 C-Level Representation of KL1 Terms
------------------------------------------

Note that C language types of the C variables and KL1 language types of
corresponding KL1 values are not the same.  All the C variables
corresponding to a KL1 value have the type 'q' which means almost
nothing except that it occupies a single word.  KL1 values are somehow
encoded (with attached tag etc).  For example, an integer 3 of KL1 is
_not_ represented by the bit pattern corresponding to integer 3 in of
the language C.

   This document is not intended to describe all the details of the data
representation scheme of KLIC. Such description and programs depending
on it will be obsoleted anyway by future revisions of the KLIC system.
However, manipulation of integer values may be the easiest and useful in
most C programs written inline.  Thus, we'll describe macros for data
conversion for integers.  They are unlikely to be changed in future
versions.

   To obtain the integer value of a variable corresponding to an integer
value of KL1, use the macro 'intval(X)'.  To obtain KL1 representation
of integer in C, use the macro 'makeint(N)'.


File: KLIC.info,  Node: Examples of Inline,  Next: Hints of Inline,  Prev: C-Level Rep,  Up: Inline C Code

2.10.4 Examples
---------------

*Example 1: Adding Two Integers*

   Two integers can be added by the following clause.

         p(X,Y,Z) :- W := X+Y | Z = W.

   The same function can be realized using the inline insertion feature
as follows.

     p(X,Y,Z) :-
       inline:"%2 = makeint(intval(%0)+intval(%1));":
         [X+int, Y+int, W-int] | Z=W.

   The inserted text will be as follows.

     x0 = makeint(intval(a0)+intval(a1));

   Where variables 'a0' and 'a1' correspond to 'X' and 'Y', and 'x0' to
'W' in the KL1 program.  Note that the 'Z' and 'W' are unified in the
body.

*Example 2: Comparing Two Integers*

   Two integers can be compared by the following clause.

     p(X,Y) :- X > Y | ...

   The same function can be realized using the inline insertion feature
as follows.

     p(X,Y) :-
       inline:"if (intval(%0) <= intval(%1)) goto %f;":
         [X+int, Y+int] | ...

   The inserted text will be as follows.

     if (intval(a0) <= intval(a1)) goto p_2_interrupt;

   Where variables 'a0' and 'a1' correspond to 'X' and 'Y' in the KL1
program, and 'p_2_interrupt' is a label automatically generated by the
compiler.


File: KLIC.info,  Node: Hints of Inline,  Prev: Examples of Inline,  Up: Inline C Code

2.10.5 Some Hints on Using the Inline C Code Feature
----------------------------------------------------

   * Whenever possible, avoid using the inline feature.  Revisions of
     the KLIC system may obsolete your code.

   * If multiple lines are to be inserted consecutively, specify all of
     them in one single inline specification.  Otherwise, they might be
     interleaved by other code for the guard.  Newlines are allowed
     within the inserted program text.

   * Do not forget to prefix doublequotes and backslahes with a
     backslash.  Do not forget also to write two percent signs to insert
     one.  If you would like to say hello to the world, you should write
     such a program as follows.

          hello :-
              inline:"printf(\"Hello, world\\n\");" |
              ...

     Note the backslashes before doublequotes within the inlined code
     and doubled backslash before 'n'.  If you put only one backslash
     before 'n', it will become a newline code after inline expansion;
     it will appear within a string constant in the expanded C program.
     It fortunately works the same in this case, except that some C
     compilers may generate a warning message.

   * If your program with inline code does not work as you expect it to,
     the best way to find the problem may be to look into the C code
     generated.


File: KLIC.info,  Node: Builtin and Library,  Next: Using KLIC,  Prev: Language,  Up: Top

3 Builtin and Library Features
******************************

This chapter describes builtin and library features of KLIC.

* Menu:

* Common Operations::           Operations common to all the data types
* Atomic Data::                 Atomic data and their operation
* Structured Data::             Structured data and their operation
* Executable Code::             Higher order manipulation of executable code
* Unix::                        Interfacing with the operating system
* Input and Output::            Input and output from and to files &c
* System Control::              Controlling system behavior
* Timer::                       Timing and interval timer
* Random Numbers::              Random number generator


File: KLIC.info,  Node: Common Operations,  Next: Atomic Data,  Prev: Builtin and Library,  Up: Builtin and Library

3.1 Common Operations
=====================

Some predicates are used commonly for all the data types or are
independent from any data types.

* Menu:

* Unification::                 Unifying two terms
* Synchronization::             Waiting for data availability
* Comparison and Hashing::      Comparing and hashing terms
* Execution Status::            Knowing about execution status
* Debugging::                   Debugging support


File: KLIC.info,  Node: Unification,  Next: Synchronization,  Prev: Common Operations,  Up: Common Operations

3.1.1 Unification
-----------------

 -- Guard Predicate on builtin: = ?X ?Y
     Checks whether X and Y are unifiable without giving values to
     variables outside the clause.

 -- Body Predicate on builtin: = ?X ?Y
     Unifies X and Y.  If X has no value yet and Y already has some
     defined value, the value of Y is given to X.  If Y has no value and
     X has some, the reverse takes place.  If both do not have values
     yet, two variables are made to mean the same variable.  If both
     have values, they are matched.  If both are the data structures of
     the same kind, this unification operation is made recursively to
     corresponding elements of two structures.


File: KLIC.info,  Node: Synchronization,  Next: Comparison and Hashing,  Prev: Unification,  Up: Common Operations

3.1.2 Synchronization
---------------------

 -- Guard Predicate on builtin: wait +X
     Waits until instantiation of X.


File: KLIC.info,  Node: Comparison and Hashing,  Next: Execution Status,  Prev: Synchronization,  Up: Common Operations

3.1.3 Comparison and Hashing
----------------------------

 -- Guard Predicate on builtin: compare +X +Y -R
     Compares X and Y, and returns the result in R.  The result is an
     integer value less than, equal to, or greater than 0, when X is
     less than, equal to, or greater than Y, respectively.

     The comparison is made by the standard order.  This predicate can
     compare data of any types.  If both X and Y are of the same numeric
     type, normal numerical comparison is made.  Note that integer and
     floating point numbers are _not_ of the same type; their comparison
     may not be meaningful.  Two strings are compared in (so-called)
     dictionary order.

     The order of any two data of different types is somehow defined by
     the system.  However, the ordering is guaranteed to be kept only
     within a single executable program.  If some data sequence is saved
     into a permanent file using the ordering provided by this
     predicate, the same program recompiled or linked with some other
     programs may or may not recognize the sequence as ordered.
     Different programs, of course, may use different ordering.

     Both X and Y have to be instantiated enough for making the
     comparison.  For example 'f(V) @< f(W)' will suspend if not both
     'V' and 'W' are instantiated.  On the other hand, 'f(1,V) @<
     f(2,W)' will succeed immediately, as the order can be determined
     without looking into values of 'V' or 'W'.

     The absolute value of the result R may have some meaning for
     certain data types.  When comparing two strings, the absolute value
     of the result is one more than the index of the first differng
     element (a la 'strcmp' of C).

     Some generic objects may not implement their comparison methods,
     and, in such cases, their comparison will result in a fatal error.

 -- Guard Predicate on builtin: @< +X +Y
 -- Guard Predicate on builtin: @=< +X +Y
 -- Guard Predicate on builtin: @>= +X +Y
 -- Guard Predicate on builtin: @> +X +Y
     Compares X and Y with the standard order.  If the condition is not
     satisfied, the invocation of the predicate fails.

 -- Guard Predicate on builtin: \= +X +Y
     Compares X and Y and succeeds if and only if their principal
     functors are different.  For atomic values, it means that they are
     different; for functor structures, it means that either they have
     different functor names or different arity.  For generic objects,
     the predicate succeeds when two objects are of different classes.

     Note that 'f(a) \= f(b)' fails, as the two terms have the same
     principal functor.  Note also that, floating point numbers are
     generic objects and thus 'X \= Y' fails for any two floating point
     numbers, as they are objects of the same class.

 -- Guard Predicate on builtin: hash +X -H
     Computes the hash value of X and returns it in H.  The hash value
     is a non-negative integer value.

     Hashing function may look into elements of structured data
     recursively.  X has to be instantiated enough to compute hash
     value.  Some generic objects may not implement hash methods, and,
     in such cases, their hash value becomes a constant.


File: KLIC.info,  Node: Execution Status,  Next: Debugging,  Prev: Comparison and Hashing,  Up: Common Operations

3.1.4 Execution Status
----------------------

 -- Guard Predicate on builtin: current_priority -P
     Returns the priority value of the reduced goal to P.  *Note
     Priority Specification: Priority, for further details on the
     priority mechanism.

 -- Body Predicate on builtin: current_node -Node -NumNodes
     On a parallel implementation, the predicate returns the processor
     number executing the predicate in NODE and the total number of
     (pseudo-) processors available in NUMNODES.  Processor numbers have
     zero origin.  Thus, the maximum value returned to NODE is one less
     than the value returned to NUMNODES.  On a sequential
     implementation, 0 is returned to NODE and 1 to NUMNODES.


File: KLIC.info,  Node: Debugging,  Prev: Execution Status,  Up: Common Operations

3.1.5 Debugging
---------------

 -- Body Predicate on builtin: unbound ?X -Result
     Checks whether X is already bound to some concrete value or not and
     returns the RESULT.

     If the toplevel of X is already defined, RESULT is unified with a
     single-element vector of the form {X}.  When X is bound to a
     structured value, its elements may or may not be bound yet.

     If X is not bound yet, RESULT is unified with a three element
     vector of the form {ADDR1, ADDR2, X}, where ADDR1 and ADDR2 are
     integers indicating the current address of the variable X somehow.
     Note that variable addresses may change in time by garbage
     collection, automatic data migration in parallel implementations or
     any such low level implementational reasons; they are no more than
     debugging hints.

     *Do not use this predicate in normal application programs.*  Unlike
     the 'var/1' feature of sequential Prolog, variables once judged as
     unbound can be bound in the next instance on parallel
     implementations.  Thus, usage of this predicate should be
     restricted to programs that have to go into low level details of
     the system implementation, such as debugging tools.


File: KLIC.info,  Node: Atomic Data,  Next: Structured Data,  Prev: Common Operations,  Up: Builtin and Library

3.2 Atomic Data
===============

KLIC provides two kinds of atomic data types, numerical and symbolic.

   For numerical data, KLIC provides integer and floating point number
data types and operations to manipulate them.  Floating point numbers
are implemented as generic objects and thus actually are not an atom.

   Note that implicit type conversions between integer and floating
point data are never made.  Integer numbers and floating point numbers
are treated completely separately.

   Whether given data is atomic or not can be tested by the following
guard predicates.

 -- Guard Predicate on builtin: atomic +X
     Tests whether X is atomic or not.  Floating point numbers are _not_
     judged as atomic by this predicate.

* Menu:

* Symbolic Atoms::              Symbolic atoms give names to various concepts
* Integers::                    Integer data and their operations
* Floating Points::             Floating point data and their operations


File: KLIC.info,  Node: Symbolic Atoms,  Next: Integers,  Prev: Atomic Data,  Up: Atomic Data

3.2.1 Symbolic Atoms
--------------------

"Symbolic atoms" are atomic data objects that give names to notions.
Symbolic atoms with the same name are the same and with different names
are different.

* Menu:

* Notation of Atoms::           Notation of symbolic atoms
* Symbolic Atom Operation::     Operations on symbolic atoms


File: KLIC.info,  Node: Notation of Atoms,  Next: Symbolic Atom Operation,  Prev: Symbolic Atoms,  Up: Symbolic Atoms

3.2.1.1 Notation of Symbolic Atoms
..................................

The notation of symbolic atoms is similar to Edinburgh Prolog, which is
one of the following.

   * A lower case letter followed by a sequence of any number (including
     zero) of letters, digits or underlines.

     Examples:
          icot   kl1   a_symbolic_atom_with_a_long_name

   * A sequence of special characters (some of '~', '+', '-', '*', '/',
     '\', '^', '<', '>', '=', '`' (backquote), ':', '.', '?', '@', '#',
     '$', '&').

     Examples:
          +   >=   :-   =:=

   * A sequence of any characters quoted by single quotes.  If single
     quote characters are to be included, they should be doubled or
     escaped by a backslash.

     Examples:
          'Hello world'    'an atom with \'singlequotes\' in it'

   * Special one-character atoms.  There are three of them, which are
     '!', '|' and ';'.  Also, '|' has a special meaning in list notation
     (*Note Notation of Lists::).

   * A special atom '[]', which usually is used to represent ends of
     lists (*note Lists::).  Spaces can be in between '[' and ']'.

   Important differences with Edinburgh Prolog syntax are the following.

   * A vertical bar ('|') means a one-character atom.  Even when it is
     used as an operator, it is _not_ treated the same as a semicolon
     (';') but as a different atom.

   * A pair of curly braces ('{}') does not stand for a symbolic atom.
     It means a vector with no elements (*note Notation of Vectors::).


File: KLIC.info,  Node: Symbolic Atom Operation,  Prev: Notation of Atoms,  Up: Symbolic Atoms

3.2.1.2 Operations on Symbolic Atoms
....................................

Whether a given data object is a symbolic atom or not can be tested by
the following guard predicate.

 -- Guard Predicate on builtin: atom +X
     Tests whether X is a symbolic atom or not.

   To maintain the uniqueness of atoms, the system gives a unique number
to each atom and maintains the association between atom name strings and
atom numbers.  Association of symbolic atoms and their names can be
known by the following predicates defined in the module 'atom_table'.

 -- Predicate on atom_table: make_atom +String -Atom
     When given a STRING, returns ATOM with that name.  If such an atom
     does not exist, a new atom is registered.

 -- Predicate on atom_table: atom_number +Atom -Number
     Internal serial number for ATOM is returned to NUMBER as an integer
     value.

 -- Predicate on atom_table: get_atom_string +Atom -String
     The name string of ATOM is returned to STRING.

 -- Predicate on atom_table: intern +String -Result
     The same as atom_table:make_atom, except that the returned value is
     a functor structure of the form 'normal(ATOM)'.

 -- Predicate on atom_table: get_atom_name +Atom -Result
     The same as atom_table:get_atom_string, except that the returned
     value is a functor structure of the form 'normal(STRING)'.

   Although symbolic atoms are associated with their name strings, do
_not_ use them for string manipulation.  String data objects provide
much more functionality and better performance (*note Strings::).


File: KLIC.info,  Node: Integers,  Next: Floating Points,  Prev: Symbolic Atoms,  Up: Atomic Data

3.2.2 Integer Atoms
-------------------

KLIC provides integer data with usually 28 or 60 bits as its basic
standard feature.  The width depends on the C compiler you use.  It is 4
bits shorter than the width of type 'long int'.

 -- Guard Predicate on builtin: integer +X
     Tests whether X is an integer atom.

* Menu:

* Notation of Integers::        Notation of integers
* Integer Arith::               Integer arithmetics
* Integer Comp::                Integer comparison


File: KLIC.info,  Node: Notation of Integers,  Next: Integer Arith,  Prev: Integers,  Up: Integers

3.2.2.1 Notation of Integers
............................

KLIC provides several ways to denote integer constants.
   * Usual decimal notation: optional minus sign followed by a sequence
     of decimal digits.  Examples: '123', '-35'.
   * Based notation: optional minus sign followed by a sequence of
     decimal digits specifying the base (1 to 36), an apostrophe, and
     then a sequence of digits of the base, that are digits and
     alphabets (case insensitive).  Examples: '2'1010', '16'0D0a'.
     Value of an integer with base 1 is the number of ones in the digit
     sequence; for example '1'10110' means 3.
   * Character code notation: optional minus sign followed by a digit 0,
     an apostrophe and a character.  Examples: '0'a' means the character
     code of lowercase letter 'a'.
   The above listed constant notations can be used in both KL1 programs
and KL1 data read in by Prolog-like I/O interface (*note Input and
Output with Prolog-like Interface: Prolog I/O.).

   The following are also allowed in KL1 programs for compatility with
PIMOS system on PIM machines.
   * Based notation: optional minus sign followed by a sequence of
     decimal digits specifying the base (1 to 36), a sharp sign, and
     then a charcter string of digits of the base, that are digits and
     alphabets (case insensitive), surrounded by doublequotes.
     Examples: '2#"1010"', '16#"0D0a"'.
   * Character code notation: optional minus sign followed by a sharp
     sign and a character enclosed within doubleqoutes.  Examples:
     '#"a"' means the character code of lowercase letter 'a'.


File: KLIC.info,  Node: Integer Arith,  Next: Integer Comp,  Prev: Notation of Integers,  Up: Integers

3.2.2.2 Integer Arithmetics
...........................

 -- Guard Predicate on builtin: := -Var +Expr
 -- Body Predicate on builtin: := -Var +Expr
     Computes the value of the integer expression EXPR, and unifies it
     with VAR.  The following operators are available in the expression.

     X + Y
          Addition.
     + X
          No operation.  X is the result.
     X - Y
          Subtraction.
     - X
          Sign inversion.
     X * Y
          Multiplication.
     X / Y
          Integer division.
     X mod Y
          Modulo.
     \(X)
          Bit-wise complement.
     X /\ Y
          Bit-wise logical AND.
     X \/ Y
          Bit-wise logical OR.
     X xor Y
          Bit-wise exclusive OR.
     X << Y
          Left shift.
     X >> Y
          Logical right shift.
     int(X)
          Conversion from floating point to integer.  X is a floating
          point expression (*note Floating Point Arithmetics: Floating
          Arith.) and its result is rounded to an integer value.

     Arithmetical overflows are ignored, that is, all the arithmetics
     are done modulo 2**28 or 2**60 depending on the C compiler used.  C
     compilers with 32-bit 'long int' give 28-bit KLIC integers and
     those with 64-bit 'long int' give 60-bit KLIC integers.

     This predicate is available in both guards and bodies of clauses.

     If any of the operands in the expression are uninstantiated, the
     computation will be suspended until they all get instantiated.

     Any operands in the expression can be an expression recursively.
     However, operands written as a variable in the program should _not_
     be instantiated to a compound term such as '3 + 5'.  They should be
     instantiated only to an integer.  Otherwise, a type mismatch error
     will be generated.


File: KLIC.info,  Node: Integer Comp,  Prev: Integer Arith,  Up: Integers

3.2.2.3 Integer Comparison
..........................

Comparison of integer data can be made using the predicates described
here.  More general comparison predicate is also provided (*note
Comparison and Hashing::), but predicates and methods described here are
more efficient when the operands are known to be integers.

 -- Guard Predicate on builtin: > +X +Y
 -- Guard Predicate on builtin: >= +X +Y
 -- Guard Predicate on builtin: =:= +X +Y
 -- Guard Predicate on builtin: =\= +X +Y
 -- Guard Predicate on builtin: =< +X +Y
 -- Guard Predicate on builtin: < +X +Y
     Perform arithmetical comparison of two integer arguments.  Use
     '=:=' and '=\=' for equality and non-equality checks.  Each side of
     the comparison can be an arithmetical expression.  The same set of
     operators as in ':=' can be used.


File: KLIC.info,  Node: Floating Points,  Prev: Integers,  Up: Atomic Data

3.2.3 Floating Point Numbers
----------------------------

Floating point numbers with precision of 64 bits are provided as generic
objects.  The following method and predicate tell whether given data is
a floating point number or not.

 -- Guard Method on float: float +X
 -- Guard Predicate on builtin: float +X
     Tests whether X is a floating point number.

* Menu:

* Notation of Floats::          Notation of floating point numbers
* Creating Floats::
* Floating Arith::              Floating point arithmetics
* Floating Comp::               Floating comparison


File: KLIC.info,  Node: Notation of Floats,  Next: Creating Floats,  Prev: Floating Points,  Up: Floating Points

3.2.3.1 Notation of Floating Point Numbers
..........................................

Floating point numbers have the following constant notation syntax.

     SIGN INTEGRAL '.' FRACTION 'e' SIGN EXPONENT

where INTEGRAL, FRACTION and EXPONENT are sequence of decimal digits.
SIGN is either '+', '-' or empty (meaning '+').  The exponent part, that
is, character 'e', SIGN and EXPONENT, may be omitted altogether.

   The following are examples of floating point number constants.

     3.14159  -6.02e23  1234.5678e-25


File: KLIC.info,  Node: Creating Floats,  Next: Floating Arith,  Prev: Notation of Floats,  Up: Floating Points

3.2.3.2 Creating New Floating Point Numbers
...........................................

New floating point numbers can be created by the following.  Predicates
for floating point arithmetics described in *note Floating Arith:: also
create floating point numbers as the result of arithmetical operations.

 -- Object Creation on float: new -Float +Init
     A new floating point number is created and unified with FLOAT.  The
     argument INIT should be an integer specifying the value of the
     floating point number.  For example, 'generic:new(float, F, 3)'
     unifies 'F' with '3.0'.


File: KLIC.info,  Node: Floating Arith,  Next: Floating Comp,  Prev: Creating Floats,  Up: Floating Points

3.2.3.3 Floating Point Arithmetics
..................................

 -- Body Predicate on builtin: $:= -Var +Expr
     Computes the value of the floating point expression EXPR, and
     unifies it with VAR.  The following operators are available in the
     expression.

     X + Y
          Addition.
     X - Y
          Subtraction.
     X * Y
          Multiplication.
     X / Y
          Division.
     pow(X, Y)
          Y to the power of X.
     sin(X), cos(X), tan(X)
          Trigonometric functions on X.
     asin(X), acos(X), atan(X)
          Inverse trigonometric functions on X.
     sinh(X), cosh(X), tanh(X)
          Hyperbolic functions on X.
     exp(X)
          Exponential function.
     log(X)
          Natural logarithm.
     sqrt(X)
          Square root.
     ceil(X)
          Ceiling function (rounding toward positive infinity).
     floor(X)
          Flooring function (rounding toward negative infinity).
     float(X)
          Conversion from an integer to a floating point number.  X is
          an integer expression (*note Integer Arithmetics: Integer
          Arith.) and its result is converted to a floating point
          number.

     This predicate is available in both guards and bodies of clauses.

     If any of the operands in the expression are uninstantiated, the
     computation will suspend until they all get instantiated.

     Any operands in the expression can be an expression recursively.
     However, operands written as a variable in the program should _not_
     be instantiated to a compound term such as '3.0 + 5.0'.  They
     should be instantiated only to a floating point number.  Otherwise,
     a type mismatch error will be generated.

   Operations listed above are also provided as generic methods on
floating point number.

 -- Body Method on float: add +X +Y -R
 -- Body Method on float: subtract +X +Y -R
 -- Body Method on float: multiply +X +Y -R
 -- Body Method on float: divide +X +Y -R
 -- Body Method on float: pow +X +Y -R
 -- Body Method on float: sin +X -R
 -- Body Method on float: cos +X -R
 -- Body Method on float: tan +X -R
 -- Body Method on float: asin +X -R
 -- Body Method on float: acos +X -R
 -- Body Method on float: atan +X -R
 -- Body Method on float: sinh +X -R
 -- Body Method on float: cosn +X -R
 -- Body Method on float: tanh +X -R
 -- Body Method on float: exp +X -R
 -- Body Method on float: log +X -R
 -- Body Method on float: sqrt +X -R
 -- Body Method on float: ceil +X -R
 -- Body Method on float: floor +X -R
     These methods perform arithmetic operations, specified by the
     method name, on given operand(s), and return the result in R.


File: KLIC.info,  Node: Floating Comp,  Prev: Floating Arith,  Up: Floating Points

3.2.3.4 Floating Point Comparison
.................................

Comparison of floating point data can be made by the predicates
described here.  More general comparison predicate is also provided
(*note Comparison and Hashing::), but predicates and methods described
here are more efficient when the operands are known to be floating point
numbers.

 -- Guard Predicate on builtin: $> +X +Y
 -- Guard Predicate on builtin: $>= +X +Y
 -- Guard Predicate on builtin: $=:= +X +Y
 -- Guard Predicate on builtin: $=\= +X +Y
 -- Guard Predicate on builtin: $=< +X +Y
 -- Guard Predicate on builtin: $< +X +Y
     These predicates perform arithmetical comparison of two floating
     point arguments.  Use '=:=' and '=\=' for equality and non-equality
     checks (although they may not be much meaningful for floating point
     numbers).  Each side of the comparison can be a floating point
     arithmetical expression.  The same set of operators as in '$:=' can
     be used.

     *Bug Caution* The current version (1.510) has problems with
     expressions with operators in these predicates.  Only simple
     variables and constants can be used.

   Comparison of floating point numbers can also be made by the methods
described below.

 -- Guard Method on float: less_than +X +Y
 -- Guard Method on float: not_greater_than +X +Y
 -- Guard Method on float: not_less_than +X +Y
 -- Guard Method on float: greater_than +X +Y
 -- Guard Method on float: equal +X +Y
 -- Guard Method on float: not_equal +X +Y
     These methods test whether X is less than Y or not, etc.


File: KLIC.info,  Node: Structured Data,  Next: Executable Code,  Prev: Atomic Data,  Up: Builtin and Library

3.3 Structured Data
===================

Structured data objects consist of zero or more elements.

* Menu:

* Functors::                    Named data structures
* Lists::                       Linear list of elements
* Vectors::                     One-dimensional arrays of any data
* Strings::                     Array of small integers such as character codes


File: KLIC.info,  Node: Functors,  Next: Lists,  Prev: Structured Data,  Up: Structured Data

3.3.1 Functor Structures
------------------------

Functor structures are structures with given name and one or more
elements, which can be of any type.  Functors are conveniently used for
representing data structures whose sizes are known beforehand.  Functors
correspond to record structures of C-like languages.

* Menu:

* Notation of Functors::        Notation of functors
* Functor Operation::           Operation on fucntor structures


File: KLIC.info,  Node: Notation of Functors,  Next: Functor Operation,  Prev: Functors,  Up: Functors

3.3.1.1 Notation of Functors
............................

Functor constants can be written by the name of the principal functor, a
left parenthesis, elements separated by commas, and finally a right
parenthesis.  Functor names have the same syntax as symbolic atoms.  The
principal functor name and the following left parenthesis should _not_
be separated by space characters or any other punctuation symbols.
Elements can be of any type, including variables or functors themselves.

   Examples:
     f(a, 3)   'a recursive functor structure'(X, 'child functor'(Y))


File: KLIC.info,  Node: Functor Operation,  Prev: Notation of Functors,  Up: Functors

3.3.1.2 Operations on Functors
..............................

Predicates for manipulation of functor structures are provided as
builtin predicates and in the module 'functor_table', as listed in this
section.

   In the current implementation, all the body builtin predicates listed
here are actually implemented as macros expanded to predicates of the
module 'functor_table'.  This implementation scheme may be changed in
future releases.

 -- Guard Predicate on builtin: functor +X -Functor -Arity
 -- Body Predicate on builtin: functor +X -Functor -Arity
     X is a functor with the principal functor whose name being FUNCTOR
     and arity ARITY.  These predicates can be used for obtaining the
     the name and/or the arity of principal functors.  The guard
     predicate version can also be used for testing that X has the name
     FUNCTOR and/or the arity ARITY.  Any instantiated data that are not
     functor structures, i.e., atomic data, strings, vectors and so on,
     have zero as their arities and themselves as their principal
     functor names.  Note that list structures consist of functors
     './2'.

     This predicate cannot be used to create a new functor.

 -- Guard Predicate on builtin: arg +Pos +Term -Arg
 -- Body Predicate on builtin: arg +Pos +Term -Arg
     The POS-th argument of TERM is ARG.  Arguments are numbered from 1.
     The guard version simply fails if POS is out of range.  As all the
     data structures except for functor structures have no arguments,
     this predicate always fails for them.

 -- Body Predicate on builtin: new_functor -Functor +Atom +Arity
     A functor structure with its principal functor with name ATOM and
     arity ARITY is returned to FUNCTOR.  Arguments of the created
     functor are initiated with integer '0'.

 -- Body Predicate on builtin: setarg +Pos +Fnct ?NewE -NewFnct
 -- Body Predicate on builtin: setarg +Pos +Fnct ?OldE ?NewE -NewFnct
     A new functor structure that is different from FNCT with only one
     argument at POS is created and returned to NEWFNCT.  The element
     with index POS of NEWFNCT will be NEWE.  For five argument
     versions, the original argument at POS will be returned to OLDE.

 -- Predicate on functor_table: =.. -NewFnct +List
     A new functor structure is created and returned to NEWFNCT.  The
     name of the principal functor is specified by the first element of
     LIST, which should be a symbolic atom, and the arguments are
     specified by the rest of LIST.  If LIST has only one element, that
     element is returned to NEWFNCT.

     This predicate can _not_ be used for decomposing a functor
     structure to a list.


File: KLIC.info,  Node: Lists,  Next: Vectors,  Prev: Functors,  Up: Structured Data

3.3.2 Lists
-----------

Lists are arbitrarily long sequences of any data objects.  In KL1, List
structures are made up of functor structures './2', that is, functor
structures with their name '.' and arity two.  List structures are
composed of possibly many of these functor structures (sometimes called
"cons cells").

   The first element of the cons cell, sometimes called the "car" of the
cell, represents the first element of the list.  The second element, the
"cdr" of the cell, represents the rest of the list.  Termination of the
list is indicated by a symbolic atom '[]' being the cdr.

   Whether a given argument is a list or not can be tested by the
following guard predicate.

 -- Guard Predicate on builtin: list +X
     Tests whether X is a cons cell.  Note that, despite its name, this
     predicate fails for a null list '[]' for a historical reason.

   Incrementally instantiated list structures are conveniently used as
message streams.

* Menu:

* Notation of Lists::           Notation of Lists
* Merging::                     Merging messages from multiple streams


File: KLIC.info,  Node: Notation of Lists,  Next: Merging,  Prev: Lists,  Up: Lists

3.3.2.1 Notation of Lists
.........................

As in Lisp, lists of KL1 are constructed using _cons_ data structures,
which is actually a functor structure './2'.

   The basic notation for lists is '[CAR | CDR]', which consists of the
first element CAR and the tail of the list CDR.  This means exactly the
same as '.(CAR, CDR)'.  An empty list is represented by an atom '[]'.

   If CDR happens to be empty, that is, when the list consists only of
one element CAR, such a list can be written as '.(CAR, [])' or '[CAR |
[]]', or, alternatively, as '[CAR]'.  That is, the sequence '| []' at
the tail of a list can be ommitted.

   Lists with its car being CAR and its cdr being a list '[CADR, ...]'
is '[CAR | [CADR, ...]]', which can be abbreviated as '[CAR, CADR,
...]'.  For example, a list consisting of four elements, 'first',
'second', 'third' and 'fourth' can be written as '[first, second, third,
fourth]'.

   A list consisting of four or more elements, but with the first four
elements being 'first', 'second', 'third' and 'fourth', can be written
as '[first, second, third, fourth | Rest]'.  Here, the variable 'Rest'
corresponds to the list beginning with the fifth element, or an empty
list if the whole list had only four elements.

   Note that, unlike in Ediburgh Prolog, the character sequence ',..'
can _not_ be used in place of '|'.


File: KLIC.info,  Node: Merging,  Prev: Notation of Lists,  Up: Lists

3.3.2.2 Manipulation of Message Streams
.......................................

A stream merger is a process that takes multiple message streams
represented as lists of messages as input, and passes all the messages
from all the input streams to a single output stream also represented as
a list.

   The output consists of all the messages in the inputs with duplicates
preserved.  When two messages are ordered in one of the input streams,
their order is also preserved in the output.  When messages are from
different input streams, their order in the output is unpredictable.
The order may differ in one execution of the same program from another.
The behavior of mergers is thus nondeterministic.

   For example, when there are two input streams '[1, 2, 3]' and '[a, b,
c]', the output can be something like '[1, 2, a, b, 3, c]' or '[1, a, 2,
b, c, 3]', but will never be '[1, a, 3, b, c, 2]'.

   A binary (two-input) stream merger can be defined in KL1 as follows.

     merge([M|In1], In2, Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge(In1, [M|In2], Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge([], In2, Out) :- Out=In2.
     merge(In1, [], Out) :- Out=In1.

   * The first clause forwards one message coming from the first input
     stream to the output stream.  The first input stream is the first
     argument and the output stream is the third argument of the
     predicate.  It then calls the predicate 'merge/3' recursively for
     repetitive execution.

   * The second clause does the same for the second input stream.

   * The third clause is used when the first input stream has no more
     messages in it.  In this case, the second input stream is directly
     connected to the output.  As there are no more messages to merge
     from the first input stream, the result of the merging should be
     the same as the second input stream.

   * The fourth clause provides the corresponding feature when the
     second input stream has no more messages in it.

   When messages come from both the first and the second at the same
time, either the first or the second clause is arbitrarily chosen.  This
is the source of the nondeterminacy of the merger.

   Although binary mergers are easy to define in KL1, defining a merger
with arbitrarily many input streams is not so easy.  It is also
desirable to add new input streams dynamically, which makes it still
harder.  Also, mergers are used quite frequently in KL1 programs and
thus should be quite efficient.  Thus, the KLIC system provides a merger
as one of its standard feature.

   A new merger can be created by the following pseudo-predicate.

 -- Object Creation on merge: new ?Input ?Output
     A new merger with single input stream is created.  Its input stream
     is INPUT and its output is OUTPUT.

   The merger process created by the above pseudo-predicate does not
actually start any merging immediately after its creation.  It only
forwards the messages from INPUT to OUTPUT, without changing the order.

   To add a new input stream to a merger, unify the input with a vector
whose elements are input streams.  For example, if you need a binary
merger, do the following.

     generic:new(merge, INPUT, OUTPUT),
     INPUT = {IN1, IN2}

   This means the same as the following.

     generic:new(merge, {IN1, IN2}, OUTPUT)

   After doing the above, the merger will merge messages from two input
streams, IN1 and IN2, to the output stream OUTPUT.

   Input streams to a merger can be added not only immediately after its
creation but at any time on demand.  Two more input streams are added,
for example, by the following.

     IN2 = {IN2A, IN2B, IN2C}

   After this, the merger will have four input streams, IN1, IN2A, IN2B
and IN2C.

   When one of the input streams is no longer needed, that input stream
can be simply closed, by unifying it with an atom '[]'.

   The size of the vector unified with an input stream can be
arbitrarily large or small.  When it has only one element, the number of
input streams will not be changed.  When the vector has no elements,
unifying with it has the same effect as closing the stream.

   The output stream will be closed, i.e., the tail of the output list
is unified with '[]', when all the input streams have been closed.

   Here are some clues in using the merger.

   * Messages merged can be a data structure containing unbound
     variables.  Such messages are sometimes called "incomplete
     messages".  Incomplete messages are convenient for constructing a
     server-client process structure.  Giving values to variables in
     messages can be used for communicating backwards from the server to
     the client.

   * Merging may look deterministic on sequential implementations.  Do
     never rely on it.  It will become really nondeterministic on
     parallel implementations.


File: KLIC.info,  Node: Vectors,  Next: Strings,  Prev: Lists,  Up: Structured Data

3.3.3 Vectors
-------------

Vectors are fixed-length one-dimensional array of KL1 data.  The length
of a vector is determined on its creation.  Elements can be any KL1 data
and can even be left undefined when the data structure is created.

   Elements are indexed by an integer beginning from 0.  For example, a
vector with 3 elements has elements numbered 0, 1 and 2.

* Menu:

* Notation of Vectors::         Constant notation of vectors
* Creating Vectors::            Creating new vectors
* Predicates on Vectors::       Vector manipulation predicates


File: KLIC.info,  Node: Notation of Vectors,  Next: Creating Vectors,  Prev: Vectors,  Up: Vectors

3.3.3.1 Notation of Vectors
...........................

Vectors can be denoted by a comma-separated list of elements in a pair
of curly braces.

     { 1, a, f(b), X }

A null vector (vectors with no elements at all) is denoted only by a
pair of curly braces.

     {}

   Note that curly braces are used in a way completely different from
Edinburgh Prolog, where '{}' means an atom and '{...}' means a functor
structure '{}((...))'.


File: KLIC.info,  Node: Creating Vectors,  Next: Predicates on Vectors,  Prev: Notation of Vectors,  Up: Vectors

3.3.3.2 Creating New Vectors
............................

In addition to the notation described above, vectors can be dynamically
created during program execution.  The following predicate can be used
to create a new vector.

 -- Object Creation on vector: new -Vector +Init
 -- Body Predicate on builtin: new_vector -Vector +Init
     A new vector is created and returned to VECTOR.

     If the argument INIT is an integer, it sepcifies the number of
     elements.  The elements are initialized with integer '0' in this
     case.  For example, 'generic:new(vector, V, 2)' creates a vector
     '{0, 0}' and returned it to 'V'.

     If INIT is a list, the newly created vector is initiated by the
     elements of the list.  Naturally, the number of elements of the
     vector becomes the same as the length of the list.  For example,
     'generic:new(vector, V, [a, b, c])' creates a vector '{a, b, c}'
     and unifies it with 'V'.


File: KLIC.info,  Node: Predicates on Vectors,  Prev: Creating Vectors,  Up: Vectors

3.3.3.3 Predicates on Vectors
.............................

 -- Guard Method on vector: vector +Vector -Length
 -- Body Method on vector: size +Vector -Length
 -- Guard Predicate on builtin: vector +Vector -Length
     Tests whether VECTOR is a vector object (if called in guard) and
     returns the number of elements in LENGTH.

 -- Guard Method on vector: element +Vector +Index -Element
 -- Body Method on vector: element +Vector +Index -Element
 -- Guard Predicate on builtin: vector_element +Vector +Index -Element
 -- Body Predicate on builtin: vector_element +Vector +Index -Element
     An element with index INDEX of the vector VECTOR is unified with
     ELEMENT.  The index is zero origin.

 -- Body Method on vector: set_element +Original +Index ?NewElement -New
 -- Body Predicate on builtin: set_vector_element +Original +Index
          ?NewElement -New
     A new vector is unified with NEW.  The new vector has the same
     elements as the ORIGINAL, except that the INDEX'th element is
     updated to NEWELEMENT.  The original vector is left untouched.  The
     index is zero origin.

 -- Body Method on vector: set_element +Original +Index ?Element
          ?NewElement -New
 -- Body Predicate on builtin: set_vector_element +Original +Index
          ?Element ?NewElement -New
     A new vector is unified with NEW.  The new vector has the same
     elements as the ORIGINAL, except that the INDEX'th element is
     updated to NEWELEMENT.  The original vector is left untouched.  The
     index is zero origin.  The original INDEX'th element is returned to
     ELEMENT.

 -- Body Method on vector: split +Original +At -Lower -Upper
     The vector ORIGINAL is split at the index position AT and the
     resultant two vectors are unified with LOWER and UPPER.  AT has to
     be a non-negative integer less than or equal to the size of the
     original vector.  LOWER will have elements with indices between 0
     and 'AT-1', inclusive.  Elements with indices between AT and up
     will be included in UPPER.

 -- Body Method on vector: join +Lower +Upper -Joined
     Two vectors LOWER and UPPER are concatenated together to make a new
     vector JOINED.

   In KLIC, creating a new vector differing with an existing one by only
a single element is implemented with constant time and space overhead,
regardless of the size of the vector, by using multiversion array
representation.


File: KLIC.info,  Node: Strings,  Prev: Vectors,  Up: Structured Data

3.3.4 Strings
-------------

Strings are one dimensional arrays of integers in restricted range.  The
current version provides only strings of 8-bit elements which has
elements of the range 0 through 255.  They are convenient for
representing character strings.  Strings with elements of different
sizes are planned in future.

   Unlike in Edinburgh Prolog, strings are _not_ notational convention
for lists of character codes.  They are of its own data type.

* Menu:

* Notation of Strings::         Constant notation of strings
* Creating Strings::            Creating new strings
* Predicates on Strings::       String manipulation predicates


File: KLIC.info,  Node: Notation of Strings,  Next: Creating Strings,  Prev: Strings,  Up: Strings

3.3.4.1 Notation of Strings
...........................

In KLIC, character string constants should be denoted by sequence of
characters surrounded by a pair of doublequotes, as follows.

     "A string of the characters written here"

   The following escape sequences (a la ANSI C) are used to specify
doublequotes, backslashes and control codes as string elements.

'\a'
     Bell.
'\b'
     Backspace.
'\t'
     Tab.
'\n'
     Newline.
'\v'
     Vertical tab.
'\f'
     Formfeed.
'\r'
     Carriage return.
'\''
     Singlequote.
'\"'
     Doublequote.
'\?'
     Question mark.
'\\'
     Backslash.  Two consecutive backslach characters specifies a single
     backslash in the string.
'\ooo'
     Code specified by the octal number ooo.  Up to three octal digits
     are recognized.
'\xhh'
     Code specified by the hexadecimal number hh.  Arbitrarily many
     hexadecimal digits may be used.
'\<newline>'
     The backslash character along with the newline code immediately
     following it are ignored.  This sequence results in no characters
     at all in the string.

Example:

     "The character \'\"\' (doublequote)"

The above example is understood as a string containing the following
characters.

     The character '"' (doublequote)

   Strings should not contain newlines nor doublequotes directly.  A
standard way for including newlines within a string is to end the line
with '\n\'.  By this, a new line code is inserted by the sequence '\n'
and the actual newline in the source code following the second '\' is
ignored.

   Unlike in Edinburgh Prolog, character strings are _not_ lists of
character codes.


File: KLIC.info,  Node: Creating Strings,  Next: Predicates on Strings,  Prev: Notation of Strings,  Up: Strings

3.3.4.2 Creating New Strings
............................

In addition to the constant strings described above, strings can be
dynamically created during execution.  The following predicate can be
used to create a new string.

 -- Object Creation on string: new -String +Init +ElemSize
 -- Body Predicate on builtin: new_string -String +Init +ElemSize
     A new string is created and unified with STRING.  The last argument
     ELEMSIZE specifies the bit width of the elements.  As only 8-bit
     strings are available in the current version, this should be 8.

     When the argument INIT is an integer, it sepcifies the number of
     elements.  In this case, the elements are initialized with integer
     '0' (null code).  For example, 'generic:new(string, S, 3, 8)'
     creates '"\0\0\0"'.

     If INIT is a list of integers, the newly created string is
     initiated by the elements of the list.  Naturally, the number of
     elements of the string becomes the same as the length of the list.
     In this case, list elements should have values that fits in the
     given bit width; between 0 and 255 in case of 8-bit strings.  For
     example, 'generic:new(string, S, [0'a, 0'b, 0'c], 8)' creates
     '"abc"'.


File: KLIC.info,  Node: Predicates on Strings,  Prev: Creating Strings,  Up: Strings

3.3.4.3 Predicates on Strings
.............................

 -- Guard Method on string: string +String -Length -ElemSize
 -- Body Method on string: string +String -Length -ElemSize
 -- Guard Predicate on builtin: string +String -Length -ElemSize
     Tests whether STRING is a string object (if called in guard).  The
     number of elements of STRING is returned in LENGTH and the element
     size (which is always 8 in the current version) is returned in
     ELEMSIZE.

 -- Body Method on string: size +String -Length
     Returns the number of elements of STRING in LENGTH.

 -- Body Method on string: element_size +String -ElemSize
     Returns the the element size of STRING in ELEMSIZE.

 -- Guard Method on string: element +String +Index -Element
 -- Body Method on string: element +String +Index -Element
 -- Guard Predicate on builtin: string_element +String +Index -Element
 -- Body Predicate on builtin: string_element +String +Index -Element
     An element with index INDEX of the string STRING is unified with
     ELEMENT.  The index is zero origin.

 -- Guard Method on string: less_than +String1 +String2
 -- Guard Predicate on builtin: string_less_than +String1 +String2
     Succeeds only when STRING1 is less than STRING2 in lexicographical
     order.

 -- Guard Method on string: not_less_than +String1 +String2
 -- Guard Predicate on builtin: string_not_less_than +String1 +String2
     Succeeds only when STRING1 is not less than STRING2 in
     lexicographical order.

 -- Body Method on string: set_element +Original +Index +Element -New
 -- Body Predicate on builtin: set_string_element +Original +Index
          +Element -New
     A new string is unified with NEW.  The new string has the same
     elements as the ORIGINAL, except that the INDEX'th element is
     updated to ELEMENT.  The original string is left untouched.  The
     index is zero origin.

 -- Body Method on string: split +Original +At -Lower -Upper
     The string ORIGINAL is split at the index position AT and the
     resultant two strings are unified with LOWER and UPPER.  AT has to
     be a non-negative integer less than or equal to the size of the
     original string.  LOWER will have elements with indices between 0
     and 'AT-1', inclusive.  Elements with indices between AT and up
     will be included in UPPER.

 -- Body Method on string: join +Lower +Upper -Joined
     Two strings LOWER and UPPER are concatenated together to make a new
     string JOINED.

 -- Body Method on string: search_character +String +Start +End +Char
          -Where
 -- Body Predicate on builtin: search_character +String +Start +End
          +Char -Where
     The character CHAR is searched for in STRING, beginning from the
     position START and ending before END.  If such a character is
     found, its index is unified with WHERE.  If not, Where is unified
     with '-1'.  The indices are zero origin.

   In KLIC, creating a new string differing with only one element from
the original is implemented with constant time and space overhead,
regardless of the size of the string, by using multiversion array
representation.


File: KLIC.info,  Node: Executable Code,  Next: Unix,  Prev: Structured Data,  Up: Builtin and Library

3.4 Handling Program Code as Data
=================================

KLIC allows higher order manipulation of executable code as data
objects.  Program modules are treated as "module" data objects and
individual predicates are treated as "predicate" data objects.

* Menu:

* Module Type::                 Program modules as data
* Predicate Type::              Predicates as data


File: KLIC.info,  Node: Module Type,  Next: Predicate Type,  Prev: Executable Code,  Up: Executable Code

3.4.1 Modules
-------------

Program modules are treated as data through generic data objects of type
'module'.

 -- Object Creation on module: new -Module +ModuleName
     Creates a new object MODULE corresponding to the program module
     specified by MODULENAME as a symbolic atom.  If the specified
     module is not defined, the symbolic atom itself is returned to
     MODULE.  *Note Creating Objects::, for the format of object
     creation goals.

 -- Guard Method on module: module +Module
     Tests whether MODULE is a module object or not.

 -- Body Method on module: name +Module -ModuleName
     The module name of MODULE is returned to MODULENAME as a symbolic
     atom.


File: KLIC.info,  Node: Predicate Type,  Prev: Module Type,  Up: Executable Code

3.4.2 Predicates
----------------

Predicates in programs are treated as data through generic data objects
of type 'predicate'.

   Predicate type data can be either denoted as a constant or created
dynamically in runtime.  Due to limitations of the features of host
systems, dynamic creation may not be supported on some host systems.

   The syntax of a predicate constant is as follows.

     'predicate''#''('MODULE':'PREDICATE'/'ARITY')'

Where MODULE and PREDICATE should be module and predicate name atoms and
ARITY should be an integer (the number of arguments of the predicate).
For example:

     predicate#(main:main/0)  predicate#(quicksort:partition/4)

are valid predicate constants in programs.

   Note that predicate constants are recognized by the KLIC compiler and
not by the KLIC parser (*note Input and Output with Prolog-like
Interface: Prolog I/O.). Thus, the notation described above means a
usual data structure when simply read in using the Prolog-like I/O
streams.

 -- Object Creation on predicate: new -Predicate +Module +PredName
          +Arity
     Creates a new object PREDICATE corresponding to the predicate
     specified by MODULE (a module object), PREDNAME (a symbolic atom)
     and ARITY (an integer).  *Note Creating Objects::, for the format
     of object creation goals.

 -- Guard Method on predicate: predicate +Predicate
     Tests whether PREDICATE is a predicate object or not.

 -- Guard Method on predicate: arity +Predicate -Arity
 -- Body Method on predicate: arity +Predicate -Arity
     The arity of the predicate PREDICATE is returned to ARITY.

 -- Body Method on predicate: apply +Predicate +ArgVec
     Calls the predicate specified by a predicate object PREDICATE with
     arguments specified by ARGVEC.  ARGVEC should be a vector of
     arguments to be passed to PREDICATE.  Thus, the size of the vector
     should match with the arity of the predicate.

 -- Body Method on predicate: call +Predicate +Args...
     Calls the predicate specified by a predicate object PREDICATE with
     arguments specified by 'ARGS...'.  The number of the arguments
     should match with the arity of the predicate.

 -- Body Method on predicate: module +Predicate -Module
     The program module that PREDICATE belongs to is returned to MODULE
     as a module data object.

 -- Body Method on predicate: name +Predicate -Name
     The name of the predicate PREDICATE is returned to NAME as a
     symbolic atom.


File: KLIC.info,  Node: Unix,  Next: Input and Output,  Prev: Executable Code,  Up: Builtin and Library

3.5 Unix Interface
==================

The module named 'unix' makes features of the host operating system
(Unix, typically) available to KL1 programs.

   Almost all of the features are available as messages to a stream
obtained by a predicate 'unix/1' provided by the module 'unix'.  Some
features are provided directly by predicates of the module.

* Menu:

* Unix Stream::                 Obtaining Unix interface stream
* I/O Opening::                 Opening input/output streams
* Sockets::                     Internet- and Unix-domain protocol sockets
* Files & Dirs::                Manipulation of files and directories
* Signals::                     Signal interrupt handling
* Misc Unix Messages::          Miscellaneous messages to the Unix stream
* Predicate Interface::         Predicate interface for command line args &c


File: KLIC.info,  Node: Unix Stream,  Next: I/O Opening,  Prev: Unix,  Up: Unix

3.5.1 Obtaining Unix Interface Stream
-------------------------------------

The module "unix" interfaces other programs through message streams.
The stream can be obtained by calling the following predicate.

 -- Predicate on unix: unix ?Stream
     A message stream corresponding to the Unix interface is returned to
     STREAM.

   Most of the features of the Unix interface are _not_ provided as
predicates, because no ordering is guaranteed between predicate calls.

   If the Unix interface _were_ provided as predicates, for example:

     unix:cd("a", 0),
     unix:cd("b", 0),
     unix:system("mkdir ls", 0)

may list the directory 'a' but may possibly list 'b' or even some other
directory before doing any 'cd', depending on the execution order.  On
the other hand:

     unix:unix([cd("a", 0),
                cd("b", 0),
                system("ls", 0)])

will surely try two 'cd' and 'ls' in this order, as what decides the
order is not the order of execution but the order of the elements in a
list structure.

   On parallel implementations, KLIC consists of multiple processes.
The process in which the unix stream is obtained will be the process
where all the messages are handled.  For example, 'cd(Path)' message
will change working directory of that single process and none of others.

   If you obtain two or more message streams, there will be no automatic
synchronization between messages sent to different streams.


File: KLIC.info,  Node: I/O Opening,  Next: Sockets,  Prev: Unix Stream,  Up: Unix

3.5.2 Opening Streams for Input and Output Operations
-----------------------------------------------------

The following messages to the Unix stream open a Unix I/O stream.
Messages to be sent to the resulting Unix I/O streams (_not_ the Unix
stream stream itself) for actually performing I/O are described in
separate places: *Note Input and Output with C-like Interface: C-like
I/O, and *note Input and Output with Prolog-like Interface: Prolog I/O.

   The following is a KLIC program for saying hello to the world.

     main :- unix:unix([stdout(R)]), check_and_write(R).

     check_and_write(normal(R)) :- R = [fwrite("hello world\n")].

 -- Message on unix stream: stdin -Result
 -- Message on unix stream: stdout -Result
 -- Message on unix stream: stderr -Result
     These messages open a stream associated with process's standard
     input, standard output and standard error file respectively, and
     return 'normal(STREAM)' to RESULT.

 -- Message on unix stream: read_open +Path -Result
 -- Message on unix stream: write_open +Path -Result
 -- Message on unix stream: append_open +Path -Result
 -- Message on unix stream: update_open +Path -Result
     These messages open the file named by the string PATH, and return
     'normal(STREAM)' to RESULT.  The opening mode is input, output,
     append or input/output, respectively.  If opening of the file
     fails, 'abnormal' is returned instead.


File: KLIC.info,  Node: Sockets,  Next: Files & Dirs,  Prev: I/O Opening,  Up: Unix

3.5.3 Using Sockets
-------------------

Unix- and Internet-protocol sockets can be obtained using the following
messages to the Unix stream.  Only sockets of SOCK_STREAM type are
provided.

 -- Message on unix stream: connect +Spec -Result
     Creates a socket and connects it to socket specified by SPEC and
     returns 'normal(STREAM)' to RESULT.  SPEC should have either of the
     following formats.

     unix(PATH)
          A unix domain socket with the pathname PATHis opened.
     inet(HOSTNAME, PORT)
          An internet domain socket of the host specified by a string
          HOSTNAME and port number PORT is opened.
     inet({B1, B2, B3, B4}, PORT)
          An internet domain socket is opened.  The host is specified by
          the internet address B1 through B4 is opened.
     The obtained stream handles both input and output messages.

 -- Message on unix stream: bind +Spec -Result
     Creates a socket and binds it to a name specified by SPEC.  The
     format of SPEC is the same for the message 'connect' _except_ that
     HOSTNAME should be omitted for internet domain sockets.  What is
     returned to RESULT is 'normal(STREAM)' but this STREAM is a bound
     socket stream and does not directly handle I/O messages.  Rather,
     it expects 'accept' messages to obtain I/O message streams.  When
     the bound socket stream obtained is closed and the socket type is
     'unix', the named socket specified by PATH in SPEC will be
     unlinked.

 -- Message on bound socket: accept -Result
     Accepts a connection to the socket and returns 'normal(STREAM)' to
     RESULT, where STREAM is an I/O message stream for both input and
     output messages.

   Sockets provide asynchronous I/O, that is, waiting for a connection
or acceptance of a connection will not block other processes in the KLIC
system.  Trying to read or write to sockets with buffers empty or full
respectively will not block the whole computation.  Such I/O operations
will be postponed until immediate operations become possible.

   *Limitations:* When an operation on a socket is postponed, all the
remaining operations to be done on the socket are also postponed until
the completion of the postponed operation.  This is problematic when
both input and output has to be polled.  The problem is planned to be
solved in a future release.

   *Limitations on Linux:*Asynchronous I/O operations do not work on
Linux (at least with Slackware 1.2.0) with the current version.


File: KLIC.info,  Node: Files & Dirs,  Next: Signals,  Prev: Sockets,  Up: Unix

3.5.4 Files and Directories
---------------------------

The following message to the unix stream handles files and directories.

 -- Message on unix stream: cd +Path -Result
     Changes the working directory to PATH.  If successful, '0' is
     returned to RESULT; otherwise, '-1' is returned.  Corresponds to
     'chdir' system call.

 -- Message on unix stream: unlink +Path -Result
     Removes the directory entry specified by PATH.  If successful, '0'
     is retuned to RESULT; otherwise, '-1' is returned.  Corresponds to
     'unlink' system call.

 -- Message on unix stream: mktemp +Template -Filename
     Makes a unique file name from the given TEMPLATE and returns it to
     FILENAME.  Corresponds to the C library routine 'mktemp'.  Unlike
     the library routine, the template does _not_ have to have six
     trailing 'X' characters.  If a unique file name cannot be created
     somehow, a null string is returned to FILENAME.

 -- Message on unix stream: access +Path +Mode -Result
     Checks accessibility of the file with pathname PATH with the mode
     MODE is validate, and returns the result to RESULT.  Corresponds to
     the C library routine 'access'.  If the file is accessible, '0' is
     returned; otherwise, '-1' is returned.  MODE is an integer, with
     the bits of the following meaning.

     4
          read permission
     2
          write permission
     1
          execute permission
     0
          test existence

 -- Message on unix stream: chmod +Path +Mode -Result
     Changes the permission mode of the file with pathname PATH to MODE.
     Corresponds to the system call 'chmod'.  If changing the mode is
     successful, '0' is returned to RESULT; otherwise, '-1' is returned.
     MODE is an integer with standard Unix permission bits.

 -- Message on unix stream: umask -OldMask
 -- Message on unix stream: umask -OldMask +NewMask
     Returns the current file creation mask to OLDMASK.  With two
     arguments, sets the file creation mask to NEWMASK.  Corresponds to
     the 'umask' system call.


File: KLIC.info,  Node: Signals,  Next: Misc Unix Messages,  Prev: Files & Dirs,  Up: Unix

3.5.5 Handling Signal Interrupts
--------------------------------

Unix signals can be converted to a list of integers using the following
message to the unix stream.

 -- Message on unix stream: signal_stream +Signal -Result
     Unix signals specified by SIGNAL (an integer value) will become
     caught and reported.  The argument RESULT will become
     'normal(Stream)' and whenever a signal of the specified kind is
     detected, that signal number is sent to Stream.  For example, if
     signal 2 (SIGINT in BSD and SVR4, at least) is detected, Stream
     becomes '[2|REST]'.  Further signals are reported to REST.

*Limitations:* Signals may be ignored when they occur more than twice
before the same kind of signal is detected, due to limitations of Unix.


File: KLIC.info,  Node: Misc Unix Messages,  Next: Predicate Interface,  Prev: Signals,  Up: Unix

3.5.6 Miscellaneous Messages to the Unix Stream
-----------------------------------------------

Various features of Unix are provided by sending the fllowing messages
to the unix stream.

 -- Message on unix stream: system +Command -Result
     Executes COMMAND (a string) in a newly created subshell, and
     returns its exit code to RESULT.  Corresponds to the 'system'
     system call.

 -- Message on unix stream: getenv +Name -Value
     Returns the value of the environment variable with the name NAME to
     VALUE.  Corresponds to the library routine 'getenv'.  If such a
     environment variable does not exist, integer '0' is returned to
     VALUE.

 -- Message on unix stream: putenv +String -Result
     The first argument STRING should be of form 'NAME = VALUE'.  Adds
     or updates the environment variable NAME with the value VALUE.
     Corresponds to the library routine 'putenv'.  If addition or
     updating is successful, '0' is returned to RESULT.  Otherwise,
     non-zero integer value is returned.

 -- Message on unix stream: kill +Pid +Sig -Result
     Sends the signal SIG to a process or a group of processes specified
     by PID, and returns '0' on success or '-1' on failure to RESULT.

 -- Message on unix stream: fork -Pid
     Forks a new process which is a copy of the current process.
     Corresponds to the 'fork' system call.  If a child process is
     successfully created, the process ID of the child process is
     returned to PID in the parent process, and '0' is returned in the
     child process.

 -- Message on unix stream: fork_with_pipes -Result
     Creates pipes and fork a new process.  The new process is a copy of
     the current process.  In the parent process, RESULT is unified with
     'parent(PID, IN, OUT)', where PID is the process ID of the newly
     created process.  In the newly create child process, RESULT is
     unified with 'child(IN, OUT)'.  IN and OUT are Unix I/O streams to
     pipes; parent's OUT is an output stream connected to child's IN,
     which is an input stream; child's OUT is connected to parent's IN.


File: KLIC.info,  Node: Predicate Interface,  Prev: Misc Unix Messages,  Up: Unix

3.5.7 Predicate Interface
-------------------------

Some of the Unix interface are provided as predicates defined in the
module 'unix'.

 -- Predicate on unix: argc -Argc
     Number of command line arguments not used by the KLIC system is
     returned to ARGC.  Such arguments start from the first argument not
     beginning with '-' or after '--' in the command line.

 -- Predicate on unix: argv -ArgList
     Command line arguments nod used by the KLIC system is returned to
     ARGLIST as a list of strings.

 -- Predicate on unix: exit +ExitCode
     Terminates the process immediately with the exit code EXITCODE.

 -- Predicate on unix: times -Utime -Stime -CUtime -CStime
     Returns process times in milliseconds.  UTIME is user time and
     STIME is system time.  CUTIME and CSTIME are those for children
     processes.

     Note that when 'HZ' (clock ticks per second) is not defined in some
     standard places, the system assumes 60.


File: KLIC.info,  Node: Input and Output,  Next: System Control,  Prev: Unix,  Up: Builtin and Library

3.6 Input and Output
====================

KLIC provides two different sets of I/O operations.  One is similar to
those available from C language and the other is similar to those
available from Prolog language.

   C-like features are in a lower level and provide better performance
both in speed and code size.  However, during prototyping and debugging
phases, the Prolog-like higher-level interface, allowing I/O of data
structures directly, might be beneficial.

* Menu:

* C-like I/O::                  I/O with C language-like interface
* Prolog I/O::                  I/O with Prolog language-like interface


File: KLIC.info,  Node: C-like I/O,  Next: Prolog I/O,  Prev: Input and Output,  Up: Input and Output

3.6.1 Input and Output with C-like Interface
--------------------------------------------

Input and output operations with interface similar to those available in
language C are described in this section.

   Such interface are provided as messages to streams to open files,
sockets, pipes &c, which are obtained by various messages to the Unix
stream.  *Note Opening Streams for Input and Output Operations: I/O
Opening.

* Menu:

* Common Msgs (C style)::       Messages common to both input and output
* Input Msgs (C style)::        Messages for C-like input streams
* Output Msgs (C style)::       Messages for C-like output streams


File: KLIC.info,  Node: Common Msgs (C style),  Next: Input Msgs (C style),  Prev: C-like I/O,  Up: C-like I/O

3.6.1.1 Common Messages with C-like Interface
.............................................

The following messages are available for both input and output streams
for C-like I/O.

 -- Message on C-like I/O: feof -Result
     Returns '1' to RESULT if the stream is at the end of the file;
     otherwise '0'.  Corresponds to the library routine 'feof'.

 -- Message on C-like I/O: fseek +Offset +Ptrname -Result
     Changes the position of the stream according to the offset and
     pointer name given as OFFSET and PTRNAME, respectively.  The offset
     is specified as a signed integer by OFFSET.  When PTRNAME is 0, the
     offset is from the beginning of the file; when 1, from the current
     position; when 2, from the end of file.  If successful, '0' is
     returned RESULT; otherwise '-1'.

     Note that, due to the range restriction of integer values, this
     message may not be able to move to arbitrary positions in a very
     large file (larger than 128MB, on systems with 32-bit long
     integers).

 -- Message on C-like I/O: ftell -Result
     Returns the offset of the current byte position to RESULT.

     Note that, due to the range restriction of integer values, the
     obtained position may be incorrect for a very large file (larger
     than 128MB, on systems with 32-bit long integers).

 -- Message on C-like I/O: fclose -Result
     Closes the stream.  Returns '0' to RESULT if successful; '-1'
     otherwise.  No messages except for 'sync/1' should be sent to a
     stream after closing.

 -- Message on C-like I/O: sync -Result
     Returns '0' to RESULT.  Useful in making sure that all the
     preceding messages have already been processed.


File: KLIC.info,  Node: Input Msgs (C style),  Next: Output Msgs (C style),  Prev: Common Msgs (C style),  Up: C-like I/O

3.6.1.2 Input Messages with C-like Interface
............................................

The following messages are available for input streams for C-like I/O.

 -- Message on C-like I/O: getc -C
     Reads one byte from the stream and returns it to C.  At the end of
     file, '-1' is returned.

 -- Message on C-like I/O: ungetc +C
     Pushes back one byte C to the stream.

 -- Message on C-like I/O: fread +Max -String
     Reads in at most MAX bytes from the stream and returns the data as
     a byte string to STRING.  Only up to 4,096 bytes can be handled in
     the current implementation.  Note that the length of the resultant
     string may be smaller than the given maximum.  This may happen at
     the end of the file for normal files and at any time for pipes or
     sockets.

 -- Message on C-like I/O: linecount -Count
     Returns to COUNT the number of newline characters encountered so
     far.  Within the first line of a file, it returns '0', as no
     newlines have been encountered yet.  Conventional one-origin line
     numbers can be computed by adding one to this.

     This line counting can be confused when 'fseek/2' messages are
     used.


File: KLIC.info,  Node: Output Msgs (C style),  Prev: Input Msgs (C style),  Up: C-like I/O

3.6.1.3 Output Messages with C-like Interface
.............................................

The following messages are available for output streams for C-like I/O.

 -- Message on C-like I/O: putc +C
     Writes one byte C to the stream.

 -- Message on C-like I/O: NUMBER
     Writes one byte NUMBER to the stream.  This is synonymous to
     'putc(NUMBER)'.

 -- Message on C-like I/O: fwrite +String -Result
     Writes out the contents of the byte string STRING to the stream and
     returns number of bytes actually written to RESULT.  Note that the
     number of bytes actually written may be smaller than the length of
     STRING.

 -- Message on C-like I/O: fwrite +String
     Writes out the contents of the byte string STRING to the stream.
     Unlike the 'fwrite' message with RESULT argument, it waits for all
     the bytes in STRING to be output.  This may be undesirable for
     streams that require unpredictable time period for output, such as
     internet sockets and pipes.

 -- Message on C-like I/O: fflush -Result
     Flushes any output remaining on the stream.  Returns '0' to RESULT
     if successful; '-1' otherwise.


File: KLIC.info,  Node: Prolog I/O,  Prev: C-like I/O,  Up: Input and Output

3.6.2 Input and Output with Prolog-like Interface
-------------------------------------------------

Unix interface streams with features to handle Prolog-like terms based
on a operator precedence grammar can be obtained by the following
predicate of module 'klicio'.

   The syntax of terms of KLIC is very close to that of Edinburgh Prolog
but with subtle differences.  *Note Notation of Atoms::, *note Notation
of Integers::, *note Notation of Floats::, *note Notation of Functors::,
*note Notation of Lists::, *note Notation of Vectors::, and *note
Notation of Strings::, for details.

* Menu:

* Opening Prolog I/O::          Opening Prolog-like I/O streams
* Common Msgs (Prolog style)::  Message common to input and output streams
* Input Msgs (Prolog style)::   Input messages with Prolog-like interface
* Output Msgs (Prolog style)::  Output messages with Prolog-like interface
* Wrapped Terms::               Manipulation of wrapped terms


File: KLIC.info,  Node: Opening Prolog I/O,  Next: Common Msgs (Prolog style),  Prev: Prolog I/O,  Up: Prolog I/O

3.6.2.1 Opening Prolog-like I/O Streams
.......................................

 -- Predicate on klicio: klicio ?Stream
     A message stream corresponding to the Prolog-like term interface is
     returned to STREAM.  The obtained stream works the similar to a
     unix interface stream, which is used in turn to obtain message
     streams for actual I/O. I/O streams obtained through this stream
     accepts messages for Prolog-like term I/O described in this section
     in addition to ordinary C-like I/O messages.

     This 'klicio' stream is provided separately so that programs
     _without_ the need of Prolog-like term I/O can be executable
     without modules for parsing and unparsing, as these modules have
     non-negligible sizes.

 -- Message on klicio stream: stdin -Result
 -- Message on klicio stream: stdout -Result
 -- Message on klicio stream: stderr -Result
 -- Message on klicio stream: read_open +Path -Result
 -- Message on klicio stream: write_open +Path -Result
 -- Message on klicio stream: append_open +Path -Result
 -- Message on klicio stream: update_open +Path -Result

     These messages open Prolog-like I/O streams.  Messages to be sent
     to the resulting Prolog-like I/O streams (_not_ the 'klicio' stream
     itself) for actually performing I/O are described below.

     These messages work exactly the same as the corresponding messages
     for 'unix' streams, except that returned I/O streams understand
     messages for Prolog-like term I/O _in addition to_ the messages for
     C-like I/O streams.

     Prolog-like I/O streams are associated with operator definitions.
     Different operator definitions may be associated with each stream.
     Thus, adding or removing an operator to one stream will _not_
     affect operators used in other streams.  Immediately after
     creation, each stream has a default set of operators.


File: KLIC.info,  Node: Common Msgs (Prolog style),  Next: Input Msgs (Prolog style),  Prev: Opening Prolog I/O,  Up: Prolog I/O

3.6.2.2 Common Messages with Prolog-like Interface
..................................................

The following messages for C-like I/O streams can be used for
Prolog-like I/O streams.

 -- Message on Prolog-like I/O: feof -Result
 -- Message on Prolog-like I/O: fseek +Offset +Ptrname -Result
 -- Message on Prolog-like I/O: ftell -Result
 -- Message on Prolog-like I/O: fclose -Result
 -- Message on Prolog-like I/O: sync -Result
     *Note Common Messages with C-like Interface: Common Msgs (C style),
     for details.

 -- Message on Prolog-like I/O: addop +Op +Type +Prec
     Adds an operator OP of type TYPE with precedence PREC.

 -- Message on Prolog-like I/O: rmop +Op +Type
     Removes an operator OP of type TYPE.


File: KLIC.info,  Node: Input Msgs (Prolog style),  Next: Output Msgs (Prolog style),  Prev: Common Msgs (Prolog style),  Up: Prolog I/O

3.6.2.3 Input Messages with Prolog-like Interface
.................................................

 -- Message on Prolog-like I/O: gett -Term
     Reads in a KLIC syntax term from the associated input stream to
     TERM.  On parsing errors, a message is output to 'stderr' and
     another term is read in.  At the end of the file, it returns an
     atom 'end_of_file'.

 -- Message on Prolog-like I/O: getwt -Result
     Reads in a KLIC syntax term from the associated input stream and
     returns the result to RESULT.  RESULT will have the form
     'normal(WRAPPEDTERM)' if parsing completes without errors.  Here,
     WRAPPEDTERM is a ground term representation of the term read in,
     where variables are represented as a ground term with the
     information on their names.  On parsing errors, a message is output
     to 'stderr' and another term is read in.  At the end of file, it
     returns 'normal(end_of_file)'.

     *Note Wrapped Terms:: for manipulation of wrapped terms.

   The following messages for C-like I/O streams can also be used for
Prolog-like I/O streams.

 -- Message on Prolog-like I/O: getc -C
 -- Message on Prolog-like I/O: ungetc +C
 -- Message on Prolog-like I/O: fread +Max -String
 -- Message on Prolog-like I/O: linecount -Count
     *Note Input Messages with C-like Interface: Input Msgs (C style),
     for details.


File: KLIC.info,  Node: Output Msgs (Prolog style),  Next: Wrapped Terms,  Prev: Input Msgs (Prolog style),  Up: Prolog I/O

3.6.2.4 Output Messages with Prolog-like Interface
..................................................

 -- Message on Prolog-like I/O: putt +Term
 -- Message on Prolog-like I/O: puttq +Term
 -- Message on Prolog-like I/O: putwt +WrappedTerm
 -- Message on Prolog-like I/O: putwtq +WrappedTerm
     A term TERM or a wrapped term WRAPPEDTERM is written out to the
     associated output stream.

     Messages _without_ the character 'q' are supposed to omit two
     quotes around symbolic atoms even when they are required to be
     correctly read in again.  However, currently they work exactly the
     same as the messages with 'q'.

     With the current version, the output format is meant only to be
     machine-readable and not so readable for humans.  That is, no
     operators are used and all atoms are enclosed within parentheses.

     *Note Wrapped Terms:: for manpulation of wrapped terms.

   The following messages for C-like I/O streams can also be used for
Prolog-like I/O streams.

 -- Message on Prolog-like I/O: putc +C
 -- Message on Prolog-like I/O: NUMBER
 -- Message on Prolog-like I/O: fwrite +String -Result
 -- Message on Prolog-like I/O: fwrite +String
 -- Message on Prolog-like I/O: fflush -Result
     *Note Output Messages with C-like Interface: Output Msgs (C style),
     for details.

   Note that a period to end a term is not written out by these
messages.  Thus, writing out a period and a space or a newline character
is usually required for the output to be read in again.  The following
goal sequence opens the file named '/tmp/foo.bar', waits full
instantiation of the variable X, and then outputs the value in a
Prolog-like format followed by a period and a newline.

     klicio:klicio([write_open("/tmp/foo.bar", normal(S))]),
     S = [putt(X), putc(0'.), nl].

 -- Message on Prolog-like I/O: nl
     Outputs a newline code.  This is synonymous to sending a message
     'putc(10)' to the same stream.

   Note that Prolog-like I/O streams also accept all the messages
accepted by C-like I/O such as 'putc/1' or 'getc/1' (*note Input and
Output with C-like Interface: C-like I/O.).


File: KLIC.info,  Node: Wrapped Terms,  Prev: Output Msgs (Prolog style),  Up: Prolog I/O

3.6.2.5 Wrapped Terms
.....................

To allow metalevel manipulation of terms including variables, KLIC
provides a data representation called "wrapped term".  A wrapped term is
a ground term without any variables in it.  A wrapped term has one of
the following forms.

variable(VARNAME)
     a variable with its name string VARNAME
atom(ATOM)
     a symbolic atom ATOM
integer(INT)
     an integer INT
floating_point(FLOAT)
     a floating point number FLOAT
list([CAR|CDR])
     a cons cell consisting of CAR and CDR, which are wrapped terms
     recursively
functor(FUNCTOR(ARG, ...)
     a functor structure; its arguments (ARG, etc) are wrapped terms
     recursively
vector({ELEM, ...})
     a vector; its elements (ELEM, etc) are wrapped terms recursively
string(STR)
     a string STR
unknown(TERM)
     some unknown data; wrapping may be inprecise in this case

   For example, the wrapped representation of a term:

     f(a, X, {3, ["abc"|X]}, 3.14)

is the following.

     functor(f(atom(a),
             variable("X"),
             vector({integer(3), list([string("abc")|variable("X")])}),
             floating_point(3.14))).

   The following predicate convert wrapped terms to normal terms.

 -- Predicate on variable: unwrap -Wrapped ?Term
     Converts a wrapped term WRAPPED to a normal term TERM.

   Wrapped terms are normally obtained as a result of input operations
(*note Input Messages with Prolog-like Interface: Input Msgs (Prolog
style).).  Wrapped terms can also be constructed by usual user programs,
as they are nothing more than a usual KL1 term.  The following predicate
that converts normal terms to wrapped terms may also be useful in
certain cases.

 -- Predicate on variable: wrap ?Term -Wrapped
     Converts a normal term TERM to a wrapped term WRAPPED.

     In the current version, all variables are given the same name '_'.
     Thus, by wrapping a term and then unwrapping its result, all the
     variables in the original term will become references to the same
     variable.  This is a bug and is planned to be fixed in a future
     version.

     When TERM contains multiple references of a same variable,
     computation on-going concurrently may instantiate the variable.  In
     such cases, this predicate may yield a wrapped term in which two
     original occurrences of the same variable are converted
     differently; one as a variable and another as a non-variable term.
     This is an inherent problem of the specification of this predicate
     and probably will never be fixed.  Thus, applying this predicate to
     non-ground terms should be restricted to certain metalevel
     programs, such as debugging utilities.


File: KLIC.info,  Node: System Control,  Next: Timer,  Prev: Input and Output,  Up: Builtin and Library

3.7 Controlling System Behavior
===============================

The following predicates are provided in the module 'system_control'.

 -- Predicate on system_control: postmortem +Module +Goal -Result
     Registers postmortem processing after normal or abnormal
     termination of the main program.  GOAL should be a functor
     structure specifying the predicate and arguments of the postmortem
     processing goal.  MODULE should be a symbolic atom specifying the
     module of the postmortem processing predicate.  Only a single goal
     can be specified; comma-separated sequences of goals are not
     allowed.

     When the registration is done, RESULT is unified with '[]'.
     Waiting for this will prevent further processing to be executed
     before the completion of the registration.

     If this predicate is called many times, the last registration will
     be effective.

 -- Predicate on system_control: gc -Before -After
     Requests garbage collection and returns the heap size in words
     before and after the garbage collection to BEFORE and AFTER
     respectively.  The size of a word is the same as the size of type
     'long' of the C language system used in the installation.

     In parallel implementations, only garbage collection for local
     storage is requested.  Requesting of global garbage collection is
     not available.


File: KLIC.info,  Node: Timer,  Next: Random Numbers,  Prev: System Control,  Up: Builtin and Library

3.8 Timer
=========

KLIC provides real-time timers.  Although Unix provides only one timer
per process, KLIC virtualizes the mechanism and provides as many timers
as needed.

   Implementations on host systems where real-time timers are not
available do not provide the feature.

   Time values (both times and time intervals) are represented by a term
of the form 'time(DAY, SEC, USEC)', where DAY, SEC and USEC are
non-negative integers representing days, seconds and microseconds.  SEC
should be less than 86,000 (one day) and USEC should be less than
1,000,000 (one second).

   The following predicates are provided in the module 'timer'.

 -- Predicate on timer: get_time_of_day -Time
     The current time expressed in seconds and microseconds since
     midnight of January 1, 1970 GMT is returned to TIME.

     The time obtained is that of when a goal of this predicate is
     actually executed.  Note that ordering of goal execution is up to
     the KLIC system.  The time reported is only guaranteed to be the
     time between two observable events: when the parent goal of this
     goal is reduced, and when the value of TIME is inspected.

     Note also that the reported time is what is returned by the
     underlying operating system of the worker task.  On a distributed
     system, clocks of constituting systems may not agree completely.

 -- Predicate on timer: add Time1 Time2 -Time
 -- Predicate on timer: sub Time1 Time2 -Time
     Computes sum and difference of two time values, respectively.

 -- Predicate on timer: compare Time1 Time2 -Result
     Compares two time values TIME1 and TIME2 and returns the result in
     RESULT.  The result is '<' if TIME1 is smaller than (or before)
     TIME2, '=' if they are the same, '>' if TIME1 is larger than (or
     after) TIME2.

 -- Predicate on timer: instantiate_at Time -Var
 -- Predicate on timer: instantiate_after Interval -Var
     Unifies VAR with a symbolic atom '[]' at the time specified.  The
     former predicate does this _at_ the specified time, while the
     latter does this _after_ the specified time interval.  If the
     specified time has already passed, the variable may be instantiated
     immediately.

     Note that instantiation may be delayed arbitrarily long.
     Reasonable implementations should have short delays.

 -- Predicate on timer: instantiate_every Interval Stop -Var
     Incrementally instantiate VAR with a list of symbolic atom '[]'.
     The first element is instantiated after the time interval
     specified, the second after time twice the specified value, etc.
     It will be repeated forever unless the argument STOP becomes
     instantiated, on that occasion, the list will be terminated.

     Note that instantiation may be delayed arbitrarily long.
     Reasonable implementations should have short delays.


File: KLIC.info,  Node: Random Numbers,  Prev: Timer,  Up: Builtin and Library

3.9 Random Number Generator
===========================

Pseudo-random numbers can be generated using the object class
'random_numbers'.  This random number generator is based on 'nrand48'.
The random number genrator feature is not availble if 'nrand48' is not
on the host system.

 -- Object Creation on random_numbers: new -Randoms Range
 -- Object Creation on random_numbers: new -Randoms Range Seed
     An infinitely long list of pseudo-random integers ranging between 0
     and RANGE - 1, inclusive, is returned to RANDOMS.  RANGE should be
     a positive integer.  The optional argument SEED specifies the seed
     for random number generation.  The list elements are guaranteed to
     be the same if the same seed is given.

     Note that, although the list is virtually infinite, elements are
     computed lazily on demand as programs incrementally inspect their
     values.


File: KLIC.info,  Node: Using KLIC,  Next: Type Index,  Prev: Builtin and Library,  Up: Top

4 Using KLIC
************

This chapter describes how to use the KLIC system.

* Menu:

* Compiling::                   How to compile KL1 programs
* Running::                     How to run programs compiled with KLIC
* Tracing::                     Tracing execution for debugging
* Install::                     Installation of KLIC
* Distributed KLIC::
* Shared-Memory KLIC::


File: KLIC.info,  Node: Compiling,  Next: Running,  Prev: Using KLIC,  Up: Using KLIC

4.1 Compiling Programs with KLIC
================================

After proper installation, KL1 programs can be compiled into C program
and then to executables by the command 'klic'.  'klic' is a compiler
driver that allows various options.

* Menu:

* Command for Compilation::     Program compilation command
* Compiler Options::            Compiler options
* Mechanism of Compilation::    How programs are compiled


File: KLIC.info,  Node: Command for Compilation,  Next: Compiler Options,  Prev: Compiling,  Up: Compiling

4.1.1 Command for Compilation
-----------------------------

By simply running 'klic' command with the name of KL1 program source
file with the trailing '.kl1' as an argument, that program will be
compiled into C and then to an executable format.

   For example, to compile 'XXX.kl1', type in:

     % klic XXX.kl1

   The compilation result will be found in 'a.out'.  If you want the
compilation result to be named 'YYY', do the following.

     % klic -o YYY XXX.kl1

   If your program is divided into several files, say 'XXX.kl1',
'YYY.kl1' and 'ZZZ.kl1', you can compile and link them together by the
following.

     % klic XXX.kl1 YYY.kl1 ZZZ.kl1

   It is also possible to separately compile several KL1 source files
and link them afterwards.  To avoid linkage errors, you have to stop
before linkage by giving the '-c' flag, as follows.

     % klic -c XXX.kl1
     % klic -c YYY.kl1
     % klic -c ZZZ.kl1

   Finally, you have to link all of them together by the following.

     % klic XXX.o YYY.o ZZZ.o

   See *Note Compiler Options::, for details of compilation flags.

   If you want to link program pieces written directly in C, say 'CCC.c'
and 'DDD.c', with pieces written in KL1, 'XXX.kl1' and 'YYY.kl1', simply
do the following.

     % klic CCC.c DDD.c XXX.kl1 YYY.kl1

   The order of files specified does not matter.  C functions can be
invoked from within inline-expanded codes (*note Inline C Code::).


File: KLIC.info,  Node: Compiler Options,  Next: Mechanism of Compilation,  Prev: Command for Compilation,  Up: Compiling

4.1.2 Compiler Options
----------------------

Options available for the compilation command 'klic' are listed below.

-c
     Stop after generating relocatable object and don't link the
     program.

-C
     Stop after translation into C.

-d
     Don't try any compilation (dry run).  Implies '-v'.

-D DATABASE_MANAGER
     Use the specified database manager program.

-g
     Debug flag passed to the C compiler.

-I DIRECTORY
     Use the additional include directory specified for C compilation.

-K KLIC_COMPILER
     Use the speicfied KL1 to C translator program.

-l LIBRARY
     Use the additional library specified for linking.

-L DIRECTORY
     Use the additional directory specified to be searched for '-l'.

-o FILE
     Use the file name for the generated executable file.

-O
-OLEVEL
     Use the specified optimization level.  When a non-zero optimization
     level is specified, some additional optimization flags may be also
     passed to the C compiler.  Such Additional optimization flags are
     system dependent and determined on KLIC system installation
     procedure.

     For this option, no spaces are allowed between '-O' and LEVEL.

-P PARALLEL
     Run subtasks (C compilers &c) in parallel.  At most PARALLEL
     subtasks are forked at a time.

-R
     Do recompilation regardless of file dates.

-S
     Stop after generating assembly code output.

-n
     Link with the non-debugging version of the runtime library.  By
     default, the debugging version is used.

-v
     Run in verbose mode.  All the commands executed through the
     compielr driver will be output to standard error.

-xDIRECTORY
     Use database file 'klic.db' in the specified directory and also
     place 'atom.c', 'funct.c' and 'predicates.c' and their
     corresponding objects in the same directory.  This flag is useful
     when programs to be linked together are distributed to multiple
     directories.

-XDIRECTORY
     Initiate the database file 'klic.db' from the database initiation
     file 'klicdb.init' under the specified directory, when the database
     file does not exist yet.  It defaults to the default library
     directory.

   The following environment variables can change the default behavior
of the compiler.  Options given at compilation time supersede the
environment variable values.

KLIC_LIBRARY
     Directory for runtime libraries.  Superseded by the '-X' option.

KLIC_DBINIT
     Directory for initial database.  Defaults to the directory for
     runtime libraries.

KLIC_COMPILER
     KL1 to C translator program.  Superseded by the '-K' option.

KLIC_DBMAKER
     Database manager program.  Superseded by the '-D' option.

KLIC_INCLUDE
     Additional include directory for C compilation.  Superseded by the
     '-I' option.

KLIC_CC
     C compiler to be used.

KLIC_CC_OPTIONS
     Additional option flags for the C compiler.

KLIC_LD
     Linker to be used.

KLIC_LD_OPTIONS
     Additional option flags for the linker.


File: KLIC.info,  Node: Mechanism of Compilation,  Prev: Compiler Options,  Up: Compiling

4.1.3 How KLIC Compiler Works
-----------------------------

Understanding how KL1 programs are compiled and executed may help
understanding the usage of KLIC in further depth.

   The system consists of the following three modules.

   * KLIC compiler
   * KLIC database manager
   * KLIC runtime system

   KL1 programs are compiled using the KLIC compiler into C programs.
It also generates files 'FILE.ext' containing information on atoms and
functors used in the program.  The information in '.ext' files for
programs to be linked together is merged together later by the database
manager, into files 'atom.h', 'funct.h', 'atom.c', 'funct.c' and
'predicates.c'.

   The object C program is then compiled by a C compiler, with headers
provided by the KLIC runtime system, 'atom.h' and 'funct.h'.  The files
'atom.c', 'funct.c' and 'predicates.c' are also compiled, and linked
together with the runtime system ('predicates.c' is linked only with
debugging runtime).

   Compilation, database management and linkage are governed by a driver
program named 'klic'.  This program 'klic' plays a role similar to 'cc'
and 'make' combined.  'cc' controls the C preprocessor, the C compiler
kernel and the linker; 'klic' controls the KL1-to-C compiler, the C
compiler, the KL1 program database manager and the linker.  'make'
selectively executes compilation only when needed by examining the file
dates; 'klic' works similarly.


File: KLIC.info,  Node: Running,  Next: Tracing,  Prev: Compiling,  Up: Using KLIC

4.2 Running Programs Compiled with KLIC
=======================================

You can simply run the compiled excutable.  If you compiled your program
into the file 'a.out', you simply give the file name './a.out' to the
shell you are using.

   The predicate 'main' with no arguments in the module 'main' will be
the initial goal to be executed (*note Initial Goal::).

* Menu:

* Runtime Switches::            Runtime command line switches


File: KLIC.info,  Node: Runtime Switches,  Prev: Running,  Up: Running

4.2.1 Runtime Switches for Programs Compiled with KLIC
------------------------------------------------------

The following options are available on running the compiled executable.

-h SIZE
     Specifies initial heap size in words.  As copying garbage
     collection is used, memory size actually used for heap will be
     twice this size.  The size can be specified directly (such as
     '2097152') or with a postfix 'k' or 'm' (as '2048k' or '2m') to
     specify units of 2^10 or 2^20 words.  The default heap size is
     determined by the macro 'HEAPSIZE', which is 24k in the original
     distribution.  The length of one word is the same as the length of
     the type 'long int' in C, that depends on the hardware and the C
     compiler you use.  The heap size will be increased automatically
     according to options '-H' and '-a'.

-H SIZE
     Specifies maximum heap size in words.  Automatic heap expansion
     mechanism will never try to expand the heap above the size
     specified by this option.  The default value is infinite.

-a RATIO
     Specifies threashold active cell ratio as a floating point number.
     If the ratio of the space occupied by active (non-garbage) cells in
     the heap space is above this threshold, the heap size will be
     doubled in the next garbage collection, as far as the size doesn't
     exceed the maximum size specified by the '-H' option.  The default
     value is 0.5.

-g
     Specifies that time required for garbage collection is to be
     measured.  As garbage collection will not take long for small heap
     sizes, the measurement overhead can be more than that.  Thus, by
     default, garbage collection timing is disabled.

-s
     Specifies suspension statistics.  After execution of the program,
     suspended predicates and numbers of their suspensions are reported.
     This option is available when the debugging version of the runtime
     library is linked, which is the default setting (*note Compiler
     Options::).

-t
     Specifies to start execution with tracing (*note Tracing Program
     Execution: Tracing.).  Tracing is only possible when the debugging
     version of the runtime library is linked, which is the default
     setting.  The non-debugging version of the runtime library can be
     specified by compilation time options (*note Compiler Options::).

   When all the ready goals have been executed, the program will stop.
If there remain any goals awaiting for input data and if the program is
linked with the debugging runtime library, it will try to detect which
goal is problematic and report such a goal.  Otherwise, if the linked
library is a non-debugging version, only the number of such remaining
goals is reported.


File: KLIC.info,  Node: Tracing,  Next: Install,  Prev: Running,  Up: Using KLIC

4.3 Tracing Program Execution
=============================

KLIC provides a debugging tracer with "spying" (break point) feature.

* Menu:

* Preparing for Trace::         Compiling your program to be traced
* Trace Ports::                 Places you stop at stepping execution
* Output of Tracer::            How your program execution process is displayed
* Controlling Trace::           Controlling which are traced and which are not
* Spying::                      Setting spypoints = break points
* Port Control::                Enabling and disabling tracing of each port
* Display Control::             Controlling the verbosity of trace display
* Dumping Goals::               Displaying all ready or suspended goals
* Misc Trace Commands::         Miscellaneous commands
* Perpetual Suspension::        Detecting goals that can never proceed


File: KLIC.info,  Node: Preparing for Trace,  Next: Trace Ports,  Prev: Tracing,  Up: Tracing

4.3.1 Preparation for Traced Execution
--------------------------------------

To use the tracing feature, you have to link your program with the
debugging version of the runtime library.  The debugging version is used
by default, but when you give the '-n' option to the compilation command
'klic', tracing will not be available.

   If you already have compiled and linked the program with the '-n'
option, you don't have to recompile the program from scratch; running
the command 'klic' again without the '-n' option will only link the
object with the debugging version of the runtime library, which takes
much shorter time.

   To trace execution of a program, simply run your program with '-t'
option (*note Runtime Switches for Programs Compiled with KLIC: Runtime
Switches.).


File: KLIC.info,  Node: Trace Ports,  Next: Output of Tracer,  Prev: Preparing for Trace,  Up: Tracing

4.3.2 Trace Ports
-----------------

Execution of KL1 programs proceeds as follows.

  1. The initial goal 'main:main' is put into a pool of goals to be
     executed.

  2. One goal is taken from the goal pool ('CALL').

  3. The goal is matched against the program clauses.

  4. If any of the clauses matches the goal, the goal is reduced into
     subgoals and they are put back to the goal pool ('REDUCE').

  5. If no clause matches the goal, then the whole computation will be
     aborted ('FAIL').

  6. If values of goal arguments or their substructures are not defined
     and thus it is not possible yet to decide whether some clauses will
     match the goal or not, the goal is put into another goal pool
     awaiting for required values ('SUSPEND').

  7. If there still remain some goals in the goal pool, loop back to the
     step 2.

   Execution of a goal can be traced on four of the above listed points,
numbered 2, 4, 5 and 6.  Such points of interest are called "trace
ports" and referenced as 'CALL', 'REDUCE', 'FAIL' and 'SUSPEND' ports,
respectively.

   Those who are accustomed to the four-port trace model of Prolog may
wonder why two other ports of Prolog, 'EXIT' and 'REDO' are missing.
The 'REDO' port does not exist because KL1 programs do not backtrack.
The 'EXIT' port is not traced for two reasons.  First, keeping track of
all the goal-subgoal hierarchy is much more costly for a concurrent
language such as KL1 than for sequential languages such as Prolog.  Many
different subtrees of the hierarchy may run interleaving each other,
because of the data-flow synchronization feature.  The other reason is
that, KL1 programs are often written as a set of communicating processes
each defined as a goal calling the same predicate in a tail-recursive
fashion.  Such processes (sometimes called "perpetual processes") will
almost never finish and detecting their termination is not as meaningful
as in Prolog.


File: KLIC.info,  Node: Output of Tracer,  Next: Controlling Trace,  Prev: Trace Ports,  Up: Tracing

4.3.3 Format of Trace Display
-----------------------------

Below is our sample program for explanation here.

     :- module main.

     main :- nrev([1,2],X), builtin:print(X).

     nrev([], R) :- R = [].
     nrev([W|X], R) :- nrev(X, XR), append(XR, [W], R).

     append([], Y, Z) :- Z = Y.
     append([W|X], Y, WZ) :- WZ = [W|Z], append(X, Y, Z).

Listed below is output of a full trace of execution of the sample
program.

        1 CALL:main:main?
        1 REDU:main:main :-
        2   0:+nrev([1,2],_4)
        3   1:+builtin:print(_4)?
        2 CALL:main:nrev([1,2],_4)?
        2 REDU:main:nrev([1,2],_4) :-
        4   0:+nrev([2],_D)
        5   1:+append(_D,[1],_4)?
        4 CALL:main:nrev([2],_D)?
        4 REDU:main:nrev([2],_D) :-
        6   0:+nrev([],_18)
        7   1:+append(_18,[2],_D)?
        6 CALL:main:nrev([],_18)?
        6 REDU:main:nrev([],[])?
        7 CALL:main:append([],[2],_D)?
        7 REDU:main:append([],[2],[2])?
        5 CALL:main:append([2],[1],_4)?
        5 REDU:main:append([2],[1],[2|_1F]) :-
        8   0:+append([],[1],_1F)?
        8 CALL:main:append([],[1],_1F)?
        8 REDU:main:append([],[1],[1])?
        3 CALL:builtin:print([2,1])?
     [2,1]
        3 REDU:builtin:print([2,1])?

   As this program does not make any suspensions nor failures, all the
trace outputs here are either at the call or the reduce port (marked as
'REDU').

   The first line of the above is the trace of the call port of the
initial goal 'main:main'.

        1 CALL:main:main?

All the traced goals are given a unique identifier (an integer value) to
distinguish them among themselves.  The number '1' in the first column
here is the identifier of the initial goal.

   The initial goal matches the first clause defined in the program and
thus reduced into subgoals as defined in the program clause.  This
reduction is traced as follows.

        1 REDU:main:main :-
        2   0:+nrev([1,2],_4)
        3   1:+builtin:print(_4)?

This shows that the original goal 'main:main' with ID 1 has been reduced
into two new goals, 'main:nrev([1, 2], _4)' and 'builtin:print(_4)',
with IDs 2 and 3 respectively.

   The numbers 0 and 1 following the IDs 2 and 3 of the two new goals
are sequential numbers for the subgoals generated by the reduction.
They are used by some tracer commands to identify which subgoal to apply
the command to.  Unlike unique goal IDs that have global meaning, these
subgoal numbers are meaningful only at this specific port.

   Next comes ':', which means the subgoal is an ordinary subgoal of the
parent goal.  There are other possibilities here.  The character '*'
means that the goal following it is also a subgoal, but is given a
priority different from the parent.  The priority is displayed in a
pseudo-pragma format.  The character '!' means that the goal following
it is not actually a subgoal reduced from the parent goal, but is a goal
awaiting for some variable value which has just waken up as this
reduction gave some concrete value to the variable.  The character '#'
similarly indicates a goal waken up, but with a priority different from
the parent.

   Then comes either '+' or '-'.  '+' means that the subgoal will be
traced if you simply continue the execution, and '-' means it will not.
This can be changed by giving some tracer commands described below.  In
the example above, all of the subgoals have '+' as all goals are traced.

   Then the module name, a colon character, and the predicate name of
the subgoal are displayed.  The module name for predicates defined in
the same module as the predicate of the parent goal is omitted with the
colon for brevity.  In the above example, the subgoal calling 'nrev'
(that is 'main') does not have its module name displayed, as it is the
same as the parent goal 'main:main'.

   Finally comes the argument list in parentheses separated by commas.
The second argument of nrev and the only argument of print is '_4',
which corresponds to a variable corresponding to 'X' in the source
program.  As variables are newly allocated for all incarnation of
predicate clauses, and as two or more variables can be unified together,
displaying their original names in the source program is not meaningful.
They are given unique names such as '_4'.

   Actually, this number 4 is related to the physical memory address of
the variable.  It will thus change completely by garbage collections.
However, as garbage collections are not so frequent, the address
information is still quite useful for debugging.

   The trace output stops after displaying all the subgoals and a
question mark.  Here, you can input one of the trace commands described
below.


File: KLIC.info,  Node: Controlling Trace,  Next: Spying,  Prev: Output of Tracer,  Up: Tracing

4.3.4 Trace Controlling Commands
--------------------------------

Tracing can be controlled at each _leashed_ port (*note Controlling
Trace Ports: Port Control.).  Tracing can be controlled for the traced
goal as a whole or, at the reduce port, for each of the newly created
subgoal.  The default of whether or not to trace goals of each predicate
can also be set.

* Menu:

* Goal Control::                Controlling trace of the traced goal
* Subgoal Control::             Controlling trace of newly created subgoals
* Predicate Control::           Changing default trace of predicates


File: KLIC.info,  Node: Goal Control,  Next: Subgoal Control,  Prev: Controlling Trace,  Up: Controlling Trace

4.3.4.1 Controlling Tracing of the Traced Goal
..............................................

The following commands are available for controlling program execution.

Continue: 'c' or simply '<RET>'
     Continues stepping execution.  Subgoal marked as '-' are not traced
     even in stepping mode.

Leap: 'l'
     Continues execution without tracing until a spy point is
     encountered.  *Note Spying::, for details.

Skip: 's'
     Continues execution of the traced goal and all subgoals thereof
     without tracing them at all.  Even spy points are neglected.

Abort: 'a'
     Aborts whole execution of the program.

   These commands do not take any arguments.


File: KLIC.info,  Node: Subgoal Control,  Next: Predicate Control,  Prev: Goal Control,  Up: Controlling Trace

4.3.4.2 Controlling Tracing of Newly Created Subgoals
.....................................................

Tracing of each subgoal (displayed as '+' or '-') can be changed by the
following commands.

Trace: '+' SUBGOAL_NUMBER ...
     Switches on the trace of the specified subgoal(s).  Multiple
     subgoal numbers separated by spaces can be specified.  If no
     subgoal numbers are given, all the subgoals become traced.

No Trace: '-' SUBGOAL_NUMBER ...
     Switches off the trace of the specified subgoal(s).  Multiple
     subgoal numbers separated by spaces can be specified.  If no
     subgoal numbers are given, all the subgoals become untraced.

Toggle Trace: SUBGOAL_NUMBER ...
     Toggles the trace switch of the specified subgoal(s).  Multiple
     subgoal numbers separated by spaces can be specified.


File: KLIC.info,  Node: Predicate Control,  Prev: Subgoal Control,  Up: Controlling Trace

4.3.4.3 Changing Default Trace of Predicates
............................................

By default, all the subgoals of a goal will have trace switch on ('+')
initially at the reduce port.  This default setting can be changed
predicate by predicate using commands described in this section, so that
predicates you are not interested in will not be traced by default.

   In what follows, command arguments <predicate> has one of the
following format.

MODULE:PREDICATE/ARITY
     Specifies explicitly and exactly one predicate.  For example,
     'main:nrev/2'.

MODULE:PREDICATE
     Specifies all the predicates within a module with different
     arities.

MODULE:
     Specifies all the predicates defined in a module.  Note that a
     colon is required after the module name to distinguish it from a
     predicate name.

PREDICATE/ARITY
     Specifies the predicate defined in the same module as the predicate
     of the currently traced goal with the given name and arity.

PREDICATE
     Specifies all the predicates defined in the same module as the
     predicate of the currently traced goal with the given name.

   Listed below are commands to change the default for given predicates.

No Trace Default: 'n' PREDICATE ...
     Sets the default trace for the predicate(s) to be off.  If no
     predicates are given as argument, the predicate of the traced goal
     is considered to be specified.

Trace Default: 't' PREDICATE ...
     Sets the default trace for the predicate(s) to be on.  If no
     predicates are given as argument, the predicate of the traced goal
     is considered to be specified.


File: KLIC.info,  Node: Spying,  Next: Port Control,  Prev: Controlling Trace,  Up: Tracing

4.3.5 Spying
------------

It is often the case that only some specific predicates are of interest
for debugging.  In such cases, ports for such predicates can be
specified as the "spy points".  You can let program run without tracing
until some spy point is encountered, using the leap ('l') command.
*Note Controlling Tracing of the Traced Goal: Goal Control, for details.

   Commands described in this section set or reset such spy points.

Spy: 'S' PREDICATE ...
     Makes the predicate(s) spied.  If no predicates are given as
     argument, the predicate of the traced goal is spied.

No Spy: 'N' PREDICATE ...
     Resets the spy point on the predicate(s).  If no predicates are
     given as argument, the spy point on the predicate of the traced
     goal is reset.


File: KLIC.info,  Node: Port Control,  Next: Display Control,  Prev: Spying,  Up: Tracing

4.3.6 Controlling Trace Ports
-----------------------------

The four trace ports can be selectively enabled and disabled.  Disabled
ports will not be traced at all.

   In addition, for each port, you can specify whether to stop and wait
for command input.  Ports where execution stops and waits for commands
are said to be "leashed".  On ports enabled but not leashed, the trace
output will be displayed but execution continues as if the continue
command (carriage return) was input immediately.  For spied predicates,
even unleashed ports will be leashed.

   Commands described in this section is for controlling such attributes
of ports.  They take port names as their arguments, specified as one of
the following ways.

Call:
     'c', 'call'
Reduce:
     'r', 'redu', 'reduce'
Suspend:
     's', 'susp', 'suspend'
Fail:
     'f', 'fail'
All ports:
     'a', 'all'

   Listed below are the commands for controlling ports.

Enable Port: 'E' PORT ...
     Enables the specified port(s).

Disable Port: 'D' PORT ...
     Disables the specified port(s).

Leash Port: 'L' PORT ...
     Leashes the specified port(s).

Unleash Port: 'U' PORT ...
     Unleashes the specified port(s).


File: KLIC.info,  Node: Display Control,  Next: Dumping Goals,  Prev: Port Control,  Up: Tracing

4.3.7 Display Control Commands
------------------------------

Sometimes, full information of the traced goals is not desirable, as too
much information is only harmful for understanding the program behavior.
Thus, commands in this section are provided for controlling the amount
of information displayed on trace ports.

   The amount of display is controlled by a combination of the following
options.

   * By limiting display depth: Arguments of structures below depth
     limit are displayed in the following abbreviated way.

          f(a,b,c,d,e)    ==>    f(..)
          [a,b,c,d,e]     ==>    [..]

   * By limiting display length: Argument lists of structures or
     character strings longer than the length limit are displayed in the
     following abbreviated way.

          f(a,b,c,d,e)    ==>    f(a,b,c,..)
          [a,b,c,d,e]     ==>    [a,b,c,..]
          "abcde"         ==>    "abc.."

   * By specifying a subterm to be displayed: Only a part of the traced
     goal can be specified for display.

   The following commands can be used to control the options.

Set Print Depth: 'pd' DEPTH
     Sets depth limit of displaying data structures to DEPTH.  With no
     argument, prints the current depth limit value.

Set Print Length: 'pl' LENGTH
     Sets length limit of displaying data structures to LENGTH.  With no
     argument, prints the current length limit value.

Toggle Verbose Print: 'pv'
     Toggles verbose printing mode switch.  In verbose printing mode,
     variables with goals awaiting for its value are displayed with the
     information of the goal.

Set Subterm: '^' N
Reset Subterm:'^'
     Sets the N-th subterm of the traced goal to be inspected.  With 0
     specified as N, the subterm goes up one level.  With N omitted,
     subterm inspection is reset.  For list structures, 1 means car and
     2 means cdr.

     With subterm specification, only the subterm of the traced goal is
     displayed after the information of which subterm is inspected.  An
     example follows.

            10 CALL: foo:bar(f(a,g(..),[..]))? ^1
            10 CALL: ^1 f(a,g(b,c),[d,e])? ^2
            10 CALL: ^1^2 g(b,c)? ^0
            10 CALL: ^1 f(a,g(b,c),[d,e])? ^3
            10 CALL: ^1^3 [d,e]? ^2
            10 CALL: ^1^3^2 [e]? ^
            10 CALL: foo:bar(f(a,g(..),[..]))?

     At reduce ports, subgoals created by the reduction are not
     displayed when subterm display is specified; only the specified
     subterm of the parent goal is displayed.  With the current version,
     vector elements cannot be specified as subterms.

   The initial setting of depth and length limits are 3 and 7,
respectively.  Verbose print mode is initially switched off.


File: KLIC.info,  Node: Dumping Goals,  Next: Misc Trace Commands,  Prev: Display Control,  Up: Tracing

4.3.8 Dumping Goals
-------------------

It is desirable sometimes to dump all the goals in the system as a last
resort.  The following commands do it.

Dump Ready Queue: 'Q'
     Displays all the goals in the ready queue (goal pool) with their
     priorities.

Dump Suspended (Waiting) Goals: 'W'
     Displays all the suspended goals in the system with their
     priorities.


File: KLIC.info,  Node: Misc Trace Commands,  Next: Perpetual Suspension,  Prev: Dumping Goals,  Up: Tracing

4.3.9 Miscellaneous Commands
----------------------------

Status Query: '='
     Displays tracer status information, such as follows.

             port: Call Susp Redu Fail
          enabled:  +    +    +    +
          leashed:  +    +    +    +
          print terse; depth = 3; length = 7

List Modules: 'lm'
     Lists all the modules of the currently executed program.

List Predicates: 'lp'
     Lists all the predicates and their default trace status of the
     currently executed program.

Queue: 'Q'
     Lists the contents of the ready queue (goal pool).

Help: '?' or 'h'
     Lists all the commands and their terse description available at the
     current port.


File: KLIC.info,  Node: Perpetual Suspension,  Prev: Misc Trace Commands,  Up: Tracing

4.3.10 Detecting Perpetual Suspensions
--------------------------------------

When some goals are awaiting for instantiation of a variable that will
never be instantiated by any other goals, such goals will never proceed.
This situation is called "perpetual suspension".  Perpetual suspension
is detected by the garbage collector of KLIC. Thus, during program
execution, garbage collections may find perpetual suspensions.

   The system keeps track of the number of suspended goals.  When there
exist no goals ready for running and there are suspended goals
remaining, the system will try garbage collection to detect perpetual
suspensions.

   Perpetual suspensions are reported as follows.

     !!! Perpetual Suspention Detected !!!
        3 PSUS: MODULE:PREDICATE(ARGS...)?

The same command set as at a fail port is available here.


File: KLIC.info,  Node: Install,  Next: Distributed KLIC,  Prev: Tracing,  Up: Using KLIC

4.4 Installation
================

Installation of KLIC should be fairly easy.

   Host-dependent and preference-based customizations are made by
running a configuration script provided with the distribution.  Then
'make all' should compile the whole system.  You can make sure that the
system has been compiled without problems by running 'make tests'.  Then
you can install the system by 'make install'.

* Menu:

* Configuration::               Configuration script
* Make All::                    Compiling the system
* Make Tests::                  Testing the compilation
* Make Install::                Actually installing the system
* Make Distclean::              Cleaning up after installation
* Troubles::                    What to do when you have some trouble


File: KLIC.info,  Node: Configuration,  Next: Make All,  Prev: Install,  Up: Install

4.4.1 Configuration
-------------------

First thing to do in installation of KLIC is to configure the KLIC
system depending on the host computer system and your preference.

   Go to the root directory of the distribution (referred to as ROOT in
what follows).  Then, run the configuration script there by a command
'./Configure'.  The script will search for available software tools in
your system and ask your preferences.

   The default shell programs on some Unix systems based on BSD 4.2 do
not understand some of the constructs used in this configuration script.
In such a case, obtain a modern shell (such as GNU 'bash') and let it
execute the script, as follows.

     % bash Configure

   If you have built the system before and rebuilding it in the same
directory, it will ask whether the same values you specified the last
time should be used as default values.

   The next question it asks (or the first, if it is the first time to
build the system) is whether to configure also for parallel
implementations.  If you want to install only the sequential system,
please answer 'no' to the question.  See relevant sections (*note
Distributed KLIC:: and *note Shared-Memory KLIC::), for further details
of configuraion of parallel versions of the system.

   The configuration script will make three files.

     ROOT/Makefile
     ROOT/include/klic/config.h
     ROOT/config.sh

   The last one records the specified options for reconfiguration.

   The configuration script asks about the parallelism used in the
installation procedure.  You can specify non-zero parallelism here to
speed up the procedure if you are installing your system on a lightly
loaded multiprocessor system.  Do _not_ use parallel execution features
of the 'make' program.


File: KLIC.info,  Node: Make All,  Next: Make Tests,  Prev: Configuration,  Up: Install

4.4.2 Compiling the KLIC system
-------------------------------

After configuring the system, typing in 'make all' should compile the
whole KLIC system, including the KL1 to C compiler and the runtime
libraries.


File: KLIC.info,  Node: Make Tests,  Next: Make Install,  Prev: Make All,  Up: Install

4.4.3 Testing the Compilation
-----------------------------

After system compilation is finished, you are recommended to test
whether the compilation went without problems.  To do that, type in
'make tests' in the root directory of the distribution (not in its
subdirectory 'test').  This will compile and run several KL1 test
programs and compares the output with the expected output.


File: KLIC.info,  Node: Make Install,  Next: Make Distclean,  Prev: Make Tests,  Up: Install

4.4.4 Installing the Objects
----------------------------

After compilation, typing in 'make install' will install the compiler,
header files and runtime libraries to directories specified on
configuration (*note Configuration::).


File: KLIC.info,  Node: Make Distclean,  Next: Troubles,  Prev: Make Install,  Up: Install

4.4.5 Cleaning Up the Installation Directory
--------------------------------------------

After installation has been done, typing in 'make distclean' will delete
all the files _not_ included in the distribution.

   Normal users should *not* try 'make realclean', which will delete C
program source files generated from KL1.  A working KL1 to C compiler
will be needed to regenerate the C program source files.


File: KLIC.info,  Node: Troubles,  Prev: Make Distclean,  Up: Install

4.4.6 When Something Goes Wrong
-------------------------------

When the installation procedure went wrong because of misconfiguration,
you had better start all over again from the configuration step (*note
Configuration::).  The configuraion script will ask you whether to clean
up the system for reconfiguration.  Please answer affirmative then.

   Dependency rules written in Makefiles are inappropriate for using
parallel make features provided by some versions of 'make'.  The
compilation procedure of KLIC relies on the fact that contents of atom
and functor databases are monotonically increasing.  Dependencies on
them are intentionally omitted to avoid redundant recompilation.  Use
the parallel compilation feature of the compiler driver 'klic' that
understands the mechanism instead.  Parallelism used during installation
procedure is specified at the configuration step (*note
Configuration::).

   If you think the problem is due to the distributed code, please
report your problem to the following address.

     klic-bugs@icot.or.jp

   Including information on your host system (hardware and operating
system), your configuration (contents of the file 'config.sh'), and log
of your installation would be of great help in analysing your problems.


File: KLIC.info,  Node: Distributed KLIC,  Next: Shared-Memory KLIC,  Prev: Install,  Up: Using KLIC

4.5 Distributed Memory Parallel Implementation of KLIC
======================================================

A version of the distributed parallel implementation of KLIC is included
in this KLIC distribution.  The distributed implementation is based on
PVM 3.3.  Implementations on other portable parallel processing
libraries, such as MPI, and those on system-specific interprocess
communication libraries have also been done, but not yet integrated into
this distribution.

   Although it is based on PVM, the current version does not support
heterogeneous configuration: It does not work with systems consisting of
processors with multiple architectures or running different operating
systems.  Currently, we don't have any plans to support heterogenous
systems.

* Menu:

* Installation of Distributed KLIC::
* Compiling Programs for Distributed KLIC::
* Running Programs of Distributed KLIC::


File: KLIC.info,  Node: Installation of Distributed KLIC,  Next: Compiling Programs for Distributed KLIC,  Prev: Distributed KLIC,  Up: Distributed KLIC

4.5.1 Installation of Distributed KLIC
--------------------------------------

To install the PVM version of the distributed KLIC, you have to first
answer affirmatively to the question from the configuration script
asking whether to configure for parallel implementations and then
affirmatively again to to the question asking whether to configure for
the distributed KLIC. Then it will ask for several questions on which
directories the PVM system is installed and which PVM library is to be
used, if several of them are available.

   The following will be asked.
   * Root directory of the pvm system
   * The keyword for architecture of the system ('SUN4MP', for example)
   * The name of the PVM library ('pvm3', for example)

   The current version has problems with PVM implementations which does
not use daemon processes.  For example, on shared-memory multiprocessor
Sparc systems running Solaris 2, the library 'pvm3' does not work.  Use
'pvm3s' that use sockets instead of shared-memory for interprocess
communication.

   The rest of the installation procedure is the same as the procedure
without the distributed KLIC system.

   The distributed KLIC system runs exactly the same as its sequential
version when the option for distributed processing ('-dp') is not
specified on compilation.


File: KLIC.info,  Node: Compiling Programs for Distributed KLIC,  Next: Running Programs of Distributed KLIC,  Prev: Installation of Distributed KLIC,  Up: Distributed KLIC

4.5.2 Compiling Programs for Distributed KLIC
---------------------------------------------

Compilation procedure is almost the same for the sequential version
except that the following option is available.

-dp
     Specifies compilation for the distributed KLIC system.  Without
     this option, the compiled object code will run only sequentially.


File: KLIC.info,  Node: Running Programs of Distributed KLIC,  Prev: Compiling Programs for Distributed KLIC,  Up: Distributed KLIC

4.5.3 Running Programs of Distributed KLIC
------------------------------------------

* Menu:

* Setting Up PVM::
* Runtime Options for Distributed KLIC::
* Known Bugs of Distributed KLIC::


File: KLIC.info,  Node: Setting Up PVM,  Next: Runtime Options for Distributed KLIC,  Prev: Running Programs of Distributed KLIC,  Up: Running Programs of Distributed KLIC

4.5.3.1 Setting Up PVM
......................

Before executing programs compiled for distributed execution, the PVM
system has to be running on your system.  The following set up will be
required.

   * The following environment variables should be set properly.

     PVM_ROOT
          The root directory of the PVM system installed on your system.

     PVM_ARCH
          The keyword specifying the architecture of the system.

     They should be the same as what you specified on installation of
     the KLIC system.

   * The PVM demon should be running.  The demon can be started by
     invoking the PVM console, which is in
     '$PVM_ROOT/lib/$PVM_ARCH/pvm'.  It would be convenient to keep a
     window for this console.

   For other setting parameters and details of operation of PVM console,
please consult its own manual.


File: KLIC.info,  Node: Runtime Options for Distributed KLIC,  Next: Known Bugs of Distributed KLIC,  Prev: Setting Up PVM,  Up: Running Programs of Distributed KLIC

4.5.3.2 Runtime Options for Distributed KLIC
............................................

The following options are available when running programs in the
distributed KLIC system, in addition to those available for the
sequential version.

-p N
     Specifies the number of workers (Unix processes) for running the
     program.

-e
     Specifies eager transfer mode.  Normally, KLIC transfers data
     structures between processors on demands.  Thus, nested data
     structures are transferred one level at a time.  In the eager
     transfer mode, nested structures are sent at a time as far as they
     are already defined.  This makes the execution more efficient for
     some programs, but may degrade the performance for others.

-E LEVEL
     Specifies how many level of nested data structures are to be
     transferred at each communication.

-I MICROSEC
     Specifies interval between interprocessor communication polling.
     Whether such polling is needed and which value to be appropriate
     depend on host systems and implementations of the physical
     communication layer.  In most cases, its default value of 10000 is
     appropriate.

-n
     Specifies printing out of some runtime statistics on interprocess
     communication.

-notimer
     Specifies not to use timer-driven communication polling.  Whether
     such polling is mandatory depends on implementation of the physical
     communication layer.

-relsp
     Specifies that relative path should be used for the executable file
     on spawning worker tasks.

-S
     Specifies not to notify receiver processes of communication packets
     by sending singals.  On some implementations, this may speed up
     program execution by eliminating signal sending overheads.


File: KLIC.info,  Node: Known Bugs of Distributed KLIC,  Prev: Runtime Options for Distributed KLIC,  Up: Running Programs of Distributed KLIC

4.5.3.3 Known Bugs of Distributed KLIC
......................................

   * Atoms and functors newly registered during program execution may
     not be handled properly.

   * Specification of spying (*note Spying::) is effective only within
     the computation node where it is specified.


File: KLIC.info,  Node: Shared-Memory KLIC,  Prev: Distributed KLIC,  Up: Using KLIC

4.6 Shared-Memory Implementation of KLIC
========================================

A version of the shared-memory parallel implementation of KLIC is
included in this KLIC distribution.  The implementation contains
hardware, operating system, and C compiler dependent parts.  The version
included is for Sparc-based systems running SunOS 5.3 and Alpha-based
systems running DEC OSF/1.  Gnu CC should be used for their compilation.

* Menu:

* Installation of Shared-Memory KLIC::
* Compiling Programs for Shared-Memory KLIC::
* Running Programs of Shared-Memory KLIC::


File: KLIC.info,  Node: Installation of Shared-Memory KLIC,  Next: Compiling Programs for Shared-Memory KLIC,  Prev: Shared-Memory KLIC,  Up: Shared-Memory KLIC

4.6.1 Installation of Shared-Memory KLIC
----------------------------------------

To install the shared-memory parallel version of KLIC, you have to first
answer affirmatively to the question from the configuration script
asking whether to configure shared-memory parallel implementation.

   The rest of the installation procedure is the same as the procedure
without the shared-memory KLIC system.

   The shared-memory KLIC system runs exactly the same as its sequential
version when the option for shared-memory parallel processing ('-shm')
is not specified on compilation.


File: KLIC.info,  Node: Compiling Programs for Shared-Memory KLIC,  Next: Running Programs of Shared-Memory KLIC,  Prev: Installation of Shared-Memory KLIC,  Up: Shared-Memory KLIC

4.6.2 Compiling Programs for Shared-Memory KLIC
-----------------------------------------------

Compilation procedure is almost the same for the sequential version
except that the following option is available.

-shm
     Specifies compilation for the shared-memory KLIC system.  Without
     this option, the compiled object code will run only sequentially.


File: KLIC.info,  Node: Running Programs of Shared-Memory KLIC,  Prev: Compiling Programs for Shared-Memory KLIC,  Up: Shared-Memory KLIC

4.6.3 Running Programs of Shared-Memory KLIC
--------------------------------------------

* Menu:

* Runtime Options for Shared-Memory KLIC::
* Known Bugs of Shared-Memory KLIC::


File: KLIC.info,  Node: Runtime Options for Shared-Memory KLIC,  Next: Known Bugs of Shared-Memory KLIC,  Prev: Running Programs of Shared-Memory KLIC,  Up: Running Programs of Shared-Memory KLIC

4.6.3.1 Runtime Options for Shared-MemoryKLIC
.............................................

The following options are available when running programs in the
shared-memory KLIC system, in addition to those available for the
sequential version.

-p N
     Specifies the number of workers (Unix processes) for running the
     program.

-D
     Reports process numbers of children workers.  Maybe useful for
     lower level debugging.

-S SIZE
     Specifies the size of the shared heap.  In the current
     implementation, shared heap is allocated at the initiation and will
     never be expanded.


File: KLIC.info,  Node: Known Bugs of Shared-Memory KLIC,  Prev: Runtime Options for Shared-Memory KLIC,  Up: Running Programs of Shared-Memory KLIC

4.6.3.2 Known Bugs of Shared-Memory KLIC
........................................

   * The tracer may not work correctly.


File: KLIC.info,  Node: Type Index,  Next: Predicate Index,  Prev: Using KLIC,  Up: Top

Data Type Index
***************

 [index ]
* Menu:

* atom:                                  Symbolic Atoms.       (line  6)
* floating point number:                 Floating Points.      (line  6)
* functor:                               Functors.             (line  6)
* integer:                               Integers.             (line  6)
* list:                                  Lists.                (line  6)
* merger:                                Merging.              (line 60)
* module:                                Module Type.          (line  6)
* predicate:                             Predicate Type.       (line  6)
* string:                                Strings.              (line  6)
* vector:                                Vectors.              (line  6)


File: KLIC.info,  Node: Predicate Index,  Next: Module Index,  Prev: Type Index,  Up: Top

Predicate, Method and Message Index
***********************************

 [index ]
* Menu:

* $:= on builtin:                        Floating Arith.       (line  6)
* $< on builtin:                         Floating Comp.        (line 17)
* $=:= on builtin:                       Floating Comp.        (line 14)
* $=< on builtin:                        Floating Comp.        (line 16)
* $=\= on builtin:                       Floating Comp.        (line 15)
* $> on builtin:                         Floating Comp.        (line 12)
* $>= on builtin:                        Floating Comp.        (line 13)
* := on builtin:                         Integer Arith.        (line  6)
* := on builtin <1>:                     Integer Arith.        (line  7)
* < on builtin:                          Integer Comp.         (line 16)
* = on builtin:                          Unification.          (line  6)
* = on builtin <1>:                      Unification.          (line 10)
* =.. on functor_table:                  Functor Operation.    (line 48)
* =:= on builtin:                        Integer Comp.         (line 13)
* =< on builtin:                         Integer Comp.         (line 15)
* =\= on builtin:                        Integer Comp.         (line 14)
* > on builtin:                          Integer Comp.         (line 11)
* >= on builtin:                         Integer Comp.         (line 12)
* @< on builtin:                         Comparison and Hashing.
                                                               (line 40)
* @=< on builtin:                        Comparison and Hashing.
                                                               (line 41)
* @> on builtin:                         Comparison and Hashing.
                                                               (line 43)
* @>= on builtin:                        Comparison and Hashing.
                                                               (line 42)
* \= on builtin:                         Comparison and Hashing.
                                                               (line 47)
* accept on bound socket:                Sockets.              (line 36)
* access on unix stream:                 Files & Dirs.         (line 25)
* acos on float:                         Floating Arith.       (line 66)
* add on float:                          Floating Arith.       (line 57)
* add on timer:                          Timer.                (line 35)
* addop on Prolog-like I/O:              Common Msgs (Prolog style).
                                                               (line 17)
* append_open on klicio stream:          Opening Prolog I/O.   (line 24)
* append_open on unix stream:            I/O Opening.          (line 27)
* apply on predicate:                    Predicate Type.       (line 45)
* arg on builtin:                        Functor Operation.    (line 29)
* arg on builtin <1>:                    Functor Operation.    (line 30)
* argc on unix:                          Predicate Interface.  (line  9)
* argv on unix:                          Predicate Interface.  (line 14)
* arity on predicate:                    Predicate Type.       (line 41)
* arity on predicate <1>:                Predicate Type.       (line 42)
* asin on float:                         Floating Arith.       (line 65)
* atan on float:                         Floating Arith.       (line 67)
* atom on builtin:                       Symbolic Atom Operation.
                                                               (line  9)
* atomic on builtin:                     Atomic Data.          (line 19)
* atom_number on atom_table:             Symbolic Atom Operation.
                                                               (line 21)
* bind on unix stream:                   Sockets.              (line 25)
* call on predicate:                     Predicate Type.       (line 51)
* cd on unix stream:                     Files & Dirs.         (line  8)
* ceil on float:                         Floating Arith.       (line 74)
* chmod on unix stream:                  Files & Dirs.         (line 41)
* compare on builtin:                    Comparison and Hashing.
                                                               (line  6)
* compare on timer:                      Timer.                (line 39)
* connect on unix stream:                Sockets.              (line 10)
* cos on float:                          Floating Arith.       (line 63)
* cosn on float:                         Floating Arith.       (line 69)
* current_node on builtin:               Execution Status.     (line 11)
* current_priority on builtin:           Execution Status.     (line  6)
* divide on float:                       Floating Arith.       (line 60)
* element on string:                     Predicates and Methods.
                                                               (line 17)
* element on string <1>:                 Predicates on Strings.
                                                               (line 20)
* element on string <2>:                 Predicates on Strings.
                                                               (line 21)
* element on vector:                     Predicates on Vectors.
                                                               (line 12)
* element on vector <1>:                 Predicates on Vectors.
                                                               (line 13)
* element_size on string:                Predicates on Strings.
                                                               (line 17)
* equal on float:                        Floating Comp.        (line 36)
* exit on unix:                          Predicate Interface.  (line 18)
* exp on float:                          Floating Arith.       (line 71)
* fclose on C-like I/O:                  Common Msgs (C style).
                                                               (line 33)
* fclose on Prolog-like I/O:             Common Msgs (Prolog style).
                                                               (line 12)
* feof on C-like I/O:                    Common Msgs (C style).
                                                               (line  9)
* feof on Prolog-like I/O:               Common Msgs (Prolog style).
                                                               (line  9)
* fflush on C-like I/O:                  Output Msgs (C style).
                                                               (line 28)
* fflush on Prolog-like I/O:             Output Msgs (Prolog style).
                                                               (line 31)
* float on builtin:                      Floating Points.      (line 11)
* float on float:                        Floating Points.      (line 10)
* floor on float:                        Floating Arith.       (line 75)
* fork on unix stream:                   Misc Unix Messages.   (line 31)
* fork_with_pipes on unix stream:        Misc Unix Messages.   (line 38)
* fread on C-like I/O:                   Input Msgs (C style). (line 15)
* fread on Prolog-like I/O:              Input Msgs (Prolog style).
                                                               (line 29)
* fseek on C-like I/O:                   Common Msgs (C style).
                                                               (line 13)
* fseek on Prolog-like I/O:              Common Msgs (Prolog style).
                                                               (line 10)
* ftell on C-like I/O:                   Common Msgs (C style).
                                                               (line 26)
* ftell on Prolog-like I/O:              Common Msgs (Prolog style).
                                                               (line 11)
* functor on builtin:                    Functor Operation.    (line 15)
* functor on builtin <1>:                Functor Operation.    (line 16)
* fwrite on C-like I/O:                  Output Msgs (C style).
                                                               (line 15)
* fwrite on C-like I/O <1>:              Output Msgs (C style).
                                                               (line 21)
* fwrite on Prolog-like I/O:             Output Msgs (Prolog style).
                                                               (line 29)
* fwrite on Prolog-like I/O <1>:         Output Msgs (Prolog style).
                                                               (line 30)
* gc on system_control:                  System Control.       (line 24)
* getc on C-like I/O:                    Input Msgs (C style). (line  8)
* getc on Prolog-like I/O:               Input Msgs (Prolog style).
                                                               (line 27)
* getenv on unix stream:                 Misc Unix Messages.   (line 14)
* gett on Prolog-like I/O:               Input Msgs (Prolog style).
                                                               (line  6)
* getwt on Prolog-like I/O:              Input Msgs (Prolog style).
                                                               (line 12)
* get_atom_name on atom_table:           Symbolic Atom Operation.
                                                               (line 32)
* get_atom_string on atom_table:         Symbolic Atom Operation.
                                                               (line 25)
* get_time_of_day on timer:              Timer.                (line 21)
* greater_than on float:                 Floating Comp.        (line 35)
* hash on builtin:                       Comparison and Hashing.
                                                               (line 59)
* instantiate_after on timer:            Timer.                (line 46)
* instantiate_at on timer:               Timer.                (line 45)
* instantiate_every on timer:            Timer.                (line 56)
* integer on builtin:                    Integers.             (line 10)
* intern on atom_table:                  Symbolic Atom Operation.
                                                               (line 28)
* join on string:                        Predicates on Strings.
                                                               (line 53)
* join on vector:                        Predicates on Vectors.
                                                               (line 45)
* kill on unix stream:                   Misc Unix Messages.   (line 27)
* klicio on klicio:                      Opening Prolog I/O.   (line  6)
* less_than on float:                    Floating Comp.        (line 32)
* less_than on string:                   Predicates on Strings.
                                                               (line 27)
* linecount on C-like I/O:               Input Msgs (C style). (line 23)
* linecount on Prolog-like I/O:          Input Msgs (Prolog style).
                                                               (line 30)
* list on builtin:                       Lists.                (line 20)
* log on float:                          Floating Arith.       (line 72)
* make_atom on atom_table:               Symbolic Atom Operation.
                                                               (line 17)
* mktemp on unix stream:                 Files & Dirs.         (line 18)
* module on module:                      Module Type.          (line 16)
* module on predicate:                   Predicate Type.       (line 56)
* multiply on float:                     Floating Arith.       (line 59)
* name on module:                        Module Type.          (line 19)
* name on predicate:                     Predicate Type.       (line 60)
* new on float:                          Creating Floats.      (line 10)
* new on merge:                          Merging.              (line 59)
* new on module:                         Module Type.          (line  9)
* new on predicate:                      Predicate Type.       (line 31)
* new on random_numbers:                 Random Numbers.       (line 11)
* new on random_numbers <1>:             Random Numbers.       (line 12)
* new on string:                         Creating Strings.     (line 10)
* new on vector:                         Creating Vectors.     (line 10)
* new_functor on builtin:                Functor Operation.    (line 36)
* new_string on builtin:                 Creating Strings.     (line 11)
* new_vector on builtin:                 Creating Vectors.     (line 11)
* nl on Prolog-like I/O:                 Output Msgs (Prolog style).
                                                               (line 45)
* not_equal on float:                    Floating Comp.        (line 37)
* not_greater_than on float:             Floating Comp.        (line 33)
* not_less_than on float:                Floating Comp.        (line 34)
* not_less_than on string:               Predicates on Strings.
                                                               (line 32)
* NUMBER on C-like I/O:                  Output Msgs (C style).
                                                               (line 11)
* NUMBER on Prolog-like I/O:             Output Msgs (Prolog style).
                                                               (line 28)
* postmortem on system_control:          System Control.       (line  8)
* pow on float:                          Floating Arith.       (line 61)
* predicate on predicate:                Predicate Type.       (line 38)
* putc on C-like I/O:                    Messages.             (line 17)
* putc on C-like I/O <1>:                Output Msgs (C style).
                                                               (line  8)
* putc on Prolog-like I/O:               Output Msgs (Prolog style).
                                                               (line 27)
* putenv on unix stream:                 Misc Unix Messages.   (line 20)
* putt on Prolog-like I/O:               Output Msgs (Prolog style).
                                                               (line  6)
* puttq on Prolog-like I/O:              Output Msgs (Prolog style).
                                                               (line  7)
* putwt on Prolog-like I/O:              Output Msgs (Prolog style).
                                                               (line  8)
* putwtq on Prolog-like I/O:             Output Msgs (Prolog style).
                                                               (line  9)
* read_open on klicio stream:            Opening Prolog I/O.   (line 22)
* read_open on unix stream:              I/O Opening.          (line 25)
* rmop on Prolog-like I/O:               Common Msgs (Prolog style).
                                                               (line 20)
* search_character on builtin:           Predicates on Strings.
                                                               (line 59)
* search_character on string:            Predicates on Strings.
                                                               (line 57)
* setarg on builtin:                     Functor Operation.    (line 41)
* setarg on builtin <1>:                 Functor Operation.    (line 42)
* set_element on string:                 Predicates on Strings.
                                                               (line 37)
* set_element on vector:                 Predicates on Vectors.
                                                               (line 19)
* set_element on vector <1>:             Predicates on Vectors.
                                                               (line 27)
* set_string_element on builtin:         Predicates on Strings.
                                                               (line 38)
* set_vector_element on builtin:         Predicates on Vectors.
                                                               (line 20)
* set_vector_element on builtin <1>:     Predicates on Vectors.
                                                               (line 29)
* signal_stream on unix stream:          Signals.              (line  9)
* sin on float:                          Floating Arith.       (line 62)
* sinh on float:                         Floating Arith.       (line 68)
* size on string:                        Predicates on Strings.
                                                               (line 14)
* size on vector:                        Predicates on Vectors.
                                                               (line  7)
* split on string:                       Predicates on Strings.
                                                               (line 45)
* split on vector:                       Predicates on Vectors.
                                                               (line 37)
* sqrt on float:                         Floating Arith.       (line 73)
* stderr on klicio stream:               Opening Prolog I/O.   (line 21)
* stderr on unix stream:                 I/O Opening.          (line 20)
* stdin on klicio stream:                Opening Prolog I/O.   (line 19)
* stdin on unix stream:                  I/O Opening.          (line 18)
* stdout on klicio stream:               Opening Prolog I/O.   (line 20)
* stdout on unix stream:                 I/O Opening.          (line 19)
* string on builtin:                     Predicates on Strings.
                                                               (line  8)
* string on string:                      Predicates on Strings.
                                                               (line  6)
* string on string <1>:                  Predicates on Strings.
                                                               (line  7)
* string_element on builtin:             Predicates and Methods.
                                                               (line 16)
* string_element on builtin <1>:         Predicates on Strings.
                                                               (line 22)
* string_element on builtin <2>:         Predicates on Strings.
                                                               (line 23)
* string_less_than on builtin:           Predicates on Strings.
                                                               (line 28)
* string_not_less_than on builtin:       Predicates on Strings.
                                                               (line 33)
* sub on timer:                          Timer.                (line 36)
* subtract on float:                     Floating Arith.       (line 58)
* sync on C-like I/O:                    Common Msgs (C style).
                                                               (line 38)
* sync on Prolog-like I/O:               Common Msgs (Prolog style).
                                                               (line 13)
* system on unix stream:                 Misc Unix Messages.   (line  9)
* tan on float:                          Floating Arith.       (line 64)
* tanh on float:                         Floating Arith.       (line 70)
* times on unix:                         Predicate Interface.  (line 21)
* umask on unix stream:                  Files & Dirs.         (line 47)
* umask on unix stream <1>:              Files & Dirs.         (line 48)
* unbound on builtin:                    Debugging.            (line  6)
* ungetc on C-like I/O:                  Input Msgs (C style). (line 12)
* ungetc on Prolog-like I/O:             Input Msgs (Prolog style).
                                                               (line 28)
* unix on unix:                          Unix Stream.          (line  9)
* unlink on unix stream:                 Files & Dirs.         (line 13)
* unwrap on variable:                    Wrapped Terms.        (line 45)
* update_open on klicio stream:          Opening Prolog I/O.   (line 25)
* update_open on unix stream:            I/O Opening.          (line 28)
* vector on builtin:                     Predicates on Vectors.
                                                               (line  8)
* vector on vector:                      Predicates on Vectors.
                                                               (line  6)
* vector_element on builtin:             Predicates on Vectors.
                                                               (line 14)
* vector_element on builtin <1>:         Predicates on Vectors.
                                                               (line 15)
* wait on builtin:                       Synchronization.      (line  6)
* wrap on variable:                      Wrapped Terms.        (line 55)
* write_open on klicio stream:           Opening Prolog I/O.   (line 23)
* write_open on unix stream:             I/O Opening.          (line 26)


File: KLIC.info,  Node: Module Index,  Next: Concepts,  Prev: Predicate Index,  Up: Top

Module Index
************

 [index ]
* Menu:

* atom_table:                            Symbolic Atom Operation.
                                                               (line 15)
* functor_table:                         Functor Operation.    (line  8)
* generic (pseudo module):               Generic Objects.      (line  6)
* klicio:                                Opening Prolog I/O.   (line  6)
* system_control:                        System Control.       (line  6)
* unix:                                  Unix.                 (line  6)


File: KLIC.info,  Node: Concepts,  Prev: Module Index,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* aborting:                              Predicate Interface.  (line  6)
* accumulator:                           Usage of Paired Arguments.
                                                               (line  8)
* alternatively:                         Alternatively.        (line  6)
* argument mode:                         Argument Modes.       (line  6)
* argument pair:                         Argument Pair Notation.
                                                               (line  6)
* argument pair name:                    Paired Arguments.     (line  6)
* arithmetics on floating points:        Floating Arith.       (line  6)
* arithmetics on integers:               Integer Arith.        (line  6)
* array:                                 Vectors.              (line  6)
* asynchronous I/O:                      Sockets.              (line 41)
* atom:                                  Symbolic Atoms.       (line  6)
* atomic data:                           Atomic Data.          (line  6)
* body:                                  Basics.               (line  6)
* body method:                           Body Methods.         (line  6)
* break point:                           Spying.               (line  6)
* bug report:                            Reporting Bugs.       (line  6)
* C:                                     Inline C Code.        (line  6)
* C <1>:                                 C-like I/O.           (line  6)
* car:                                   Lists.                (line  6)
* cdr:                                   Lists.                (line  6)
* ceiling:                               Floating Arith.       (line 34)
* character code:                        Notation of Integers. (line 15)
* character code <1>:                    Notation of Integers. (line 29)
* character input:                       Input Msgs (C style). (line  6)
* character output:                      Output Msgs (C style).
                                                               (line  6)
* character string:                      Strings.              (line  6)
* chdir:                                 Files & Dirs.         (line  9)
* class:                                 Predicates and Methods.
                                                               (line 34)
* clause:                                Basics.               (line  6)
* clause <1>:                            Predicates.           (line  6)
* clause preference:                     Alternatively.        (line  6)
* closing a file:                        Common Msgs (C style).
                                                               (line  6)
* command line arguments:                Predicate Interface.  (line  6)
* comparison:                            Comparison and Hashing.
                                                               (line  6)
* comparison of strings:                 Predicates on Strings.
                                                               (line  6)
* comparison on floating points:         Floating Comp.        (line  6)
* comparison on integers:                Integer Comp.         (line  6)
* compilation:                           Compiling.            (line  6)
* concurrent logic programming language: Language.             (line  6)
* configuration:                         Configuration.        (line  6)
* configuration <1>:                     Installation of Distributed KLIC.
                                                               (line  6)
* configuration <2>:                     Installation of Shared-Memory KLIC.
                                                               (line  6)
* cons cell:                             Lists.                (line  6)
* converting integer to floating point:  Creating Floats.      (line  6)
* copyright:                             Copying.              (line  6)
* cosine:                                Floating Arith.       (line 22)
* creating generic objects:              Creating Objects.     (line  6)
* creation of floating point numbers:    Creating Floats.      (line  6)
* creation of vectors:                   Creating Vectors.     (line  6)
* debugging:                             Tracing.              (line  6)
* decrement:                             Macros for Paired Arguments.
                                                               (line  6)
* depth limit of trace display:          Display Control.      (line 34)
* dictionary order:                      Predicates on Strings.
                                                               (line  6)
* difference list:                       Usage of Paired Arguments.
                                                               (line 18)
* directory:                             Files & Dirs.         (line  6)
* distributed KLIC:                      Distributed KLIC.     (line  6)
* distribution:                          Copying.              (line  6)
* dump:                                  Dumping Goals.        (line  6)
* end of file:                           Common Msgs (C style).
                                                               (line  6)
* environment varialble:                 Misc Unix Messages.   (line  6)
* execution:                             Basics.               (line  6)
* exit code:                             Predicate Interface.  (line  6)
* expanded pair:                         Paired Arguments.     (line  6)
* exponential:                           Floating Arith.       (line 28)
* file:                                  Files & Dirs.         (line  6)
* floating point arithmetics:            Floating Arith.       (line  6)
* floating point comparison:             Floating Comp.        (line  6)
* floating point conversion from an integer: Creating Floats.  (line  6)
* floating point notation:               Notation of Floats.   (line  6)
* floating point number:                 Floating Points.      (line  6)
* flooring:                              Floating Arith.       (line 36)
* flushing changes:                      Common Msgs (C style).
                                                               (line  6)
* forking processes:                     Misc Unix Messages.   (line  6)
* functor:                               Functors.             (line  6)
* functor notation:                      Notation of Functors. (line  6)
* garbage collection:                    System Control.       (line  6)
* generic method:                        Predicates and Methods.
                                                               (line 34)
* generic method <1>:                    Generic Objects.      (line  6)
* generic object:                        Generic Objects.      (line  6)
* GHC:                                   Language.             (line  6)
* goal:                                  Goals.                (line  6)
* goal pool:                             Dumping Goals.        (line  6)
* guard:                                 Basics.               (line  6)
* guard method:                          Guard Methods.        (line  6)
* hashing:                               Comparison and Hashing.
                                                               (line  6)
* header file:                           Top Insertion.        (line  6)
* higher order:                          Executable Code.      (line  6)
* hyperbolic function:                   Floating Arith.       (line 26)
* I/O:                                   C-like I/O.           (line  6)
* ICOT Free Software:                    Copying.              (line  6)
* increment:                             Macros for Paired Arguments.
                                                               (line  6)
* initial goal:                          Initial Goal.         (line  6)
* inline:                                Inline C Code.        (line  6)
* input:                                 Input and Output.     (line  6)
* input <1>:                             Input Msgs (C style). (line  6)
* input argument:                        Argument Modes.       (line  6)
* installation:                          Install.              (line  6)
* integer:                               Integers.             (line  6)
* integer arithmetics:                   Integer Arith.        (line  6)
* integer comparison:                    Integer Comp.         (line  6)
* integer to floating point conversion:  Creating Floats.      (line  6)
* interprocess communication:            Messages.             (line  6)
* interrupt:                             Signals.              (line  6)
* interval timer:                        Timer.                (line  6)
* KL1:                                   Language.             (line  6)
* length limit of trace display:         Display Control.      (line 38)
* linkage:                               Compiling.            (line  6)
* Linux:                                 Sockets.              (line 53)
* list:                                  Lists.                (line  6)
* logarithm:                             Floating Arith.       (line 30)
* mailing list:                          Reporting Bugs.       (line  6)
* main:                                  Initial Goal.         (line  6)
* merging:                               Merging.              (line  6)
* message:                               Messages.             (line  6)
* message sending:                       Macros for Paired Arguments.
                                                               (line  6)
* message stream:                        Merging.              (line  6)
* method:                                Predicates and Methods.
                                                               (line  6)
* method <1>:                            Generic Objects.      (line  6)
* module:                                Modules.              (line  6)
* negation:                              Predicates.           (line 30)
* new release:                           Reporting Bugs.       (line  6)
* nil:                                   Lists.                (line  6)
* notation of lists:                     Notation of Lists.    (line  6)
* object creation:                       Creating Objects.     (line  6)
* open:                                  I/O Opening.          (line 29)
* open <1>:                              Opening Prolog I/O.   (line 26)
* operating system:                      Unix.                 (line  6)
* operations on functors:                Functor Operation.    (line  6)
* operator precedence grammar:           Prolog I/O.           (line  6)
* otherwise:                             Predicates.           (line 30)
* output:                                Input and Output.     (line  6)
* output argument:                       Argument Modes.       (line  6)
* paired argument:                       Argument Pair Notation.
                                                               (line  6)
* paired argument <1>:                   Paired Arguments.     (line  6)
* parallel processing:                   Distributed KLIC.     (line  6)
* parallel processing <1>:               Shared-Memory KLIC.   (line  6)
* port:                                  Trace Ports.          (line  6)
* port <1>:                              Port Control.         (line  6)
* postmortem processing:                 System Control.       (line  6)
* predicate:                             Predicates and Methods.
                                                               (line  6)
* predicate <1>:                         Predicates.           (line  6)
* preference of clauses:                 Alternatively.        (line  6)
* principal functor:                     Comparison and Hashing.
                                                               (line 48)
* principal functor <1>:                 Functors.             (line  6)
* priority:                              Priority.             (line  6)
* priority <1>:                          Execution Status.     (line  6)
* process forking:                       Misc Unix Messages.   (line  6)
* program:                               Executable Code.      (line  6)
* PVM:                                   Configuration.        (line  6)
* PVM <1>:                               Distributed KLIC.     (line  6)
* random number:                         Random Numbers.       (line  6)
* reading in:                            Input Msgs (C style). (line  6)
* ready queue:                           Dumping Goals.        (line  6)
* real number:                           Floating Points.      (line  6)
* record structure:                      Functors.             (line  6)
* rounding:                              Floating Arith.       (line 34)
* running:                               Running.              (line  6)
* seek:                                  Common Msgs (C style).
                                                               (line  6)
* shared-memory KLIC:                    Shared-Memory KLIC.   (line  6)
* shell command:                         Misc Unix Messages.   (line  6)
* signal:                                Signals.              (line  6)
* signal sending:                        Misc Unix Messages.   (line  6)
* sine:                                  Floating Arith.       (line 22)
* spy:                                   Spying.               (line  6)
* square root:                           Floating Arith.       (line 32)
* standard input:                        I/O Opening.          (line 21)
* standard input <1>:                    I/O Opening.          (line 21)
* standard input <2>:                    Opening Prolog I/O.   (line 26)
* standard input <3>:                    Opening Prolog I/O.   (line 26)
* standard order:                        Comparison and Hashing.
                                                               (line  6)
* standard output:                       I/O Opening.          (line 21)
* standard output <1>:                   Opening Prolog I/O.   (line 26)
* stdio:                                 I/O Opening.          (line 21)
* stream:                                Merging.              (line  6)
* string:                                Strings.              (line  6)
* string input:                          Input Msgs (C style). (line  6)
* string output:                         Output Msgs (C style).
                                                               (line  6)
* structure:                             Structured Data.      (line  6)
* subterm:                               Display Control.      (line 48)
* suspended goal:                        Dumping Goals.        (line  6)
* symbol:                                Symbolic Atoms.       (line  6)
* symbolic atom:                         Symbolic Atoms.       (line  6)
* synchronization:                       Common Msgs (C style).
                                                               (line  6)
* tangent:                               Floating Arith.       (line 22)
* time:                                  Timer.                (line  6)
* timer:                                 Timer.                (line  6)
* trace display:                         Display Control.      (line  6)
* tracing:                               Tracing.              (line  6)
* trigonometric function:                Floating Arith.       (line 22)
* unbound:                               Debugging.            (line  6)
* unification:                           Unification.          (line  6)
* Unix interface:                        Unix.                 (line  6)
* unlink:                                Files & Dirs.         (line 14)
* update:                                Macros for Paired Arguments.
                                                               (line  6)
* vector:                                Vectors.              (line  6)
* verbose print:                         Display Control.      (line 42)
* wrapped term:                          Wrapped Terms.        (line  6)
* writing out:                           Output Msgs (C style).
                                                               (line  6)



Tag Table:
Node: Top439
Node: Copying9742
Node: Introduction14910
Node: Description16043
Node: Predicates and Methods16414
Node: Messages18655
Node: Argument Modes20043
Node: Reporting Bugs20673
Node: Language21316
Node: Basics22719
Node: Predicates24325
Node: Modules26583
Node: Goals27448
Node: Initial Goal28484
Node: Generic Objects28992
Node: Creating Objects30280
Node: Guard Methods30817
Node: Body Methods31623
Node: Priority32360
Node: Alternatively33971
Node: Argument Pair Notation35413
Node: Paired Arguments35866
Node: Macros for Paired Arguments39481
Node: Usage of Paired Arguments40673
Node: Inline C Code41369
Node: Top Insertion42256
Node: Guard Insertion43210
Node: C-Level Rep45862
Node: Examples of Inline47116
Node: Hints of Inline48377
Node: Builtin and Library49835
Node: Common Operations50658
Node: Unification51216
Node: Synchronization52018
Node: Comparison and Hashing52259
Node: Execution Status55614
Node: Debugging56453
Node: Atomic Data57759
Node: Symbolic Atoms58838
Node: Notation of Atoms59265
Node: Symbolic Atom Operation60907
Node: Integers62560
Node: Notation of Integers63142
Node: Integer Arith64847
Node: Integer Comp66771
Node: Floating Points67670
Node: Notation of Floats68320
Node: Creating Floats68958
Node: Floating Arith69666
Node: Floating Comp72443
Node: Structured Data74103
Node: Functors74583
Node: Notation of Functors75122
Node: Functor Operation75797
Node: Lists78557
Node: Notation of Lists79736
Node: Merging81182
Node: Vectors86120
Node: Notation of Vectors86766
Node: Creating Vectors87304
Node: Predicates on Vectors88362
Node: Strings90866
Node: Notation of Strings91588
Node: Creating Strings93322
Node: Predicates on Strings94666
Node: Executable Code97889
Node: Module Type98377
Node: Predicate Type99176
Node: Unix101726
Node: Unix Stream102674
Node: I/O Opening104200
Node: Sockets105706
Node: Files & Dirs108282
Node: Signals110428
Node: Misc Unix Messages111292
Node: Predicate Interface113498
Node: Input and Output114541
Node: C-like I/O115264
Node: Common Msgs (C style)116009
Node: Input Msgs (C style)117813
Node: Output Msgs (C style)119122
Node: Prolog I/O120369
Node: Opening Prolog I/O121399
Node: Common Msgs (Prolog style)123408
Node: Input Msgs (Prolog style)124274
Node: Output Msgs (Prolog style)125782
Node: Wrapped Terms128043
Node: System Control130830
Node: Timer132315
Node: Random Numbers135270
Node: Using KLIC136244
Node: Compiling136720
Node: Command for Compilation137230
Node: Compiler Options138769
Node: Mechanism of Compilation141880
Node: Running143398
Node: Runtime Switches143930
Node: Tracing146746
Node: Preparing for Trace147683
Node: Trace Ports148564
Node: Output of Tracer150616
Node: Controlling Trace155403
Node: Goal Control156093
Node: Subgoal Control156878
Node: Predicate Control157816
Node: Spying159533
Node: Port Control160406
Node: Display Control161684
Node: Dumping Goals164503
Node: Misc Trace Commands164990
Node: Perpetual Suspension165781
Node: Install166712
Node: Configuration167580
Node: Make All169430
Node: Make Tests169735
Node: Make Install170213
Node: Make Distclean170542
Node: Troubles171050
Node: Distributed KLIC172388
Node: Installation of Distributed KLIC173393
Node: Compiling Programs for Distributed KLIC174854
Node: Running Programs of Distributed KLIC175384
Node: Setting Up PVM175711
Node: Runtime Options for Distributed KLIC176728
Node: Known Bugs of Distributed KLIC178659
Node: Shared-Memory KLIC179107
Node: Installation of Shared-Memory KLIC179765
Node: Compiling Programs for Shared-Memory KLIC180510
Node: Running Programs of Shared-Memory KLIC181056
Node: Runtime Options for Shared-Memory KLIC181378
Node: Known Bugs of Shared-Memory KLIC182178
Node: Type Index182455
Node: Predicate Index183331
Node: Module Index204172
Node: Concepts204816

End Tag Table
