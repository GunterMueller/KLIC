This is Info file KLIC.info, produced by Makeinfo version 1.68 from the
input file klic.tex.

   This file documents KLIC, a portable implementation of KL1.  The
contents of this manual correspond to KLIC version 3.002.

   Copyright 1994, 1995 Institute for New Generation Computer
Technology\\ (Read COPYRIGHT for detailed information.)\\ (C)1996,
1997, 1998, 1999 Japan Information Processing Development Center\\
(Read COPYRIGHT-JIPDEC for detailed information.)


File: KLIC.info,  Node: Top,  Next: Copying,  Prev: (dir),  Up: (dir)

KLIC
****

   KLIC is a portable implementation of KL1.  KL1 is a concurrent logic
programming language based on Guarded Horn Clauses (GHC, in short).
KL1 has very simple and concise syntax and semantics and yet provides
very powerful features for concurrent computation.

* Menu:

* Copying::                     Copyright notices
* Introduction::                How to read this manual
* Language::                    Features of KLIC KL1 language
* Builtin and Library::         Builtin and library features
* Using KLIC::                  How to use the KLIC system
* Type Index::                  Index of data types
* Predicate Index::             Index of predicates, methods and messages
* Module Index::                Index of program modules
* Concepts::                    Index of various concepts

 -- The Detailed Node Listing --

Introduction

* Description::                 Description of predicates &c
* Reporting Bugs::              Reporting system problems

Description of Predicates and Methods

* Predicates and Methods::      Two forms of procedures
* Messages::                    Messages to processes
* Argument Modes::              Input/output modes of arguments

KL1 Language

* Basics::                      Basic execution mechanism of the language
* Predicates::                  Predicates correspond to subroutines
* Modules::                     Module is a set of predicates
* Goals::                       Goals are units of execution of KL1
* Initial Goal::                How program execution starts
* Generic Objects::             Generic objects extends features of KLIC
* Priority::                    Specifying scheduling preference
* Alternatively::               Preference among clauses
* Argument Pair Notation::
* Inline C Code::               Inserting C code inline

Generic Objects

* Creating Objects::            How to create generic objects
* Guard Methods::               Operations on data objects in guards
* Body Methods::                Operations on data objects in bodies

Shorthand Notation for Argument Pairs

* Paired Arguments::
* Macros for Paired Arguments::
* Usage of Paired Arguments::

Inserting C Language Code Inline

* Top Insertion::               Inserting C program text at the top
* Guard Insertion::             Inserting C program text in guards
* C-Level Rep::                 C-level representation of KL1 terms
* Examples of Inline::          Some examples of inline C code
* Hints of Inline::             Some hints on using inline C code

Builtin and Library Features

* Common Operations::           Operations common to all the data types
* Atomic Data::                 Atomic data and their operation
* Structured Data::             Structured data and their operation
* Executable Code::             Higher order manipulation of executable code
* Unix::                        Interfacing with the operating system
* Input and Output::            Input and output from and to files &c
* System Control::              Controlling system behavior
* Timer::                       Timing and interval timer
* Random Numbers::              Random number generator

Common Operations

* Unification::                 Unifying two terms
* Synchronization::             Waiting for data availability
* Comparison and Hashing::      Comparing and hashing terms
* Execution Status::            Knowing about execution status
* Debugging::                   Debugging support

Atomic Data

* Symbolic Atoms::              Symbolic atoms give names to various concepts
* Integers::                    Integer data and their operations
* Floating Points::             Floating point data and their operations

Symbolic Atoms

* Notation of Atoms::           Notation of symbolic atoms
* Symbolic Atom Operation::     Operations on symbolic atoms

Integer Atoms

* Notation of Integers::        Notation of integers
* Integer Arith::               Integer arithmetics
* Integer Comp::                Integer comparison

Floating Point Numbers

* Notation of Floats::          Notation of floating point numbers
* Creating Floats::
* Floating Arith::              Floating point arithmetics
* Floating Comp::               Floating comparison

Structured Data

* Functors::                    Named data structures
* Lists::                       Linear list of elements
* Vectors::                     One-dimensional arrays of any data
* Strings::                     Array of small integers such as character codes

Functor Structures

* Notation of Functors::        Notation of functors
* Functor Operation::           Operation on fucntor structures

Lists

* Notation of Lists::           Notation of Lists
* Merging::                     Merging messages from multiple streams

Vectors

* Notation of Vectors::         Constant notation of vectors
* Creating Vectors::            Creating new vectors
* Predicates on Vectors::       Vector manipulation predicates

Strings

* Notation of Strings::         Constant notation of strings
* Creating Strings::            Creating new strings
* Predicates on Strings::       String manipulation predicates

Handling Program Code as Data

* Module Type::                 Program modules as data
* Predicate Type::              Predicates as data

Unix Interface

* Unix Stream::                 Obtaining Unix interface stream
* I/O Opening::                 Opening input/output streams
* Sockets::                     Internet- and Unix-domain protocol sockets
* Files & Dirs::                Manipulation of files and directories
* Signals::                     Signal interrupt handling
* Misc Unix Messages::          Miscellaneous messages to the Unix stream
* Predicate Interface::         Predicate interface for command line args &c

Input and Output

* C-like I/O::                  I/O with C language-like interface
* Prolog I/O::                  I/O with Prolog language-like interface

Input and Output with C-like Interface

* Common Msgs (C style)::       Messages common to both input and output
* Input Msgs (C style)::        Messages for C-like input streams
* Output Msgs (C style)::       Messages for C-like output streams

Input and Output with Prolog-like Interface

* Opening Prolog I/O::          Opening Prolog-like I/O streams
* Common Msgs (Prolog style)::  Message common to input and output streams
* Input Msgs (Prolog style)::   Input messages with Prolog-like interface
* Output Msgs (Prolog style)::  Output messages with Prolog-like interface
* Wrapped Terms::               Manipulation of wrapped terms

Using KLIC

* Compiling::                   How to compile KL1 programs
* Running::                     How to run programs compiled with KLIC
* Tracing::                     Tracing execution for debugging
* Install::                     Installation of KLIC
* Distributed KLIC::            Distributed memory parallel implementation
* Shared-Memory KLIC::          Shared-memory parallel implementation

Compiling Programs with KLIC

* Command for Compilation::     Program compilation command
* Compiler Options::            Compiler options
* Mechanism of Compilation::    How programs are compiled

Running Programs Compiled with KLIC

* Runtime Switches::            Runtime command line switches

Tracing Program Execution

* Preparing for Trace::         Compiling your program to be traced
* Trace Ports::                 Places you stop at stepping execution
* Output of Tracer::            How your program execution process is displayed
* Controlling Trace::           Controlling which are traced and which are not
* Spying::                      Setting spypoints = break points
* Port Control::                Enabling and disabling tracing of each port
* Display Control::             Controlling the verbosity of trace display
* Dumping Goals::               Displaying all ready or suspended goals
* Misc Trace Commands::         Miscellaneous commands
* Perpetual Suspension::        Detecting goals that can never proceed

Trace Controlling Commands

* Goal Control::                Controlling trace of the traced goal
* Subgoal Control::             Controlling trace of newly created subgoals
* Predicate Control::           Changing default trace of predicates

Installation

* Configuration::               Configuration script
* Make All::                    Compiling the system
* Make Tests::                  Testing the compilation
* Make Install::                Actually installing the system
* Make Distclean::              Cleaning up after installation
* Troubles::                    What to do when you have some trouble

Distributed Memory Parallel Implementation of KLIC

* Installation of Distributed KLIC::
* Compiling Programs for Distributed KLIC::
* Running Programs of Distributed KLIC::

Running Programs of Distributed KLIC

* Setting Up PVM::
* Runtime Options for Distributed KLIC::
* Known Bugs of Distributed KLIC::

Shared-Memory Implementation of KLIC

* Installation of Shared-Memory KLIC::
* Compiling Programs for Shared-Memory KLIC::
* Running Programs of Shared-Memory KLIC::

Running Programs of Shared-Memory KLIC

* Runtime Options for Shared-Memory KLIC::
* Known Bugs of Shared-Memory KLIC::


File: KLIC.info,  Node: Copying,  Next: Introduction,  Prev: Top,  Up: Top

Terms and Conditions for Use of ICOT Free Software
**************************************************

*1. Purposes and Background of ICOT Free Software.*

   The Institute for New Generation Computer Technology ("ICOT") had
been promoting the Fifth Generation Computer Systems project under the
commitment of the Ministry of International Trade and Industry of Japan
(the "MITI").  Since April 1993, ICOT has been promoting the Follow-on
project to the FGCS project. This follow-on project aims to disseminate
and further develop FGCS technology.  The FGCS project and the
Follow-on project (collectively, the "Project") have been aimed at
creating basic technology for novel computers that realizes parallel
inference processing as their core mechanism, and contributing toward
the progress of computer science by sharing innovative knowledge and
technology with the research community worldwide.

   Innovative hardware and software parallel inference technology has
been under development through the Project, which involves varieties of
advanced software for experiments and evaluation.  This software, being
at a basic stage of research and development, should be disseminated
widely to the research community.

   According to the aims of the Project, ICOT has made this software,
the copyright of which does not belong to the government but to ICOT
itself, available to the public in order to contribute to the world,
and, moreover, has removed all restrictions on its usage that may have
impeded further research and development in order that large number of
researchers can use it freely to begin a new era of computer science.

   This program together with any attached documentation (collectively,
the "Program") is being distributed by ICOT free of charge as "ICOT
Free Software".

*2. Free Use, Modification, Copying and Distribution*

   Persons wanting to use the Program ("Users") may freely do so and
may also freely modify and copy the Program.  The term "modify," as
used here, includes, but is not limited to, any act to improve or expand
the Program for the purposes of enhancing and/or improving its function,
performance and/or quality as well as to add one or more programs or
documents developed by Users of the Program.

   Each User may also freely distribute the Program, whether in its
original form or modified, to any third party or parties, *PROVIDED*
that the provisions of Section 3 (*NO WARRANTY*) will *ALWAYS* appear
on, or be attached to, the Program, which is distributed substantially
in the same form as set out herein and that such intended distribution,
if actually made, will neither violate or otherwise contravene any of
the laws and regulations of the countries having jurisdiction over the
User or the intended distribution itself.

*3. NO WARRANTY*

   The program was produced on an experimental basis in the course of
the research and development conducted during the project and is
provided to users as so produced on an experimental basis.  Accordingly,
the program is provided without any warranty whatsoever, whether
express, implied, statutory or otherwise.  The term "warranty" used
herein includes, but is not limited to, any warranty of the quality,
performance, merchantability and fitness for a particular purpose of the
program and the nonexistence of any infringement or violation of any
right of any third party.

   Each user of the program will agree and understand, and be deemed to
have agreed and understood, that there is no warranty whatsoever for the
program and, accordingly, the entire risk arising from or otherwise
connected with the program is assumed by the user.

   Therefore, neither ICOT, the copyright holder, or any other
organization that participated in or was otherwise related to the
development of the program and their respective officials, directors,
officers and other employees shall be held liable for any and all
damages, including, without limitation, general, special, incidental and
consequential damages, arising out of or otherwise in connection with
the use or inability to use the program or any product, material or
result produced or otherwise obtained by using the program, regardless
of whether they have been advised of, or otherwise had knowledge of, the
possibility of such damages at any time during the project or
thereafter.  Each user will be deemed to have agreed to the foregoing by
his or her commencement of use of the program.  The term "use" as used
herein includes, but is not limited to, the use, modification, copying
and distribution of the program and the production of secondary products
from the program.

   In the case where the program, whether in its original form or
modified, was distributed or delivered to or received by a user from any
person, organization or entity other than ICOT, unless it makes or
grants independently of ICOT any specific warranty to the user in
writing, such person, organization or entity, will also be exempted from
and not be held liable to the user for any such damages as noted above
as far as the program is concerned.


File: KLIC.info,  Node: Introduction,  Next: Language,  Prev: Copying,  Up: Top

Introduction
************

   This manual describes a portable implementation of KL1 called KLIC,
developed at Institute for New Generation Computer Technology as a part
of the Fifth Generation Computer national project of Japan and its
follow-on project.

   KL1 is a concurrent logic programming language based on Guarded Horn
Clauses (GHC, in short).  KL1 has very simple and concise syntax and
semantics and yet provides very powerful features for concurrent
computation.

   KLIC compiles KL1 programs to C programs.  A C compiler of the host
system then compiles the C programs to relocatable objects, which will
then be linked together with the runtime library of KLIC (*note How
KLIC Compiler Works: Mechanism of Compilation.).  Thus, the system is
independent from the hardware architecture of the host system.  Also,
the system is written so that only minimal features of Unix are used to
assure portability.

* Menu:

* Description::                 Description of predicates &c
* Reporting Bugs::              Reporting system problems


File: KLIC.info,  Node: Description,  Next: Reporting Bugs,  Prev: Introduction,  Up: Introduction

Description of Predicates and Methods
=====================================

* Menu:

* Predicates and Methods::      Two forms of procedures
* Messages::                    Messages to processes
* Argument Modes::              Input/output modes of arguments


File: KLIC.info,  Node: Predicates and Methods,  Next: Messages,  Prev: Description,  Up: Description

Predicates and Methods
----------------------

   Unlike other logic programming language systems, KLIC provides two
kinds of procedures, predicates and generic methods.  Predicates define
relations on their arguments and their semantics is fixed.  Generic
methods, (or methods, simply) are defined by *objects* they are applied
to.  Thus, their semantics depends on the object applied.

   Sometimes the same operation is provided by both predicates and
methods.  For example, obtaining an element of a string can be done by
either of the following two.

 - Body Predicate on builtin: string_element +STRING +INDEX -ELEMENT
 - Body Method on string: element +STRING +INDEX -ELEMENT

The former is a builtin predicate of the system.  Predicate invocations
are written as follows.

     MODULENAME:PREDICATENAME(ARGUMENTS, ...)

In case of the predicate `string_element' mentioned above, it is
defined as a builtin predicate and thus no module name is needed in its
invocation.  Thus, an invocation is written as follows.

     string_element(STRING, INDEX, ELEMENT)

In general, a module name may come first with a colon before the
predicate name.  Some predicates do not have any arguments.  In such
cases, parentheses enclosing arguments are also omitted.

   The latter is a generic method defined on the objects of class
`string'.  Method invocation is written as follows.

     generic:METHODNAME(OBJECT, OTHERARGUMENTS, ...)

In case of the method `element' mentioned above, its invocation is
written as follows.

     generic:element(STRING, INDEX, ELEMENT)

   The same operation may be effected using either a predicate or a
method.  For example, obtaining the third element (element number 2) of
a string S into E can be done by either of the following invocations.

     string_element(S, 2, E)
     generic:element(S, 2, E)

Note that, while the predicate `string_element' is only for obtaining
an element of a string, a generic method invocation can also be used to
obtain an element of *similar* object.  For example, an element of a
vector (one-dimensional array) can also be obtained by the same
invocation.


File: KLIC.info,  Node: Messages,  Next: Argument Modes,  Prev: Predicates and Methods,  Up: Description

Messages
--------

   KL1 programs often consist of many *processes*.  Processes often
communicate one another using *streams*.  Streams are actually lists of
*messages*.  Lists are made of cells called *cons* cells with two
fields *car* and *cdr*, just as in Lisp or similar languages.  Thus,
when used as message streams, the car part of a cons cell contains the
message and the cdr contains the rest of the stream.

   Some standard features of the KLIC system are also provided as
processes with message stream interface.  An example of such message
described in this manual follows.

 - Message on C-like I/O: putc +C

This means that a message named `putc' is accepted as a message to a
C-like I/O process interface stream.  The message has one argument
called C in this case.

   To send a message to a message stream, the variable referring to the
message stream should be instantiated with a cons cell whose car
contains the message and cdr contains the rest of the stream.  Thus,
when `S' is a stream to C-like I/O and character with code 10 is to be
output, the following unification should be made.

     S = [putc(10)|T]

Here, the variable `T' is given the rest of the stream and thus any
following messages to the stream should be sent to this variable.


File: KLIC.info,  Node: Argument Modes,  Prev: Messages,  Up: Description

Argument Modes
--------------

   Arguments of predicates, methods or messages may have specific
input/output mode.  Input arguments are read by invocation of predicates
or methods; the invocation will be suspended if any of the input
arguments are left undefined.  Output arguments are given a value by the
invocation.

   In the description of predicates and methods, input arguments are
marked with a `+' and output arguments are marked with a `-'.  Some
arguments are not either read or given value.  Such arguments are marked
with a `?'.


File: KLIC.info,  Node: Reporting Bugs,  Prev: Description,  Up: Introduction

Reporting Bugs and Sending Comments
===================================

   Please report bugs and comments on the KLIC system and this document
to the following mail address.

     `klic-bugs@icot.or.jp'.

   There is a mailing list for users of KLIC.  This mailing list is used
for announcement from the developers on known bugs, fixes or
availability of new releases.  The same mailing list can also be used
for communication among users.  To subscribe to the mailing list, please
send your request to the following address.

     `klic-requests@icot.or.jp'


File: KLIC.info,  Node: Language,  Next: Builtin and Library,  Prev: Introduction,  Up: Top

KL1 Language
************

   KL1 is a programming language for describing concurrent computation
based on Guarded Horn Clauses (GHC, in short).  GHC belongs to a family
of languages called concurrent logic programming languages or
committed-choice logic programming languages.  Languages that belong to
the family are, for example, Concurrent Prolog, Parlog, Fleng, Strand
and Janus.  These languages have simple and concise syntax and semantics
and yet provide very powerful features for concurrent computation.

   Here, a very rough and informal description of the KL1 language is
given.  More detailed and accurate specification are planned to be
supplied in future (hopefully).

* Menu:

* Basics::                      Basic execution mechanism of the language
* Predicates::                  Predicates correspond to subroutines
* Modules::                     Module is a set of predicates
* Goals::                       Goals are units of execution of KL1
* Initial Goal::                How program execution starts
* Generic Objects::             Generic objects extends features of KLIC
* Priority::                    Specifying scheduling preference
* Alternatively::               Preference among clauses
* Argument Pair Notation::
* Inline C Code::               Inserting C code inline


File: KLIC.info,  Node: Basics,  Next: Predicates,  Prev: Language,  Up: Language

Basic Execution Mechanism
=========================

   The following is an example of a small KL1 program that defines a
part of quicksort program.

   Example 1: Quicksort

     :- module quicksort.
     
     sort(X, Y) :- sort(X, Y, []).
     
     sort([], Y, Z) :- Y = Z.
     sort([P|X], Y, Z) :-
         partition(P, X, X1, X2),
         sort(X1, Y, [P|Y1]),
         sort(X2, Y1, Z).
     
     partition(_, [], S, L) :-
         S = [],
         L = [].
     partition(P, [W|X], S, L) :- W =< P |
         S = [W|S1],
         partition(P, X, S1, L).
     partition(P, [W|X], S, L) :- W >= P |
         L = [W|L1],
         partition(P, X, S, L1).

   The first line, `:- module quicksort' declares that this program
module will be called `quicksort' (*note Modules::.).

   Execution of a KL1 program is a (possibly parallel) repetitive
reduction of given "goals" using program "clauses".  Each clause has the
following form.

     PREDICATENAME(ARGUMENT PATTERN ...) :- GUARD | BODY.

   When a goal is to be reduced, clauses for the predicate of the goal
will be inspected.  For clauses with matching argument pattern, their
guard parts are tested.  All the clauses with matching argument pattern
and satisfied guard conditions are candidates to be used in the
reduction.  Only one of them, *arbitrarily chosen,* will be used and the
original goal will be replaced by the goals in the body of the clause
chosen.

   If no guard condition tests are required, the guard part along with
the vertical bar can be omitted.


File: KLIC.info,  Node: Predicates,  Next: Modules,  Prev: Basics,  Up: Language

Predicates
==========

   "Predicates" of KL1 corresponds to subroutines of Fortran or
functions of C.  Predicates are defined by a collection of clauses with
the same predicate name and the same number of arguments in their heads.
Unlike in some other languages, predicates are identified not only by
their names but also by their "arities" (numbers of arguments).  To
identify predicates with the same name but different arities, the
notation `PREDICATE/ARITY' is used in this manual.

   In the example of the quicksort program, two predicates with the same
name `sort', with 2 and 3 arguments respectively, are defined (*note
Basic Execution Mechanism: Basics.).  Such predicates are referred to
as `sort/2' and `sort/3' respectively.

   The order of clauses defining a predicate does not affect the
meaning.  For example, a predicate for computing maximum of two integer
values can be defined as follows.
     max(X, Y, M) :- X >= Y | M = X.
     max(X, Y, M) :- X =< Y | M = Y.

Exactly the same predicate can be defined by reversing the order of the
clauses as follows.
     max(X, Y, M) :- X =< Y | M = Y.
     max(X, Y, M) :- X >= Y | M = X.

   When a set of clauses are to be used *only when* another set of
clauses are known not to be applicable, the keyword `otherwise' should
be put in between the two sets of clauses.  For example, the above
`max' predicate may be defined as follows.
     max(X, Y, M) :- X >= Y | M = X.
     otherwise.
     max(X, Y, M) :- M = Y.

The meaning of the predicate is almost the same except that this version
succeeds after unifying `M' with `Y' even when `X' or `Y' does not have
an integer value, while the two previous versions will fail.

   The `otherwise' directive specifies that clauses after the directive
should not be applied unless all the clauses preceding the directive
are known not to be applicable, even with any information (variable
bindings) may become available afterwards.  This feature should *not*
be confounded with the `alternatively' directive, which specifies that
clauses preceding the directive should be given priority to the clauses
following (*note Clause Preference: Alternatively.).


File: KLIC.info,  Node: Modules,  Next: Goals,  Prev: Predicates,  Up: Language

Modules
=======

   KL1 provides "module" structure for dividing large programs into
many modules.  A module consists of one or more predicates.  Definition
of a module starts with a module declaration of the form `:- module
MODULE.' Clauses defining predicates in the module will follow.  The
end of the file or another module declaration ends the definition of
the module.

   In the quicksort example, the first line:

     :- module quicksort

declares that this program module is called `quicksort' (*note Basic
Execution Mechanism: Basics.).

   Predicates defined with the same name and arity but in different
modules are considered to be different predicates.  Thus, when
necessary, the notation `MODULE:PREDICATE/ARITY' is used to explicitly
specify the module name.


File: KLIC.info,  Node: Goals,  Next: Initial Goal,  Prev: Modules,  Up: Language

Goals
=====

   A Goal is a unit of execution of KL1.  Goals are associated with a
predicate.  A goal is reduced to zero or more simpler goals by applying
one of the clauses defining the predicate.

   Goals are written as:

     PREDICATE(ARGUMENTS, ...)

or simply as the following.

     PREDICATE

when the predicate has no arguments.

   When the predicate is not in the same module, the syntax is either:

     MODULE:PREDICATE(ARGUMENTS, ...)

or as the following.

     MODULE:PREDICATE

   For example, a module named `main' that uses the quicksort module
might be defined as follows (*note Basic Execution Mechanism: Basics.).

   Example 2: Module using `quicksort'

     :- module main.
     
     main :-
         X = [9,2,8,3,6,7,4,1,5],
         builtin:print(X),
         quicksort:sort(X, Y),
         builtin:print(Y).

Here, the body goal `quicksort:sort(X, Y)' is associated with the
predicate `sort/2' of the module `quicksort'.


File: KLIC.info,  Node: Initial Goal,  Next: Generic Objects,  Prev: Goals,  Up: Language

Initial Goal
============

   All KLIC programs start from the initial goal `main:main', i.e., the
predicate `main' with no arguments defined in the module `main'.  The
example of the module `main' (*note Goals::.) is an example of a main
program.

   Command line arguments are not passed to the initial goal.
Predicates to access command line arguments are provided separately
(*note Predicate Interface::.).


File: KLIC.info,  Node: Generic Objects,  Next: Priority,  Prev: Initial Goal,  Up: Language

Generic Objects
===============

   "Generic objects" provide a framework to extend the KL1 language
with new data types and their operations.  There are three kinds of
generic objects, namely, "data objects", "consumer objects" and
"generator objects".

   Generic objects are created by pseudo-predicates `generic:new'.
Generic data objects are similar to usual KL1 data.  Operations on data
objects are defined by their "generic methods".  Methods are invoked by
pseudo-predicates `generic:METHOD'.  Consumer and generator objects
look like variables to normal KL1 programs and operations on them are
implicit by unification.

   Many of the standard types of KLIC, vectors and strings, for example,
are actually implemented as generic data objects.  For them, builtin
predicates can also be used as aliases for generic methods.  For
example, `set_vector_element(ORIGINAL, INDEX, NEWELEMENT, NEW)' means
the same as `generic:set_element(ORIGINAL, INDEX, NEWELEMENT, NEW)'.

* Menu:

* Creating Objects::            How to create generic objects
* Guard Methods::               Operations on data objects in guards
* Body Methods::                Operations on data objects in bodies


File: KLIC.info,  Node: Creating Objects,  Next: Guard Methods,  Prev: Generic Objects,  Up: Generic Objects

Creating Generic Objects
------------------------

   Generic objects are created by the following pseudo-predicate.

     generic:new(CLASSNAME, OBJECT, ARGS, ...)

CLASSNAME should be a symbolic atom which names the object class.  By
this invocation, a new generic object is created and associated with
OBJECT.  Parameters for creation can be specified by ARGS.  The meaning
of ARGS depends on each object class.


File: KLIC.info,  Node: Guard Methods,  Next: Body Methods,  Prev: Creating Objects,  Up: Generic Objects

Guard Methods of Generic Data Objects
-------------------------------------

   Clause selection depending on generic data objects can be done by
calling guard methods.  Guard methods have the following format.

     generic:METHOD(OBJECT, INPUT, ...):OUTPUT:...

   `INPUT, ...' specify input arguments.  If any of the input arguments
are left undefined, this invocation will be suspended.  `OUTPUT:...'
specify output arguments, which are returned from the method.  If some
concrete value is specified as an OUTPUT, guard unification of the
specified and returned values will be made.  Some guard methods have no
output arguments, in which case colon and following OUTPUT are omitted.


File: KLIC.info,  Node: Body Methods,  Prev: Guard Methods,  Up: Generic Objects

Body Methods of Generic Data Objects
------------------------------------

   Operations on generic data objects can be done by calling body
methods.  Body methods have the following format.

     generic:METHOD(OBJECT, ARGS, ...)

Unlike guard methods, input and output arguments are not syntactically
distinguished.  The method to be called can be determined in runtime.
To do that, an alternative format is provided.

     generic:generic(OBJECT, FUNCTOR)

With this format, FUNCTOR should be (or become in runtime) a functor
structure of the format `METHOD(ARGS, ...)'.  Invocation will be
suspended until FUNCTOR will become instantiated.


File: KLIC.info,  Node: Priority,  Next: Alternatively,  Prev: Generic Objects,  Up: Language

Priority Specification
======================

   Goals have execution priority associated with them.  Execution
priority is specified by a positive integer value.  Goals with larger
priority values are (usually) executed earlier than goals with smaller
priority values.  However, priority specifications are no more than
suggestions and actual implementations may or may not strictly obey
them.

   Body goals can have execution priority specification in one of the
following formats.

             `GOAL@priority(ABSPRIO)'
     `GOAL@lower_priority(RELPRIO)'
     `GOAL@lower_priority'

Here, ABSPRIO and RELPRIO should be a non-negative integer constant, or
a variable which should be instantiated to a non-negative integer
later.  In the current implementation, negative priority values are
interpreted as zero.

   With the absolute priority specification, the goal with the
specification will have the priority value specified by ABSPRIO.  With
the relative priority specification, the goal will have priority less
than the priority of the parent goal by the amount specified by
RELPRIO.  The specification `GOAL@lower_priority' has the same effect
as `GOAL@lower_priority(1)'.  Goals without any priority specifications
will have the same priority as their parents.

   The highest possible priority is the largest possible integer value,
which depends on host systems (*note Integer Atoms: Integers.).  The
initial goal `main:main' has the maximum priority possible for the host
system (*note Initial Goal::.).


File: KLIC.info,  Node: Alternatively,  Next: Argument Pair Notation,  Prev: Priority,  Up: Language

Clause Preference
=================

   Predicates of KL1 may have nondeterminacy; more than one clause may
be applicable.  In such cases, preference among clauses may be specified
using the `alternatively' directive.

   When the keyword `alternatively' is put in between two sets of
clauses, clauses preceding it are *preferred* to those following it.
However, when clauses preceding the `alternatively' directive cannot be
applied directly due to lack of information (insufficient instantiation
of variable values), the clauses following it may be used.  This
feature is often useful in controlling speculative computation
depending on progress of computation.

   The feature is not be confounded with the `otherwise' feature (*note
Predicates::.).  For example, consider the following two predicates.

     p(1, Y, R) :- R = a.
     alternatively.
     p(X, 2, R) :- R = b.
     
     q(1, Y, R) :- R = a.
     otherwise.
     q(X, 2, R) :- R = b.

When the first argument is still undefined and the second is `2', the
predicate `p' may return `b' to the third argument using its second
clause.  The predicate `q' will wait until the value of the first
argument becomes available.  Thus, if the first argument eventually
becomes `1', the predicate `q' is guaranteed to return `a', but the
predicate `p' may return either `a' or `b'.


File: KLIC.info,  Node: Argument Pair Notation,  Next: Inline C Code,  Prev: Alternatively,  Up: Language

Shorthand Notation for Argument Pairs
=====================================

   KL1 programs often require passing two arguments as a pair to a
predicate: one as input and the other as output.  KLIC provides a
shorthand notation for such cases.

* Menu:

* Paired Arguments::
* Macros for Paired Arguments::
* Usage of Paired Arguments::


File: KLIC.info,  Node: Paired Arguments,  Next: Macros for Paired Arguments,  Prev: Argument Pair Notation,  Up: Argument Pair Notation

Paired Arguments and their Expansion
------------------------------------

   The head and goals in both guard and body parts of a clause can have
argument pairs specified by a single variable name attached to the head
or goals by a hyphen character.  We call such pseudo variable an
"argument pair name".  An example is shown here.

     p(X,Y)-Pair :- q(X)-Pair, s(Z)-Pair, r(Pair,Y), t(Z)-Pair.

The pseudo-variable `Pair' is an argument pair name.  Such a clause is
interpreted the same as the following clause.

     p(X,Y,P0,P) :- q(X,P0,P1), s(Z,P1,P2), r(P2,Y), t(Z,P2,P).

Occurrences of argument pair names attached to the head or goals by a
hyphen character are interpreted as a pair of two different variables
added at the end of the argument lists.  In what follows, we call the
two variables generated from an paired argument an "expanded pair".

   The second of an expanded pair of a goal is the same as the first of
the expanded pair of the next goal with the same argument pair name.
In the example above, `P1' appearing as the third argument of the goal
of `q/3' also appears as the second argument of `s/3', as originally
they both have the same argument pair name `Pair'.

   The first of an expanded pair in the head will be the same as the
first of the expanded pair in the first goal in the clause with the same
argument pair name.  The second of an expanded pair in the head will be
the same as the second of the expanded pair in the last goal with the
same argument pair name.

   In the above example, the first of the expanded pair `P0' in the
head appears again as the second argument of the first goal calling
`q/3', and `P', the second of the expanded pair in the head, appears
again as the third argument of the last goal of `t/3'.

   If the argument pair name appears only in the head, two variables of
the expanded pair are unified in the body.  For example, a clause:

     p(X)-Y :- q(X).

is expanded into the following.

     p(X,Y0,Y) :- Y0=Y, q(X).

   An argument pair name may appear at a usual argument position rather
than being attached to the head or goals, as does the first argument of
the goal for `r/2' in the above example.  In such a case, it is
expanded to a single variable.  This variable is the same as the second
of the last expanded pair and is also the same as the first of the next
expanded pair.  Thus, in the above example, `Pair' appearing as the
first argument of `r/2' is expanded into `P2', which is the same as the
third argument of `s/3' and the second argument of `t/3'.

   Arbitrarily many argument pair names can be specified for a head or a
goal.  For example, a clause such as:

     p-X-Y :- q-X, r-Y, s-Y-X.

is interpreted as follows.

     p(X0,X,Y0,Y) :- q(X0,X1), r(Y0,Y1), s(Y1,Y,X1,X).

   Sometimes, specifying normal arguments after some argument pair
names is desirable.  This can be done by connecting them with a plus
(`+') character.  For example:

     p-X+Y :- q-X+35, r(Y), s+Y-X.

is interpreted as follows.

     p(X0,X,Y) :- q(X0,X1,35), r(Y), s(Y,X1,X).

   Note that the expansion rules for paired arguments described above
are position sensitive for goals.  However, this does *not* at all mean
that the execution order of body goals are constrained anyhow.

   Also note that the argument pair notation is no more than macro
expansion of clauses.  One predicate may have clauses some of which
written in the argument pair notation and others in the usual notation.


File: KLIC.info,  Node: Macros for Paired Arguments,  Next: Usage of Paired Arguments,  Prev: Paired Arguments,  Up: Argument Pair Notation

Macros for Paired Arguments
---------------------------

   To fascilitate the usage of paired arguments, KLIC provides the
following macros to be used in place of a goal.

S <= M
     Expanded to `S0 = [M|S1]' where S0 and S1 are expanded pair for
     the argument pair name S.

M => S
     Expanded to `[M|S0] = S1' where S0 and S1 are the expanded pair
     for the argument pair name S.

S += E

S -= E

S *= E

S /= E
     Expanded to `S1 := S0 + E0' etc, where S0 and S1 are the expanded
     pair for the argument pair name S.

S <== X
     Expanded to `S1 = X', where S0 and S1 are the expanded pair for
     the argument pair name S.  S0 does not appear in the expansion;
     the original value of the paired argument for S will be lost, and
     the next occurrence of S will mean X instead.  This feature is
     normally used with a non-paired occurrence of the argument pair
     name.  For example:

          ..., p-S, q(S), S <== X, r-S, ...

     means the following.

          ..., p(S0,S1), q(S1), S2 = X, r(S2,S3), ...


File: KLIC.info,  Node: Usage of Paired Arguments,  Prev: Macros for Paired Arguments,  Up: Argument Pair Notation

Usage of Paired Arguments
-------------------------

   Some examples of typical usage of paired arguments are given here.

   The following program is for summing up elements of a list of
integers.

     sum(List,Sum) :- sum(List)+0+Sum.
     
     sum([])-Acc.
     sum([H|T])-Acc :- Acc += H, sum(T)-Acc.

Here, the paired argument `Acc' plays the role of an accumulator.

   The following program inverts the sign of the elements of a list of
integers.

     inv(List,Inv) :- inv(List)+Inv-[].
     
     inv([])-Inv.
     inv([H|T])-Inv :- MH := -H, Inv <= MH, inv(T)-Inv.


File: KLIC.info,  Node: Inline C Code,  Prev: Argument Pair Notation,  Up: Language

Inserting C Language Code Inline
================================

   The inline C code feature allows specifying C programs to be
inserted in the object code within KL1 programs.  This feature is
somewhat similar to the `asm' statements of C.

   Appropriateness of inserted C code totally depends on internal
implementation schemes of the KLIC system, which may be altered in
future.  Thus, *general users are not recommended to use this feature.*

* Menu:

* Top Insertion::               Inserting C program text at the top
* Guard Insertion::             Inserting C program text in guards
* C-Level Rep::                 C-level representation of KL1 terms
* Examples of Inline::          Some examples of inline C code
* Hints of Inline::             Some hints on using inline C code


File: KLIC.info,  Node: Top Insertion,  Next: Guard Insertion,  Prev: Inline C Code,  Up: Inline C Code

Inline Insertion at the Top of Files
------------------------------------

   At the top of a source file, strings to be inserted in the object C
program can be specified in the following way.

     :- inline:"C PROGRAM TEXT TO BE INSERTED".

   The specified text is inserted in the object C program after standard
declarations and before any user-defined modules.

   There can be any number of such inline specification.  A typical
example is as follows.

     :- inline:"#include <stdio.h>"

   As inserted C programs are written as string constants of KLIC,
doubleqoute characters have to be escaped with a backslash character.  A
typical example is as follows.

     :- inline:"#include \"myheader.h\""

   It might also be a good idea to define macros and functions here,
that are invoked from the inline code in clause guards.


File: KLIC.info,  Node: Guard Insertion,  Next: C-Level Rep,  Prev: Top Insertion,  Up: Inline C Code

Inline Insertion in the Guard
-----------------------------

   Inline insertion specification can also appear as a guard goal with
one of the following forms.

     inline:"C PROGRAM TEXT"
     inline:"C PROGRAM TEXT":[ARGSPEC, ...]

   With either format, the C program text is literally inserted in the
object code corresponding to the guard part, except that percent signs
(`%') in the program text string specify special formatting.  The
following table lists special format characters after percent signs and
what they mean.

<digit>
     The name of the C variable corresponding to the <digit>-th ARGSPEC
     (zero origin).  Note that only up to 10 such arguments are allowed.

f
     The name of the C label to `goto' when this clause should fail or
     suspend.

%
     The percent character itself, i.e., percent characters should be
     doubled.  Be careful when you specify format strings for `printf'.

ARGSPEC  has one of the following formats.

VARIABLE+TYPE
     Specifies that the value of the variable is used within the
     inserted program text.  Object code for synchronization with
     availability of the variable value and checking of the value type
     is generated by the compiler.

VARIABLE-TYPE
     Specifies that variable is given a value within the inserted
     program text.  This has to be the first occurence of the variable.
     The compiler assumes that, after executing the inserted code, the
     variable will have value of TYPE.

The Type field should be one of the following.

any
     Anything, including uninstantiated variables

bound
     Any bound value

atomic
     An atomic value (a symbolic atom or an integer)

int
     An integer

atom
     An symbolic atom

list
     A list structure

functor
     A functor structure (including generic object)

object
     A generic data object

object(CLASS)
     A generic data object of CLASS

   Values are referenced without any indirections for all types except
for `any'.  For an input (`+') mode argument, the generated code makes
sure that, before executing the inserted program text, the argument
will have the value of the specified type directly, without indirect
references.  For an output (`-') mode argument, the compiler assumes
that, after executing the inserted program text, the variable will have
the value of the specified type directly, without any indirect
references, and uses that information for optimization.  If you cannot
be sure of this for output mode arguments, specify `any', which may be
less efficient but safe.


File: KLIC.info,  Node: C-Level Rep,  Next: Examples of Inline,  Prev: Guard Insertion,  Up: Inline C Code

C-Level Representation of KL1 Terms
-----------------------------------

   Note that C language types of the C variables and KL1 language types
of corresponding KL1 values are not the same.  All the C variables
corresponding to a KL1 value have the type `q' which means almost
nothing except that it occupies a single word.  KL1 values are somehow
encoded (with attached tag etc).  For example, an integer 3 of KL1 is
*not* represented by the bit pattern corresponding to integer 3 in of
the language C.

   This document is not intended to describe all the details of the data
representation scheme of KLIC.  Such description and programs depending
on it will be obsoleted anyway by future revisions of the KLIC system.
However, manipulation of integer values may be the easiest and useful in
most C programs written inline.  Thus, we'll describe macros for data
conversion for integers.  They are unlikely to be changed in future
versions.

   To obtain the integer value of a variable corresponding to an integer
value of KL1, use the macro `intval(X)'.  To obtain KL1 representation
of integer in C, use the macro `makeint(N)'.


File: KLIC.info,  Node: Examples of Inline,  Next: Hints of Inline,  Prev: C-Level Rep,  Up: Inline C Code

Examples
--------

*Example 1: Adding Two Integers*

   Two integers can be added by the following clause.

         p(X,Y,Z) :- W := X+Y | Z = W.

   The same function can be realized using the inline insertion feature
as follows.

     p(X,Y,Z) :-
       inline:"%2 = makeint(intval(%0)+intval(%1));":
         [X+int, Y+int, W-int] | Z=W.

   The inserted text will be as follows.

     x0 = makeint(intval(a0)+intval(a1));

   Where variables `a0' and `a1' correspond to `X' and `Y', and `x0' to
`W' in the KL1 program.  Note that the `Z' and `W' are unified in the
body.

*Example 2: Comparing Two Integers*

   Two integers can be compared by the following clause.

     p(X,Y) :- X > Y | ...

   The same function can be realized using the inline insertion feature
as follows.

     p(X,Y) :-
       inline:"if (intval(%0) <= intval(%1)) goto %f;":
         [X+int, Y+int] | ...

   The inserted text will be as follows.

     if (intval(a0) <= intval(a1)) goto p_2_interrupt;

   Where variables `a0' and `a1' correspond to `X' and `Y' in the KL1
program, and `p_2_interrupt' is a label automatically generated by the
compiler.


File: KLIC.info,  Node: Hints of Inline,  Prev: Examples of Inline,  Up: Inline C Code

Some Hints on Using the Inline C Code Feature
---------------------------------------------

   * Whenever possible, avoid using the inline feature.  Revisions of
     the KLIC system may obsolete your code.

   * If multiple lines are to be inserted consecutively, specify all of
     them in one single inline specification.  Otherwise, they might be
     interleaved by other code for the guard.  Newlines are allowed
     within the inserted program text.

   * Do not forget to prefix doublequotes and backslahes with a
     backslash.  Do not forget also to write two percent signs to
     insert one.  If you would like to say hello to the world, you
     should write such a program as follows.

          hello :-
              inline:"printf(\"Hello, world\\n\");" |
              ...

     Note the backslashes before doublequotes within the inlined code
     and doubled backslash before `n'.  If you put only one backslash
     before `n', it will become a newline code after inline expansion;
     it will appear within a string constant in the expanded C program.
     It fortunately works the same in this case, except that some C
     compilers may generate a warning message.

   * If your program with inline code does not work as you expect it
     to, the best way to find the problem may be to look into the C
     code generated.


File: KLIC.info,  Node: Builtin and Library,  Next: Using KLIC,  Prev: Language,  Up: Top

Builtin and Library Features
****************************

   This chapter describes builtin and library features of KLIC.

* Menu:

* Common Operations::           Operations common to all the data types
* Atomic Data::                 Atomic data and their operation
* Structured Data::             Structured data and their operation
* Executable Code::             Higher order manipulation of executable code
* Unix::                        Interfacing with the operating system
* Input and Output::            Input and output from and to files &c
* System Control::              Controlling system behavior
* Timer::                       Timing and interval timer
* Random Numbers::              Random number generator


File: KLIC.info,  Node: Common Operations,  Next: Atomic Data,  Prev: Builtin and Library,  Up: Builtin and Library

Common Operations
=================

   Some predicates are used commonly for all the data types or are
independent from any data types.

* Menu:

* Unification::                 Unifying two terms
* Synchronization::             Waiting for data availability
* Comparison and Hashing::      Comparing and hashing terms
* Execution Status::            Knowing about execution status
* Debugging::                   Debugging support


File: KLIC.info,  Node: Unification,  Next: Synchronization,  Prev: Common Operations,  Up: Common Operations

Unification
-----------

 - Guard Predicate on builtin: = ?X ?Y
     Checks whether X and Y are unifiable without giving values to
     variables outside the clause.

 - Body Predicate on builtin: = ?X ?Y
     Unifies X and Y.  If X has no value yet and Y already has some
     defined value, the value of Y is given to X.  If Y has no value
     and X has some, the reverse takes place.  If both do not have
     values yet, two variables are made to mean the same variable.  If
     both have values, they are matched.  If both are the data
     structures of the same kind, this unification operation is made
     recursively to corresponding elements of two structures.


File: KLIC.info,  Node: Synchronization,  Next: Comparison and Hashing,  Prev: Unification,  Up: Common Operations

Synchronization
---------------

 - Guard Predicate on builtin: wait +X
     Waits until instantiation of X.


File: KLIC.info,  Node: Comparison and Hashing,  Next: Execution Status,  Prev: Synchronization,  Up: Common Operations

Comparison and Hashing
----------------------

 - Guard Predicate on builtin: compare +X +Y -R
     Compares X and Y, and returns the result in R.  The result is an
     integer value less than, equal to, or greater than 0, when X is
     less than, equal to, or greater than Y, respectively.

     The comparison is made by the standard order.  This predicate can
     compare data of any types.  If both X and Y are of the same
     numeric type, normal numerical comparison is made.  Note that
     integer and floating point numbers are *not* of the same type;
     their comparison may not be meaningful.  Two strings are compared
     in (so-called) dictionary order.

     The order of any two data of different types is somehow defined by
     the system.  However, the ordering is guaranteed to be kept only
     within a single executable program.  If some data sequence is
     saved into a permanent file using the ordering provided by this
     predicate, the same program recompiled or linked with some other
     programs may or may not recognize the sequence as ordered.
     Different programs, of course, may use different ordering.

     Both X and Y have to be instantiated enough for making the
     comparison.  For example `f(V) @< f(W)' will suspend if not both
     `V' and `W' are instantiated.  On the other hand, `f(1,V) @<
     f(2,W)' will succeed immediately, as the order can be determined
     without looking into values of `V' or `W'.

     The absolute value of the result R may have some meaning for
     certain data types.  When comparing two strings, the absolute
     value of the result is one more than the index of the first
     differng element (a la `strcmp' of C).

     Some generic objects may not implement their comparison methods,
     and, in such cases, their comparison will result in a fatal error.

 - Guard Predicate on builtin: @< +X +Y
 - Guard Predicate on builtin: @=< +X +Y
 - Guard Predicate on builtin: @>= +X +Y
 - Guard Predicate on builtin: @> +X +Y
     Compares X and Y with the standard order.  If the condition is not
     satisfied, the invocation of the predicate fails.

 - Guard Predicate on builtin: \= +X +Y
     Compares X and Y and succeeds if and only if their principal
     functors are different.  For atomic values, it means that they are
     different; for functor structures, it means that either they have
     different functor names or different arity.  For generic objects,
     the predicate succeeds when two objects are of different classes.

     Note that `f(a) \= f(b)' fails, as the two terms have the same
     principal functor.  Note also that, floating point numbers are
     generic objects and thus `X \= Y' fails for any two floating point
     numbers, as they are objects of the same class.

 - Guard Predicate on builtin: hash +X -H
     Computes the hash value of X and returns it in H.  The hash value
     is a non-negative integer value.

     Hashing function may look into elements of structured data
     recursively.  X has to be instantiated enough to compute hash
     value.  Some generic objects may not implement hash methods, and,
     in such cases, their hash value becomes a constant.


File: KLIC.info,  Node: Execution Status,  Next: Debugging,  Prev: Comparison and Hashing,  Up: Common Operations

Execution Status
----------------

 - Guard Predicate on builtin: current_priority -P
     Returns the priority value of the reduced goal to P.  *Note
     Priority Specification: Priority, for further details on the
     priority mechanism.

 - Body Predicate on builtin: current_node -NODE -NUMNODES
     On a parallel implementation, the predicate returns the processor
     number executing the predicate in NODE and the total number of
     (pseudo-) processors available in NUMNODES.  Processor numbers
     have zero origin.  Thus, the maximum value returned to NODE is one
     less than the value returned to NUMNODES.  On a sequential
     implementation, 0 is returned to NODE and 1 to NUMNODES.


File: KLIC.info,  Node: Debugging,  Prev: Execution Status,  Up: Common Operations

Debugging
---------

 - Body Predicate on builtin: unbound ?X -RESULT
     Checks whether X is already bound to some concrete value or not
     and returns the RESULT.

     If the toplevel of X is already defined, RESULT is unified with a
     single-element vector of the form {X}.  When X is bound to a
     structured value, its elements may or may not be bound yet.

     If X is not bound yet, RESULT is unified with a three element
     vector of the form {ADDR1, ADDR2, X}, where ADDR1 and ADDR2 are
     integers indicating the current address of the variable X somehow.
     Note that variable addresses may change in time by garbage
     collection, automatic data migration in parallel implementations
     or any such low level implementational reasons; they are no more
     than debugging hints.

     *Do not use this predicate in normal application programs.* Unlike
     the `var/1' feature of sequential Prolog, variables once judged as
     unbound can be bound in the next instance on parallel
     implementations.  Thus, usage of this predicate should be
     restricted to programs that have to go into low level details of
     the system implementation, such as debugging tools.


File: KLIC.info,  Node: Atomic Data,  Next: Structured Data,  Prev: Common Operations,  Up: Builtin and Library

Atomic Data
===========

   KLIC provides two kinds of atomic data types, numerical and symbolic.

   For numerical data, KLIC provides integer and floating point number
data types and operations to manipulate them.  Floating point numbers
are implemented as generic objects and thus actually are not an atom.

   Note that implicit type conversions between integer and floating
point data are never made.  Integer numbers and floating point numbers
are treated completely separately.

   Whether given data is atomic or not can be tested by the following
guard predicates.

 - Guard Predicate on builtin: atomic +X
     Tests whether X is atomic or not.  Floating point numbers are
     *not* judged as atomic by this predicate.

* Menu:

* Symbolic Atoms::              Symbolic atoms give names to various concepts
* Integers::                    Integer data and their operations
* Floating Points::             Floating point data and their operations


File: KLIC.info,  Node: Symbolic Atoms,  Next: Integers,  Prev: Atomic Data,  Up: Atomic Data

Symbolic Atoms
--------------

   "Symbolic atoms" are atomic data objects that give names to notions.
Symbolic atoms with the same name are the same and with different names
are different.

* Menu:

* Notation of Atoms::           Notation of symbolic atoms
* Symbolic Atom Operation::     Operations on symbolic atoms


File: KLIC.info,  Node: Notation of Atoms,  Next: Symbolic Atom Operation,  Prev: Symbolic Atoms,  Up: Symbolic Atoms

Notation of Symbolic Atoms
..........................

   The notation of symbolic atoms is similar to Edinburgh Prolog, which
is one of the following.

   * A lower case letter followed by a sequence of any number (including
     zero) of letters, digits or underlines.

     Examples:
          icot   kl1   a_symbolic_atom_with_a_long_name

   * A sequence of special characters (some of `~', `+', `-', `*', `/',
     `\', `^', `<', `>', `=', ``' (backquote), `:', `.', `?', `@', `#',
     `$', `&').

     Examples:
          +   >=   :-   =:=

   * A sequence of any characters quoted by single quotes.  If single
     quote characters are to be included, they should be doubled or
     escaped by a backslash.

     Examples:
          'Hello world'    'an atom with \'singlequotes\' in it'

   * Special one-character atoms.  There are three of them, which are
     `!', `|' and `;'.  Also, `|' has a special meaning in list
     notation (*Note Notation of Lists::).

   * A special atom `[]', which usually is used to represent ends of
     lists (*note Lists::.).  Spaces can be in between `[' and `]'.

   Important differences with Edinburgh Prolog syntax are the following.

   * A vertical bar (`|') means a one-character atom.  Even when it is
     used as an operator, it is *not* treated the same as a semicolon
     (`;') but as a different atom.

   * A pair of curly braces (`{}') does not stand for a symbolic atom.
     It means a vector with no elements (*note Notation of Vectors::.).


File: KLIC.info,  Node: Symbolic Atom Operation,  Prev: Notation of Atoms,  Up: Symbolic Atoms

Operations on Symbolic Atoms
............................

   Whether a given data object is a symbolic atom or not can be tested
by the following guard predicate.

 - Guard Predicate on builtin: atom +X
     Tests whether X is a symbolic atom or not.

   To maintain the uniqueness of atoms, the system gives a unique number
to each atom and maintains the association between atom name strings and
atom numbers.  Association of symbolic atoms and their names can be
known by the following predicates defined in the module `atom_table'.

 - Predicate on atom_table: make_atom +STRING -ATOM
     When given a STRING, returns ATOM with that name.  If such an atom
     does not exist, a new atom is registered.

 - Predicate on atom_table: atom_number +ATOM -NUMBER
     Internal serial number for ATOM is returned to NUMBER as an
     integer value.

 - Predicate on atom_table: get_atom_string +ATOM -STRING
     The name string of ATOM is returned to STRING.

 - Predicate on atom_table: intern +STRING -RESULT
     The same as atom_table:make_atom, except that the returned value
     is a functor structure of the form `normal(ATOM)'.

 - Predicate on atom_table: get_atom_name +ATOM -RESULT
     The same as atom_table:get_atom_string, except that the returned
     value is a functor structure of the form `normal(STRING)'.

   Although symbolic atoms are associated with their name strings, do
*not* use them for string manipulation.  String data objects provide
much more functionality and better performance (*note Strings::.).


File: KLIC.info,  Node: Integers,  Next: Floating Points,  Prev: Symbolic Atoms,  Up: Atomic Data

Integer Atoms
-------------

   KLIC provides integer data with usually 28 or 60 bits as its basic
standard feature.  The width depends on the C compiler you use.  It is 4
bits shorter than the width of type `long int'.

 - Guard Predicate on builtin: integer +X
     Tests whether X is an integer atom.

* Menu:

* Notation of Integers::        Notation of integers
* Integer Arith::               Integer arithmetics
* Integer Comp::                Integer comparison


File: KLIC.info,  Node: Notation of Integers,  Next: Integer Arith,  Prev: Integers,  Up: Integers

Notation of Integers
....................

   KLIC provides several ways to denote integer constants.
   * Usual decimal notation: optional minus sign followed by a sequence
     of decimal digits.  Examples: `123', `-35'.

   * Based notation: optional minus sign followed by a sequence of
     decimal digits specifying the base (1 to 36), an apostrophe, and
     then a sequence of digits of the base, that are digits and
     alphabets (case insensitive).  Examples: `2'1010', `16'0D0a'.
     Value of an integer with base 1 is the number of ones in the digit
     sequence; for example `1'10110' means 3.

   * Character code notation: optional minus sign followed by a digit
     0, an apostrophe and a character.  Examples: `0'a' means the
     character code of lowercase letter `a'.  The above listed constant
notations can be used in both KL1 programs and KL1 data read in by
Prolog-like I/O interface (*note Input and Output with Prolog-like
Interface: Prolog I/O.).

   The following are also allowed in KL1 programs for compatility with
PIMOS system on PIM machines.
   * Based notation: optional minus sign followed by a sequence of
     decimal digits specifying the base (1 to 36), a sharp sign, and
     then a charcter string of digits of the base, that are digits and
     alphabets (case insensitive), surrounded by doublequotes.
     Examples: `2#"1010"', `16#"0D0a"'.

   * Character code notation: optional minus sign followed by a sharp
     sign and a character enclosed within doubleqoutes.  Examples:
     `#"a"' means the character code of lowercase letter `a'.


File: KLIC.info,  Node: Integer Arith,  Next: Integer Comp,  Prev: Notation of Integers,  Up: Integers

Integer Arithmetics
...................

 - Guard Predicate on builtin: := -VAR +EXPR
 - Body Predicate on builtin: := -VAR +EXPR
     Computes the value of the integer expression EXPR, and unifies it
     with VAR.  The following operators are available in the expression.

    X + Y
          Addition.

    + X
          No operation.  X is the result.

    X - Y
          Subtraction.

    - X
          Sign inversion.

    X * Y
          Multiplication.

    X / Y
          Integer division.

    X mod Y
          Modulo.

    \(X)
          Bit-wise complement.

    X /\ Y
          Bit-wise logical AND.

    X \/ Y
          Bit-wise logical OR.

    X xor Y
          Bit-wise exclusive OR.

    X << Y
          Left shift.

    X >> Y
          Logical right shift.

    int(X)
          Conversion from floating point to integer.  X is a floating
          point expression (*note Floating Point Arithmetics: Floating
          Arith.) and its result is rounded to an integer value.

     Arithmetical overflows are ignored, that is, all the arithmetics
     are done modulo 2**28 or 2**60 depending on the C compiler used.
     C compilers with 32-bit `long int' give 28-bit KLIC integers and
     those with 64-bit `long int' give 60-bit KLIC integers.

     This predicate is available in both guards and bodies of clauses.

     If any of the operands in the expression are uninstantiated, the
     computation will be suspended until they all get instantiated.

     Any operands in the expression can be an expression recursively.
     However, operands written as a variable in the program should *not*
     be instantiated to a compound term such as `3 + 5'.  They should be
     instantiated only to an integer.  Otherwise, a type mismatch error
     will be generated.


File: KLIC.info,  Node: Integer Comp,  Prev: Integer Arith,  Up: Integers

Integer Comparison
..................

   Comparison of integer data can be made using the predicates described
here.  More general comparison predicate is also provided (*note
Comparison and Hashing::.), but predicates and methods described here
are more efficient when the operands are known to be integers.

 - Guard Predicate on builtin: > +X +Y
 - Guard Predicate on builtin: >= +X +Y
 - Guard Predicate on builtin: =:= +X +Y
 - Guard Predicate on builtin: =\= +X +Y
 - Guard Predicate on builtin: =< +X +Y
 - Guard Predicate on builtin: < +X +Y
     Perform arithmetical comparison of two integer arguments.  Use
     `=:=' and `=\=' for equality and non-equality checks.  Each side
     of the comparison can be an arithmetical expression.  The same set
     of operators as in `:=' can be used.


File: KLIC.info,  Node: Floating Points,  Prev: Integers,  Up: Atomic Data

Floating Point Numbers
----------------------

   Floating point numbers with precision of 64 bits are provided as
generic objects.  The following method and predicate tell whether given
data is a floating point number or not.

 - Guard Method on float: float +X
 - Guard Predicate on builtin: float +X
     Tests whether X is a floating point number.

* Menu:

* Notation of Floats::          Notation of floating point numbers
* Creating Floats::
* Floating Arith::              Floating point arithmetics
* Floating Comp::               Floating comparison


File: KLIC.info,  Node: Notation of Floats,  Next: Creating Floats,  Prev: Floating Points,  Up: Floating Points

Notation of Floating Point Numbers
..................................

   Floating point numbers have the following constant notation syntax.

     SIGN INTEGRAL `.' FRACTION `e' SIGN EXPONENT

where INTEGRAL, FRACTION and EXPONENT are sequence of decimal digits.
SIGN is either `+', `-' or empty (meaning `+').  The exponent part,
that is, character `e', SIGN and EXPONENT, may be omitted altogether.

   The following are examples of floating point number constants.

     3.14159  -6.02e23  1234.5678e-25


File: KLIC.info,  Node: Creating Floats,  Next: Floating Arith,  Prev: Notation of Floats,  Up: Floating Points

Creating New Floating Point Numbers
...................................

   New floating point numbers can be created by the following.
Predicates for floating point arithmetics described in *Note Floating
Arith:: also create floating point numbers as the result of
arithmetical operations.

 - Object Creation on float: new -FLOAT +INIT
     A new floating point number is created and unified with FLOAT.
     The argument INIT should be an integer specifying the value of the
     floating point number.  For example, `generic:new(float, F, 3)'
     unifies `F' with `3.0'.


File: KLIC.info,  Node: Floating Arith,  Next: Floating Comp,  Prev: Creating Floats,  Up: Floating Points

Floating Point Arithmetics
..........................

 - Body Predicate on builtin: $:= -VAR +EXPR
     Computes the value of the floating point expression EXPR, and
     unifies it with VAR.  The following operators are available in the
     expression.

    X + Y
          Addition.

    X - Y
          Subtraction.

    X * Y
          Multiplication.

    X / Y
          Division.

    pow(X, Y)
          Y to the power of X.

    sin(X), cos(X), tan(X)
          Trigonometric functions on X.

    asin(X), acos(X), atan(X)
          Inverse trigonometric functions on X.

    sinh(X), cosh(X), tanh(X)
          Hyperbolic functions on X.

    exp(X)
          Exponential function.

    log(X)
          Natural logarithm.

    sqrt(X)
          Square root.

    ceil(X)
          Ceiling function (rounding toward positive infinity).

    floor(X)
          Flooring function (rounding toward negative infinity).

    float(X)
          Conversion from an integer to a floating point number.  X is
          an integer expression (*note Integer Arithmetics: Integer
          Arith.) and its result is converted to a floating point
          number.

     This predicate is available in both guards and bodies of clauses.

     If any of the operands in the expression are uninstantiated, the
     computation will suspend until they all get instantiated.

     Any operands in the expression can be an expression recursively.
     However, operands written as a variable in the program should *not*
     be instantiated to a compound term such as `3.0 + 5.0'.  They
     should be instantiated only to a floating point number.
     Otherwise, a type mismatch error will be generated.

   Operations listed above are also provided as generic methods on
floating point number.

 - Body Method on float: add +X +Y -R
 - Body Method on float: subtract +X +Y -R
 - Body Method on float: multiply +X +Y -R
 - Body Method on float: divide +X +Y -R
 - Body Method on float: pow +X +Y -R
 - Body Method on float: sin +X -R
 - Body Method on float: cos +X -R
 - Body Method on float: tan +X -R
 - Body Method on float: asin +X -R
 - Body Method on float: acos +X -R
 - Body Method on float: atan +X -R
 - Body Method on float: sinh +X -R
 - Body Method on float: cosn +X -R
 - Body Method on float: tanh +X -R
 - Body Method on float: exp +X -R
 - Body Method on float: log +X -R
 - Body Method on float: sqrt +X -R
 - Body Method on float: ceil +X -R
 - Body Method on float: floor +X -R
     These methods perform arithmetic operations, specified by the
     method name, on given operand(s), and return the result in R.


File: KLIC.info,  Node: Floating Comp,  Prev: Floating Arith,  Up: Floating Points

Floating Point Comparison
.........................

   Comparison of floating point data can be made by the predicates
described here.  More general comparison predicate is also provided
(*note Comparison and Hashing::.), but predicates and methods described
here are more efficient when the operands are known to be floating point
numbers.

 - Guard Predicate on builtin: $> +X +Y
 - Guard Predicate on builtin: $>= +X +Y
 - Guard Predicate on builtin: $=:= +X +Y
 - Guard Predicate on builtin: $=\= +X +Y
 - Guard Predicate on builtin: $=< +X +Y
 - Guard Predicate on builtin: $< +X +Y
     These predicates perform arithmetical comparison of two floating
     point arguments.  Use `=:=' and `=\=' for equality and non-equality
     checks (although they may not be much meaningful for floating point
     numbers).  Each side of the comparison can be a floating point
     arithmetical expression.  The same set of operators as in `$:=' can
     be used.

     *Bug Caution* The current version (1.510) has problems with
     expressions with operators in these predicates.  Only simple
     variables and constants can be used.

   Comparison of floating point numbers can also be made by the methods
described below.

 - Guard Method on float: less_than +X +Y
 - Guard Method on float: not_greater_than +X +Y
 - Guard Method on float: not_less_than +X +Y
 - Guard Method on float: greater_than +X +Y
 - Guard Method on float: equal +X +Y
 - Guard Method on float: not_equal +X +Y
     These methods test whether X is less than Y or not, etc.


File: KLIC.info,  Node: Structured Data,  Next: Executable Code,  Prev: Atomic Data,  Up: Builtin and Library

Structured Data
===============

   Structured data objects consist of zero or more elements.

* Menu:

* Functors::                    Named data structures
* Lists::                       Linear list of elements
* Vectors::                     One-dimensional arrays of any data
* Strings::                     Array of small integers such as character codes


File: KLIC.info,  Node: Functors,  Next: Lists,  Prev: Structured Data,  Up: Structured Data

Functor Structures
------------------

   Functor structures are structures with given name and one or more
elements, which can be of any type.  Functors are conveniently used for
representing data structures whose sizes are known beforehand.  Functors
correspond to record structures of C-like languages.

* Menu:

* Notation of Functors::        Notation of functors
* Functor Operation::           Operation on fucntor structures


File: KLIC.info,  Node: Notation of Functors,  Next: Functor Operation,  Prev: Functors,  Up: Functors

Notation of Functors
....................

   Functor constants can be written by the name of the principal
functor, a left parenthesis, elements separated by commas, and finally
a right parenthesis.  Functor names have the same syntax as symbolic
atoms.  The principal functor name and the following left parenthesis
should *not* be separated by space characters or any other punctuation
symbols.  Elements can be of any type, including variables or functors
themselves.

   Examples:
     f(a, 3)   'a recursive functor structure'(X, 'child functor'(Y))


File: KLIC.info,  Node: Functor Operation,  Prev: Notation of Functors,  Up: Functors

Operations on Functors
......................

   Predicates for manipulation of functor structures are provided as
builtin predicates and in the module `functor_table', as listed in this
section.

   In the current implementation, all the body builtin predicates listed
here are actually implemented as macros expanded to predicates of the
module `functor_table'.  This implementation scheme may be changed in
future releases.

 - Guard Predicate on builtin: functor +X -FUNCTOR -ARITY
 - Body Predicate on builtin: functor +X -FUNCTOR -ARITY
     X is a functor with the principal functor whose name being FUNCTOR
     and arity ARITY.  These predicates can be used for obtaining the
     the name and/or the arity of principal functors.  The guard
     predicate version can also be used for testing that X has the name
     FUNCTOR and/or the arity ARITY.  Any instantiated data that are
     not functor structures, i.e., atomic data, strings, vectors and so
     on, have zero as their arities and themselves as their principal
     functor names.  Note that list structures consist of functors
     `./2'.

     This predicate cannot be used to create a new functor.

 - Guard Predicate on builtin: arg +POS +TERM -ARG
 - Body Predicate on builtin: arg +POS +TERM -ARG
     The POS-th argument of TERM is ARG.  Arguments are numbered from
     1.  The guard version simply fails if POS is out of range.  As all
     the data structures except for functor structures have no
     arguments, this predicate always fails for them.

 - Body Predicate on builtin: new_functor -FUNCTOR +ATOM +ARITY
     A functor structure with its principal functor with name ATOM and
     arity ARITY is returned to FUNCTOR.  Arguments of the created
     functor are initiated with integer `0'.

 - Body Predicate on builtin: setarg +POS +FNCT ?NEWE -NEWFNCT
 - Body Predicate on builtin: setarg +POS +FNCT ?OLDE ?NEWE -NEWFNCT
     A new functor structure that is different from FNCT with only one
     argument at POS is created and returned to NEWFNCT.  The element
     with index POS of NEWFNCT will be NEWE.  For five argument
     versions, the original argument at POS will be returned to OLDE.

 - Predicate on functor_table: =.. -NEWFNCT +LIST
     A new functor structure is created and returned to NEWFNCT.  The
     name of the principal functor is specified by the first element of
     LIST, which should be a symbolic atom, and the arguments are
     specified by the rest of LIST.  If LIST has only one element, that
     element is returned to NEWFNCT.

     This predicate can *not* be used for decomposing a functor
     structure to a list.


File: KLIC.info,  Node: Lists,  Next: Vectors,  Prev: Functors,  Up: Structured Data

Lists
-----

   Lists are arbitrarily long sequences of any data objects.  In KL1,
List structures are made up of functor structures `./2', that is,
functor structures with their name `.' and arity two.  List structures
are composed of possibly many of these functor structures (sometimes
called "cons cells").

   The first element of the cons cell, sometimes called the "car" of
the cell, represents the first element of the list.  The second element,
the "cdr" of the cell, represents the rest of the list.  Termination of
the list is indicated by a symbolic atom `[]' being the cdr.

   Whether a given argument is a list or not can be tested by the
following guard predicate.

 - Guard Predicate on builtin: list +X
     Tests whether X is a cons cell.  Note that, despite its name, this
     predicate fails for a null list `[]' for a historical reason.

   Incrementally instantiated list structures are conveniently used as
message streams.

* Menu:

* Notation of Lists::           Notation of Lists
* Merging::                     Merging messages from multiple streams


File: KLIC.info,  Node: Notation of Lists,  Next: Merging,  Prev: Lists,  Up: Lists

Notation of Lists
.................

   As in Lisp, lists of KL1 are constructed using *cons* data
structures, which is actually a functor structure `./2'.

   The basic notation for lists is `[CAR | CDR]', which consists of the
first element CAR and the tail of the list CDR.  This means exactly the
same as `.(CAR, CDR)'.  An empty list is represented by an atom `[]'.

   If CDR happens to be empty, that is, when the list consists only of
one element CAR, such a list can be written as `.(CAR, [])' or `[CAR |
[]]', or, alternatively, as `[CAR]'.  That is, the sequence `| []' at
the tail of a list can be ommitted.

   Lists with its car being CAR and its cdr being a list `[CADR, ...]'
is `[CAR | [CADR, ...]]', which can be abbreviated as `[CAR, CADR,
...]'.  For example, a list consisting of four elements, `first',
`second', `third' and `fourth' can be written as `[first, second,
third, fourth]'.

   A list consisting of four or more elements, but with the first four
elements being `first', `second', `third' and `fourth', can be written
as `[first, second, third, fourth | Rest]'.  Here, the variable `Rest'
corresponds to the list beginning with the fifth element, or an empty
list if the whole list had only four elements.

   Note that, unlike in Ediburgh Prolog, the character sequence `,..'
can *not* be used in place of `|'.


File: KLIC.info,  Node: Merging,  Prev: Notation of Lists,  Up: Lists

Manipulation of Message Streams
...............................

   A stream merger is a process that takes multiple message streams
represented as lists of messages as input, and passes all the messages
from all the input streams to a single output stream also represented as
a list.

   The output consists of all the messages in the inputs with duplicates
preserved.  When two messages are ordered in one of the input streams,
their order is also preserved in the output.  When messages are from
different input streams, their order in the output is unpredictable.
The order may differ in one execution of the same program from another.
The behavior of mergers is thus nondeterministic.

   For example, when there are two input streams `[1, 2, 3]' and `[a,
b, c]', the output can be something like `[1, 2, a, b, 3, c]' or `[1,
a, 2, b, c, 3]', but will never be `[1, a, 3, b, c, 2]'.

   A binary (two-input) stream merger can be defined in KL1 as follows.

     merge([M|In1], In2, Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge(In1, [M|In2], Out) :- Out=[M|OutT],  merge(In1, In2, OutT).
     merge([], In2, Out) :- Out=In2.
     merge(In1, [], Out) :- Out=In1.

   * The first clause forwards one message coming from the first input
     stream to the output stream.  The first input stream is the first
     argument and the output stream is the third argument of the
     predicate.  It then calls the predicate `merge/3' recursively for
     repetitive execution.

   * The second clause does the same for the second input stream.

   * The third clause is used when the first input stream has no more
     messages in it.  In this case, the second input stream is directly
     connected to the output.  As there are no more messages to merge
     from the first input stream, the result of the merging should be
     the same as the second input stream.

   * The fourth clause provides the corresponding feature when the
     second input stream has no more messages in it.

   When messages come from both the first and the second at the same
time, either the first or the second clause is arbitrarily chosen.
This is the source of the nondeterminacy of the merger.

   Although binary mergers are easy to define in KL1, defining a merger
with arbitrarily many input streams is not so easy.  It is also
desirable to add new input streams dynamically, which makes it still
harder.  Also, mergers are used quite frequently in KL1 programs and
thus should be quite efficient.  Thus, the KLIC system provides a merger
as one of its standard feature.

   A new merger can be created by the following pseudo-predicate.

 - Object Creation on merge: new ?INPUT ?OUTPUT
     A new merger with single input stream is created.  Its input
     stream is INPUT and its output is OUTPUT.

   The merger process created by the above pseudo-predicate does not
actually start any merging immediately after its creation.  It only
forwards the messages from INPUT to OUTPUT, without changing the order.

   To add a new input stream to a merger, unify the input with a vector
whose elements are input streams.  For example, if you need a binary
merger, do the following.

     generic:new(merge, INPUT, OUTPUT),
     INPUT = {IN1, IN2}

   This means the same as the following.

     generic:new(merge, {IN1, IN2}, OUTPUT)

   After doing the above, the merger will merge messages from two input
streams, IN1 and IN2, to the output stream OUTPUT.

   Input streams to a merger can be added not only immediately after its
creation but at any time on demand.  Two more input streams are added,
for example, by the following.

     IN2 = {IN2A, IN2B, IN2C}

   After this, the merger will have four input streams, IN1, IN2A, IN2B
and IN2C.

   When one of the input streams is no longer needed, that input stream
can be simply closed, by unifying it with an atom `[]'.

   The size of the vector unified with an input stream can be
arbitrarily large or small.  When it has only one element, the number
of input streams will not be changed.  When the vector has no elements,
unifying with it has the same effect as closing the stream.

   The output stream will be closed, i.e., the tail of the output list
is unified with `[]', when all the input streams have been closed.

   Here are some clues in using the merger.

   * Messages merged can be a data structure containing unbound
     variables.  Such messages are sometimes called "incomplete
     messages".  Incomplete messages are convenient for constructing a
     server-client process structure.  Giving values to variables in
     messages can be used for communicating backwards from the server
     to the client.

   * Merging may look deterministic on sequential implementations.  Do
     never rely on it.  It will become really nondeterministic on
     parallel implementations.


File: KLIC.info,  Node: Vectors,  Next: Strings,  Prev: Lists,  Up: Structured Data

Vectors
-------

   Vectors are fixed-length one-dimensional array of KL1 data.  The
length of a vector is determined on its creation.  Elements can be any
KL1 data and can even be left undefined when the data structure is
created.

   Elements are indexed by an integer beginning from 0.  For example, a
vector with 3 elements has elements numbered 0, 1 and 2.

* Menu:

* Notation of Vectors::         Constant notation of vectors
* Creating Vectors::            Creating new vectors
* Predicates on Vectors::       Vector manipulation predicates


File: KLIC.info,  Node: Notation of Vectors,  Next: Creating Vectors,  Prev: Vectors,  Up: Vectors

Notation of Vectors
...................

   Vectors can be denoted by a comma-separated list of elements in a
pair of curly braces.

     { 1, a, f(b), X }

A null vector (vectors with no elements at all) is denoted only by a
pair of curly braces.

     {}

   Note that curly braces are used in a way completely different from
Edinburgh Prolog, where `{}' means an atom and `{...}' means a functor
structure `{}((...))'.


File: KLIC.info,  Node: Creating Vectors,  Next: Predicates on Vectors,  Prev: Notation of Vectors,  Up: Vectors

Creating New Vectors
....................

   In addition to the notation described above, vectors can be
dynamically created during program execution.  The following predicate
can be used to create a new vector.

 - Object Creation on vector: new -VECTOR +INIT
 - Body Predicate on builtin: new_vector -VECTOR +INIT
     A new vector is created and returned to VECTOR.

     If the argument INIT is an integer, it sepcifies the number of
     elements.  The elements are initialized with integer `0' in this
     case.  For example, `generic:new(vector, V, 2)' creates a vector
     `{0, 0}' and returned it to `V'.

     If INIT is a list, the newly created vector is initiated by the
     elements of the list.  Naturally, the number of elements of the
     vector becomes the same as the length of the list.  For example,
     `generic:new(vector, V, [a, b, c])' creates a vector `{a, b, c}'
     and unifies it with `V'.


File: KLIC.info,  Node: Predicates on Vectors,  Prev: Creating Vectors,  Up: Vectors

Predicates on Vectors
.....................

 - Guard Method on vector: vector +VECTOR -LENGTH
 - Body Method on vector: size +VECTOR -LENGTH
 - Guard Predicate on builtin: vector +VECTOR -LENGTH
     Tests whether VECTOR is a vector object (if called in guard) and
     returns the number of elements in LENGTH.

 - Guard Method on vector: element +VECTOR +INDEX -ELEMENT
 - Body Method on vector: element +VECTOR +INDEX -ELEMENT
 - Guard Predicate on builtin: vector_element +VECTOR +INDEX -ELEMENT
 - Body Predicate on builtin: vector_element +VECTOR +INDEX -ELEMENT
     An element with index INDEX of the vector VECTOR is unified with
     ELEMENT.  The index is zero origin.

 - Body Method on vector: set_element +ORIGINAL +INDEX ?NEWELEMENT -NEW
 - Body Predicate on builtin: set_vector_element +ORIGINAL +INDEX
          ?NEWELEMENT -NEW
     A new vector is unified with NEW.  The new vector has the same
     elements as the ORIGINAL, except that the INDEX'th element is
     updated to NEWELEMENT.  The original vector is left untouched.
     The index is zero origin.

 - Body Method on vector: set_element +ORIGINAL +INDEX ?ELEMENT
          ?NEWELEMENT -NEW
 - Body Predicate on builtin: set_vector_element +ORIGINAL +INDEX
          ?ELEMENT ?NEWELEMENT -NEW
     A new vector is unified with NEW.  The new vector has the same
     elements as the ORIGINAL, except that the INDEX'th element is
     updated to NEWELEMENT.  The original vector is left untouched.
     The index is zero origin.  The original INDEX'th element is
     returned to ELEMENT.

 - Body Method on vector: split +ORIGINAL +AT -LOWER -UPPER
     The vector ORIGINAL is split at the index position AT and the
     resultant two vectors are unified with LOWER and UPPER.  AT has to
     be a non-negative integer less than or equal to the size of the
     original vector.  LOWER will have elements with indices between 0
     and `AT-1', inclusive.  Elements with indices between AT and up
     will be included in UPPER.

 - Body Method on vector: join +LOWER +UPPER -JOINED
     Two vectors LOWER and UPPER are concatenated together to make a
     new vector JOINED.

   In KLIC, creating a new vector differing with an existing one by
only a single element is implemented with constant time and space
overhead, regardless of the size of the vector, by using multiversion
array representation.


File: KLIC.info,  Node: Strings,  Prev: Vectors,  Up: Structured Data

Strings
-------

   Strings are one dimensional arrays of integers in restricted range.
The current version provides only strings of 8-bit elements which has
elements of the range 0 through 255.  They are convenient for
representing character strings.  Strings with elements of different
sizes are planned in future.

   Unlike in Edinburgh Prolog, strings are *not* notational convention
for lists of character codes.  They are of its own data type.

* Menu:

* Notation of Strings::         Constant notation of strings
* Creating Strings::            Creating new strings
* Predicates on Strings::       String manipulation predicates


File: KLIC.info,  Node: Notation of Strings,  Next: Creating Strings,  Prev: Strings,  Up: Strings

Notation of Strings
...................

   In KLIC, character string constants should be denoted by sequence of
characters surrounded by a pair of doublequotes, as follows.

     "A string of the characters written here"

   The following escape sequences (a la ANSI C) are used to specify
doublequotes, backslashes and control codes as string elements.

`\a'
     Bell.

`\b'
     Backspace.

`\t'
     Tab.

`\n'
     Newline.

`\v'
     Vertical tab.

`\f'
     Formfeed.

`\r'
     Carriage return.

`\''
     Singlequote.

`\"'
     Doublequote.

`\?'
     Question mark.

`\\'
     Backslash.  Two consecutive backslach characters specifies a single
     backslash in the string.

`\ooo'
     Code specified by the octal number ooo.  Up to three octal digits
     are recognized.

`\xhh'
     Code specified by the hexadecimal number hh.  Arbitrarily many
     hexadecimal digits may be used.

`\<newline>'
     The backslash character along with the newline code immediately
     following it are ignored.  This sequence results in no characters
     at all in the string.

Example:

     "The character \'\"\' (doublequote)"

The above example is understood as a string containing the following
characters.

     The character '"' (doublequote)

   Strings should not contain newlines nor doublequotes directly.  A
standard way for including newlines within a string is to end the line
with `\n\'.  By this, a new line code is inserted by the sequence `\n'
and the actual newline in the source code following the second `\' is
ignored.

   Unlike in Edinburgh Prolog, character strings are *not* lists of
character codes.


File: KLIC.info,  Node: Creating Strings,  Next: Predicates on Strings,  Prev: Notation of Strings,  Up: Strings

Creating New Strings
....................

   In addition to the constant strings described above, strings can be
dynamically created during execution.  The following predicate can be
used to create a new string.

 - Object Creation on string: new -STRING +INIT +ELEMSIZE
 - Body Predicate on builtin: new_string -STRING +INIT +ELEMSIZE
     A new string is created and unified with STRING.  The last
     argument ELEMSIZE specifies the bit width of the elements.  As
     only 8-bit strings are available in the current version, this
     should be 8.

     When the argument INIT is an integer, it sepcifies the number of
     elements.  In this case, the elements are initialized with integer
     `0' (null code).  For example, `generic:new(string, S, 3, 8)'
     creates `"\0\0\0"'.

     If INIT is a list of integers, the newly created string is
     initiated by the elements of the list.  Naturally, the number of
     elements of the string becomes the same as the length of the list.
     In this case, list elements should have values that fits in the
     given bit width; between 0 and 255 in case of 8-bit strings.  For
     example, `generic:new(string, S, [0'a, 0'b, 0'c], 8)' creates
     `"abc"'.


File: KLIC.info,  Node: Predicates on Strings,  Prev: Creating Strings,  Up: Strings

Predicates on Strings
.....................

 - Guard Method on string: string +STRING -LENGTH -ELEMSIZE
 - Body Method on string: string +STRING -LENGTH -ELEMSIZE
 - Guard Predicate on builtin: string +STRING -LENGTH -ELEMSIZE
     Tests whether STRING is a string object (if called in guard).  The
     number of elements of STRING is returned in LENGTH and the element
     size (which is always 8 in the current version) is returned in
     ELEMSIZE.

 - Body Method on string: size +STRING -LENGTH
     Returns the number of elements of STRING in LENGTH.

 - Body Method on string: element_size +STRING -ELEMSIZE
     Returns the the element size of STRING in ELEMSIZE.

 - Guard Method on string: element +STRING +INDEX -ELEMENT
 - Body Method on string: element +STRING +INDEX -ELEMENT
 - Guard Predicate on builtin: string_element +STRING +INDEX -ELEMENT
 - Body Predicate on builtin: string_element +STRING +INDEX -ELEMENT
     An element with index INDEX of the string STRING is unified with
     ELEMENT.  The index is zero origin.

 - Guard Method on string: less_than +STRING1 +STRING2
 - Guard Predicate on builtin: string_less_than +STRING1 +STRING2
     Succeeds only when STRING1 is less than STRING2 in lexicographical
     order.

 - Guard Method on string: not_less_than +STRING1 +STRING2
 - Guard Predicate on builtin: string_not_less_than +STRING1 +STRING2
     Succeeds only when STRING1 is not less than STRING2 in
     lexicographical order.

 - Body Method on string: set_element +ORIGINAL +INDEX +ELEMENT -NEW
 - Body Predicate on builtin: set_string_element +ORIGINAL +INDEX
          +ELEMENT -NEW
     A new string is unified with NEW.  The new string has the same
     elements as the ORIGINAL, except that the INDEX'th element is
     updated to ELEMENT.  The original string is left untouched.  The
     index is zero origin.

 - Body Method on string: split +ORIGINAL +AT -LOWER -UPPER
     The string ORIGINAL is split at the index position AT and the
     resultant two strings are unified with LOWER and UPPER.  AT has to
     be a non-negative integer less than or equal to the size of the
     original string.  LOWER will have elements with indices between 0
     and `AT-1', inclusive.  Elements with indices between AT and up
     will be included in UPPER.

 - Body Method on string: join +LOWER +UPPER -JOINED
     Two strings LOWER and UPPER are concatenated together to make a
     new string JOINED.

 - Body Method on string: search_character +STRING +START +END +CHAR
          -WHERE
 - Body Predicate on builtin: search_character +STRING +START +END
          +CHAR -WHERE
     The character CHAR is searched for in STRING, beginning from the
     position START and ending before END.  If such a character is
     found, its index is unified with WHERE.  If not, Where is unified
     with `-1'.  The indices are zero origin.

   In KLIC, creating a new string differing with only one element from
the original is implemented with constant time and space overhead,
regardless of the size of the string, by using multiversion array
representation.


File: KLIC.info,  Node: Executable Code,  Next: Unix,  Prev: Structured Data,  Up: Builtin and Library

Handling Program Code as Data
=============================

   KLIC allows higher order manipulation of executable code as data
objects.  Program modules are treated as "module" data objects and
individual predicates are treated as "predicate" data objects.

* Menu:

* Module Type::                 Program modules as data
* Predicate Type::              Predicates as data


File: KLIC.info,  Node: Module Type,  Next: Predicate Type,  Prev: Executable Code,  Up: Executable Code

Modules
-------

   Program modules are treated as data through generic data objects of
type `module'.

 - Object Creation on module: new -MODULE +MODULENAME
     Creates a new object MODULE corresponding to the program module
     specified by MODULENAME as a symbolic atom.  If the specified
     module is not defined, the symbolic atom itself is returned to
     MODULE.  *Note Creating Objects::, for the format of object
     creation goals.

 - Guard Method on module: module +MODULE
     Tests whether MODULE is a module object or not.

 - Body Method on module: name +MODULE -MODULENAME
     The module name of MODULE is returned to MODULENAME as a symbolic
     atom.


File: KLIC.info,  Node: Predicate Type,  Prev: Module Type,  Up: Executable Code

Predicates
----------

   Predicates in programs are treated as data through generic data
objects of type `predicate'.

   Predicate type data can be either denoted as a constant or created
dynamically in runtime.  Due to limitations of the features of host
systems, dynamic creation may not be supported on some host systems.

   The syntax of a predicate constant is as follows.

     `predicate'`#'`('MODULE`:'PREDICATE`/'ARITY`)'

Where MODULE and PREDICATE should be module and predicate name atoms
and ARITY should be an integer (the number of arguments of the
predicate).  For example:

     predicate#(main:main/0)  predicate#(quicksort:partition/4)

are valid predicate constants in programs.

   Note that predicate constants are recognized by the KLIC compiler and
not by the KLIC parser (*note Input and Output with Prolog-like
Interface: Prolog I/O.).  Thus, the notation described above means a
usual data structure when simply read in using the Prolog-like I/O
streams.

 - Object Creation on predicate: new -PREDICATE +MODULE +PREDNAME +ARITY
     Creates a new object PREDICATE corresponding to the predicate
     specified by MODULE (a module object), PREDNAME (a symbolic atom)
     and ARITY (an integer).  *Note Creating Objects::, for the format
     of object creation goals.

 - Guard Method on predicate: predicate +PREDICATE
     Tests whether PREDICATE is a predicate object or not.

 - Guard Method on predicate: arity +PREDICATE -ARITY
 - Body Method on predicate: arity +PREDICATE -ARITY
     The arity of the predicate PREDICATE is returned to ARITY.

 - Body Method on predicate: apply +PREDICATE +ARGVEC
     Calls the predicate specified by a predicate object PREDICATE with
     arguments specified by ARGVEC.  ARGVEC should be a vector of
     arguments to be passed to PREDICATE.  Thus, the size of the vector
     should match with the arity of the predicate.

 - Body Method on predicate: call +PREDICATE +ARGS...
     Calls the predicate specified by a predicate object PREDICATE with
     arguments specified by `ARGS...'.  The number of the arguments
     should match with the arity of the predicate.

 - Body Method on predicate: module +PREDICATE -MODULE
     The program module that PREDICATE belongs to is returned to MODULE
     as a module data object.

 - Body Method on predicate: name +PREDICATE -NAME
     The name of the predicate PREDICATE is returned to NAME as a
     symbolic atom.


File: KLIC.info,  Node: Unix,  Next: Input and Output,  Prev: Executable Code,  Up: Builtin and Library

Unix Interface
==============

   The module named `unix' makes features of the host operating system
(Unix, typically) available to KL1 programs.

   Almost all of the features are available as messages to a stream
obtained by a predicate `unix/1' provided by the module `unix'.  Some
features are provided directly by predicates of the module.

* Menu:

* Unix Stream::                 Obtaining Unix interface stream
* I/O Opening::                 Opening input/output streams
* Sockets::                     Internet- and Unix-domain protocol sockets
* Files & Dirs::                Manipulation of files and directories
* Signals::                     Signal interrupt handling
* Misc Unix Messages::          Miscellaneous messages to the Unix stream
* Predicate Interface::         Predicate interface for command line args &c


File: KLIC.info,  Node: Unix Stream,  Next: I/O Opening,  Prev: Unix,  Up: Unix

Obtaining Unix Interface Stream
-------------------------------

   The module "unix" interfaces other programs through message streams.
The stream can be obtained by calling the following predicate.

 - Predicate on unix: unix ?STREAM
     A message stream corresponding to the Unix interface is returned to
     STREAM.

   Most of the features of the Unix interface are *not* provided as
predicates, because no ordering is guaranteed between predicate calls.

   If the Unix interface *were* provided as predicates, for example:

     unix:cd("a", 0),
     unix:cd("b", 0),
     unix:system("mkdir ls", 0)

may list the directory `a' but may possibly list `b' or even some other
directory before doing any `cd', depending on the execution order.  On
the other hand:

     unix:unix([cd("a", 0),
                cd("b", 0),
                system("ls", 0)])

will surely try two `cd' and `ls' in this order, as what decides the
order is not the order of execution but the order of the elements in a
list structure.

   On parallel implementations, KLIC consists of multiple processes.
The process in which the unix stream is obtained will be the process
where all the messages are handled.  For example, `cd(Path)' message
will change working directory of that single process and none of others.

   If you obtain two or more message streams, there will be no automatic
synchronization between messages sent to different streams.


File: KLIC.info,  Node: I/O Opening,  Next: Sockets,  Prev: Unix Stream,  Up: Unix

Opening Streams for Input and Output Operations
-----------------------------------------------

   The following messages to the Unix stream open a Unix I/O stream.
Messages to be sent to the resulting Unix I/O streams (*not* the Unix
stream stream itself) for actually performing I/O are described in
separate places: *Note Input and Output with C-like Interface: C-like
I/O, and *Note Input and Output with Prolog-like Interface: Prolog I/O.

   The following is a KLIC program for saying hello to the world.

     main :- unix:unix([stdout(R)]), check_and_write(R).
     
     check_and_write(normal(R)) :- R = [fwrite("hello world\n")].

 - Message on unix stream: stdin -RESULT
 - Message on unix stream: stdout -RESULT
 - Message on unix stream: stderr -RESULT
     These messages open a stream associated with process's standard
     input, standard output and standard error file respectively, and
     return `normal(STREAM)' to RESULT.

 - Message on unix stream: read_open +PATH -RESULT
 - Message on unix stream: write_open +PATH -RESULT
 - Message on unix stream: append_open +PATH -RESULT
 - Message on unix stream: update_open +PATH -RESULT
     These messages open the file named by the string PATH, and return
     `normal(STREAM)' to RESULT.  The opening mode is input, output,
     append or input/output, respectively.  If opening of the file
     fails, `abnormal' is returned instead.


File: KLIC.info,  Node: Sockets,  Next: Files & Dirs,  Prev: I/O Opening,  Up: Unix

Using Sockets
-------------

   Unix- and Internet-protocol sockets can be obtained using the
following messages to the Unix stream.  Only sockets of SOCK_STREAM
type are provided.

 - Message on unix stream: connect +SPEC -RESULT
     Creates a socket and connects it to socket specified by SPEC and
     returns `normal(STREAM)' to RESULT.  SPEC should have either of
     the following formats.

    unix(PATH)
          A unix domain socket with the pathname PATHis opened.

    inet(HOSTNAME, PORT)
          An internet domain socket of the host specified by a string
          HOSTNAME and port number PORT is opened.

    inet({B1, B2, B3, B4}, PORT)
          An internet domain socket is opened.  The host is specified
          by the internet address B1 through B4 is opened.  The
     obtained stream handles both input and output messages.

 - Message on unix stream: bind +SPEC -RESULT
     Creates a socket and binds it to a name specified by SPEC.  The
     format of SPEC is the same for the message `connect' *except* that
     HOSTNAME should be omitted for internet domain sockets.  What is
     returned to RESULT is `normal(STREAM)' but this STREAM is a bound
     socket stream and does not directly handle I/O messages.  Rather,
     it expects `accept' messages to obtain I/O message streams.  When
     the bound socket stream obtained is closed and the socket type is
     `unix', the named socket specified by PATH in SPEC will be
     unlinked.

 - Message on bound socket: accept -RESULT
     Accepts a connection to the socket and returns `normal(STREAM)' to
     RESULT, where STREAM is an I/O message stream for both input and
     output messages.

   Sockets provide asynchronous I/O, that is, waiting for a connection
or acceptance of a connection will not block other processes in the KLIC
system.  Trying to read or write to sockets with buffers empty or full
respectively will not block the whole computation.  Such I/O operations
will be postponed until immediate operations become possible.

   *Limitations:* When an operation on a socket is postponed, all the
remaining operations to be done on the socket are also postponed until
the completion of the postponed operation.  This is problematic when
both input and output has to be polled.  The problem is planned to be
solved in a future release.

   *Limitations on Linux:*Asynchronous I/O operations do not work on
Linux (at least with Slackware 1.2.0) with the current version.


File: KLIC.info,  Node: Files & Dirs,  Next: Signals,  Prev: Sockets,  Up: Unix

Files and Directories
---------------------

   The following message to the unix stream handles files and
directories.

 - Message on unix stream: cd +PATH -RESULT
     Changes the working directory to PATH.  If successful, `0' is
     returned to RESULT; otherwise, `-1' is returned.  Corresponds to
     `chdir' system call.

 - Message on unix stream: unlink +PATH -RESULT
     Removes the directory entry specified by PATH.  If successful, `0'
     is retuned to RESULT; otherwise, `-1' is returned.  Corresponds to
     `unlink' system call.

 - Message on unix stream: mktemp +TEMPLATE -FILENAME
     Makes a unique file name from the given TEMPLATE and returns it to
     FILENAME.  Corresponds to the C library routine `mktemp'.  Unlike
     the library routine, the template does *not* have to have six
     trailing `X' characters.  If a unique file name cannot be created
     somehow, a null string is returned to FILENAME.

 - Message on unix stream: access +PATH +MODE -RESULT
     Checks accessibility of the file with pathname PATH with the mode
     MODE is validate, and returns the result to RESULT.  Corresponds
     to the C library routine `access'.  If the file is accessible, `0'
     is returned; otherwise, `-1' is returned.  MODE is an integer,
     with the bits of the following meaning.

    4
          read permission

    2
          write permission

    1
          execute permission

    0
          test existence

 - Message on unix stream: chmod +PATH +MODE -RESULT
     Changes the permission mode of the file with pathname PATH to
     MODE.  Corresponds to the system call `chmod'.  If changing the
     mode is successful, `0' is returned to RESULT; otherwise, `-1' is
     returned.  MODE is an integer with standard Unix permission bits.

 - Message on unix stream: umask -OLDMASK
 - Message on unix stream: umask -OLDMASK +NEWMASK
     Returns the current file creation mask to OLDMASK.  With two
     arguments, sets the file creation mask to NEWMASK.  Corresponds to
     the `umask' system call.


File: KLIC.info,  Node: Signals,  Next: Misc Unix Messages,  Prev: Files & Dirs,  Up: Unix

Handling Signal Interrupts
--------------------------

   Unix signals can be converted to a list of integers using the
following message to the unix stream.

 - Message on unix stream: signal_stream +SIGNAL -RESULT
     Unix signals specified by SIGNAL (an integer value) will become
     caught and reported.  The argument RESULT will become
     `normal(Stream)' and whenever a signal of the specified kind is
     detected, that signal number is sent to Stream.  For example, if
     signal 2 (SIGINT in BSD and SVR4, at least) is detected, Stream
     becomes `[2|REST]'.  Further signals are reported to REST.

*Limitations:* Signals may be ignored when they occur more than twice
before the same kind of signal is detected, due to limitations of Unix.


File: KLIC.info,  Node: Misc Unix Messages,  Next: Predicate Interface,  Prev: Signals,  Up: Unix

Miscellaneous Messages to the Unix Stream
-----------------------------------------

   Various features of Unix are provided by sending the fllowing
messages to the unix stream.

 - Message on unix stream: system +COMMAND -RESULT
     Executes COMMAND (a string) in a newly created subshell, and
     returns its exit code to RESULT.  Corresponds to the `system'
     system call.

 - Message on unix stream: getenv +NAME -VALUE
     Returns the value of the environment variable with the name NAME
     to VALUE.  Corresponds to the library routine `getenv'.  If such a
     environment variable does not exist, integer `0' is returned to
     VALUE.

 - Message on unix stream: putenv +STRING -RESULT
     The first argument STRING should be of form `NAME = VALUE'.  Adds
     or updates the environment variable NAME with the value VALUE.
     Corresponds to the library routine `putenv'.  If addition or
     updating is successful, `0' is returned to RESULT.  Otherwise,
     non-zero integer value is returned.

 - Message on unix stream: kill +PID +SIG -RESULT
     Sends the signal SIG to a process or a group of processes
     specified by PID, and returns `0' on success or `-1' on failure to
     RESULT.

 - Message on unix stream: fork -PID
     Forks a new process which is a copy of the current process.
     Corresponds to the `fork' system call.  If a child process is
     successfully created, the process ID of the child process is
     returned to PID in the parent process, and `0' is returned in the
     child process.

 - Message on unix stream: fork_with_pipes -RESULT
     Creates pipes and fork a new process.  The new process is a copy
     of the current process.  In the parent process, RESULT is unified
     with `parent(PID, IN, OUT)', where PID is the process ID of the
     newly created process.  In the newly create child process, RESULT
     is unified with `child(IN, OUT)'.  IN and OUT are Unix I/O streams
     to pipes; parent's OUT is an output stream connected to child's
     IN, which is an input stream; child's OUT is connected to parent's
     IN.


File: KLIC.info,  Node: Predicate Interface,  Prev: Misc Unix Messages,  Up: Unix

Predicate Interface
-------------------

   Some of the Unix interface are provided as predicates defined in the
module `unix'.

 - Predicate on unix: argc -ARGC
     Number of command line arguments not used by the KLIC system is
     returned to ARGC.  Such arguments start from the first argument not
     beginning with `-' or after `--' in the command line.

 - Predicate on unix: argv -ARGLIST
     Command line arguments nod used by the KLIC system is returned to
     ARGLIST as a list of strings.

 - Predicate on unix: exit +EXITCODE
     Terminates the process immediately with the exit code EXITCODE.

 - Predicate on unix: times -UTIME -STIME -CUTIME -CSTIME
     Returns process times in milliseconds.  UTIME is user time and
     STIME is system time.  CUTIME and CSTIME are those for children
     processes.

     Note that when `HZ' (clock ticks per second) is not defined in some
     standard places, the system assumes 60.


File: KLIC.info,  Node: Input and Output,  Next: System Control,  Prev: Unix,  Up: Builtin and Library

Input and Output
================

   KLIC provides two different sets of I/O operations.  One is similar
to those available from C language and the other is similar to those
available from Prolog language.

   C-like features are in a lower level and provide better performance
both in speed and code size.  However, during prototyping and debugging
phases, the Prolog-like higher-level interface, allowing I/O of data
structures directly, might be beneficial.

* Menu:

* C-like I/O::                  I/O with C language-like interface
* Prolog I/O::                  I/O with Prolog language-like interface


File: KLIC.info,  Node: C-like I/O,  Next: Prolog I/O,  Prev: Input and Output,  Up: Input and Output

Input and Output with C-like Interface
--------------------------------------

   Input and output operations with interface similar to those
available in language C are described in this section.

   Such interface are provided as messages to streams to open files,
sockets, pipes &c, which are obtained by various messages to the Unix
stream.  *Note Opening Streams for Input and Output Operations: I/O
Opening.

* Menu:

* Common Msgs (C style)::       Messages common to both input and output
* Input Msgs (C style)::        Messages for C-like input streams
* Output Msgs (C style)::       Messages for C-like output streams


File: KLIC.info,  Node: Common Msgs (C style),  Next: Input Msgs (C style),  Prev: C-like I/O,  Up: C-like I/O

Common Messages with C-like Interface
.....................................

   The following messages are available for both input and output
streams for C-like I/O.

 - Message on C-like I/O: feof -RESULT
     Returns `1' to RESULT if the stream is at the end of the file;
     otherwise `0'.  Corresponds to the library routine `feof'.

 - Message on C-like I/O: fseek +OFFSET +PTRNAME -RESULT
     Changes the position of the stream according to the offset and
     pointer name given as OFFSET and PTRNAME, respectively.  The offset
     is specified as a signed integer by OFFSET.  When PTRNAME is 0,
     the offset is from the beginning of the file; when 1, from the
     current position; when 2, from the end of file.  If successful, `0'
     is returned RESULT; otherwise `-1'.

     Note that, due to the range restriction of integer values, this
     message may not be able to move to arbitrary positions in a very
     large file (larger than 128MB, on systems with 32-bit long
     integers).

 - Message on C-like I/O: ftell -RESULT
     Returns the offset of the current byte position to RESULT.

     Note that, due to the range restriction of integer values, the
     obtained position may be incorrect for a very large file (larger
     than 128MB, on systems with 32-bit long integers).

 - Message on C-like I/O: fclose -RESULT
     Closes the stream.  Returns `0' to RESULT if successful; `-1'
     otherwise.  No messages except for `sync/1' should be sent to a
     stream after closing.

 - Message on C-like I/O: sync -RESULT
     Returns `0' to RESULT.  Useful in making sure that all the
     preceding messages have already been processed.


File: KLIC.info,  Node: Input Msgs (C style),  Next: Output Msgs (C style),  Prev: Common Msgs (C style),  Up: C-like I/O

Input Messages with C-like Interface
....................................

   The following messages are available for input streams for C-like
I/O.

 - Message on C-like I/O: getc -C
     Reads one byte from the stream and returns it to C.  At the end of
     file, `-1' is returned.

 - Message on C-like I/O: ungetc +C
     Pushes back one byte C to the stream.

 - Message on C-like I/O: fread +MAX -STRING
     Reads in at most MAX bytes from the stream and returns the data as
     a byte string to STRING.  Only up to 4,096 bytes can be handled in
     the current implementation.  Note that the length of the resultant
     string may be smaller than the given maximum.  This may happen at
     the end of the file for normal files and at any time for pipes or
     sockets.

 - Message on C-like I/O: linecount -COUNT
     Returns to COUNT the number of newline characters encountered so
     far.  Within the first line of a file, it returns `0', as no
     newlines have been encountered yet.  Conventional one-origin line
     numbers can be computed by adding one to this.

     This line counting can be confused when `fseek/2' messages are
     used.


File: KLIC.info,  Node: Output Msgs (C style),  Prev: Input Msgs (C style),  Up: C-like I/O

Output Messages with C-like Interface
.....................................

   The following messages are available for output streams for C-like
I/O.

 - Message on C-like I/O: putc +C
     Writes one byte C to the stream.

 - Message on C-like I/O: NUMBER
     Writes one byte NUMBER to the stream.  This is synonymous to
     `putc(NUMBER)'.

 - Message on C-like I/O: fwrite +STRING -RESULT
     Writes out the contents of the byte string STRING to the stream
     and returns number of bytes actually written to RESULT.  Note that
     the number of bytes actually written may be smaller than the
     length of STRING.

 - Message on C-like I/O: fwrite +STRING
     Writes out the contents of the byte string STRING to the stream.
     Unlike the `fwrite' message with RESULT argument, it waits for all
     the bytes in STRING to be output.  This may be undesirable for
     streams that require unpredictable time period for output, such as
     internet sockets and pipes.

 - Message on C-like I/O: fflush -RESULT
     Flushes any output remaining on the stream.  Returns `0' to RESULT
     if successful; `-1' otherwise.


File: KLIC.info,  Node: Prolog I/O,  Prev: C-like I/O,  Up: Input and Output

Input and Output with Prolog-like Interface
-------------------------------------------

   Unix interface streams with features to handle Prolog-like terms
based on a operator precedence grammar can be obtained by the following
predicate of module `klicio'.

   The syntax of terms of KLIC is very close to that of Edinburgh Prolog
but with subtle differences.  *Note Notation of Atoms::, *Note Notation
of Integers::, *Note Notation of Floats::, *Note Notation of Functors::,
*Note Notation of Lists::, *Note Notation of Vectors::, and *Note
Notation of Strings::, for details.

* Menu:

* Opening Prolog I/O::          Opening Prolog-like I/O streams
* Common Msgs (Prolog style)::  Message common to input and output streams
* Input Msgs (Prolog style)::   Input messages with Prolog-like interface
* Output Msgs (Prolog style)::  Output messages with Prolog-like interface
* Wrapped Terms::               Manipulation of wrapped terms


File: KLIC.info,  Node: Opening Prolog I/O,  Next: Common Msgs (Prolog style),  Prev: Prolog I/O,  Up: Prolog I/O

Opening Prolog-like I/O Streams
...............................

 - Predicate on klicio: klicio ?STREAM
     A message stream corresponding to the Prolog-like term interface is
     returned to STREAM.  The obtained stream works the similar to a
     unix interface stream, which is used in turn to obtain message
     streams for actual I/O.  I/O streams obtained through this stream
     accepts messages for Prolog-like term I/O described in this
     section in addition to ordinary C-like I/O messages.

     This `klicio' stream is provided separately so that programs
     *without* the need of Prolog-like term I/O can be executable
     without modules for parsing and unparsing, as these modules have
     non-negligible sizes.

 - Message on klicio stream: stdin -RESULT
 - Message on klicio stream: stdout -RESULT
 - Message on klicio stream: stderr -RESULT
 - Message on klicio stream: read_open +PATH -RESULT
 - Message on klicio stream: write_open +PATH -RESULT
 - Message on klicio stream: append_open +PATH -RESULT
 - Message on klicio stream: update_open +PATH -RESULT
     These messages open Prolog-like I/O streams.  Messages to be sent
     to the resulting Prolog-like I/O streams (*not* the `klicio' stream
     itself) for actually performing I/O are described below.

     These messages work exactly the same as the corresponding messages
     for `unix' streams, except that returned I/O streams understand
     messages for Prolog-like term I/O *in addition to* the messages for
     C-like I/O streams.

     Prolog-like I/O streams are associated with operator definitions.
     Different operator definitions may be associated with each stream.
     Thus, adding or removing an operator to one stream will *not*
     affect operators used in other streams.  Immediately after
     creation, each stream has a default set of operators.


File: KLIC.info,  Node: Common Msgs (Prolog style),  Next: Input Msgs (Prolog style),  Prev: Opening Prolog I/O,  Up: Prolog I/O

Common Messages with Prolog-like Interface
..........................................

   The following messages for C-like I/O streams can be used for
Prolog-like I/O streams.

 - Message on Prolog-like I/O: feof -RESULT
 - Message on Prolog-like I/O: fseek +OFFSET +PTRNAME -RESULT
 - Message on Prolog-like I/O: ftell -RESULT
 - Message on Prolog-like I/O: fclose -RESULT
 - Message on Prolog-like I/O: sync -RESULT
     *Note Common Messages with C-like Interface: Common Msgs (C style),
     for details.

 - Message on Prolog-like I/O: addop +OP +TYPE +PREC
     Adds an operator OP of type TYPE with precedence PREC.

 - Message on Prolog-like I/O: rmop +OP +TYPE
     Removes an operator OP of type TYPE.


File: KLIC.info,  Node: Input Msgs (Prolog style),  Next: Output Msgs (Prolog style),  Prev: Common Msgs (Prolog style),  Up: Prolog I/O

Input Messages with Prolog-like Interface
.........................................

 - Message on Prolog-like I/O: gett -TERM
     Reads in a KLIC syntax term from the associated input stream to
     TERM.  On parsing errors, a message is output to `stderr' and
     another term is read in.  At the end of the file, it returns an
     atom `end_of_file'.

 - Message on Prolog-like I/O: getwt -RESULT
     Reads in a KLIC syntax term from the associated input stream and
     returns the result to RESULT.  RESULT will have the form
     `normal(WRAPPEDTERM)' if parsing completes without errors.  Here,
     WRAPPEDTERM is a ground term representation of the term read in,
     where variables are represented as a ground term with the
     information on their names.  On parsing errors, a message is
     output to `stderr' and another term is read in.  At the end of
     file, it returns `normal(end_of_file)'.

     *Note Wrapped Terms:: for manipulation of wrapped terms.

   The following messages for C-like I/O streams can also be used for
Prolog-like I/O streams.

 - Message on Prolog-like I/O: getc -C
 - Message on Prolog-like I/O: ungetc +C
 - Message on Prolog-like I/O: fread +MAX -STRING
 - Message on Prolog-like I/O: linecount -COUNT
     *Note Input Messages with C-like Interface: Input Msgs (C style),
     for details.


File: KLIC.info,  Node: Output Msgs (Prolog style),  Next: Wrapped Terms,  Prev: Input Msgs (Prolog style),  Up: Prolog I/O

Output Messages with Prolog-like Interface
..........................................

 - Message on Prolog-like I/O: putt +TERM
 - Message on Prolog-like I/O: puttq +TERM
 - Message on Prolog-like I/O: putwt +WRAPPEDTERM
 - Message on Prolog-like I/O: putwtq +WRAPPEDTERM
     A term TERM or a wrapped term WRAPPEDTERM is written out to the
     associated output stream.

     Messages *without* the character `q' are supposed to omit two
     quotes around symbolic atoms even when they are required to be
     correctly read in again.  However, currently they work exactly the
     same as the messages with `q'.

     With the current version, the output format is meant only to be
     machine-readable and not so readable for humans.  That is, no
     operators are used and all atoms are enclosed within parentheses.

     *Note Wrapped Terms:: for manpulation of wrapped terms.

   The following messages for C-like I/O streams can also be used for
Prolog-like I/O streams.

 - Message on Prolog-like I/O: putc +C
 - Message on Prolog-like I/O: NUMBER
 - Message on Prolog-like I/O: fwrite +STRING -RESULT
 - Message on Prolog-like I/O: fwrite +STRING
 - Message on Prolog-like I/O: fflush -RESULT
     *Note Output Messages with C-like Interface: Output Msgs (C style),
     for details.

   Note that a period to end a term is not written out by these
messages.  Thus, writing out a period and a space or a newline
character is usually required for the output to be read in again.  The
following goal sequence opens the file named `/tmp/foo.bar', waits full
instantiation of the variable X, and then outputs the value in a
Prolog-like format followed by a period and a newline.

     klicio:klicio([write_open("/tmp/foo.bar", normal(S))]),
     S = [putt(X), putc(0'.), nl].

 - Message on Prolog-like I/O: nl
     Outputs a newline code.  This is synonymous to sending a message
     `putc(10)' to the same stream.

   Note that Prolog-like I/O streams also accept all the messages
accepted by C-like I/O such as `putc/1' or `getc/1' (*note Input and
Output with C-like Interface: C-like I/O.).


File: KLIC.info,  Node: Wrapped Terms,  Prev: Output Msgs (Prolog style),  Up: Prolog I/O

Wrapped Terms
.............

   To allow metalevel manipulation of terms including variables, KLIC
provides a data representation called "wrapped term".  A wrapped term
is a ground term without any variables in it.  A wrapped term has one
of the following forms.

variable(VARNAME)
     a variable with its name string VARNAME

atom(ATOM)
     a symbolic atom ATOM

integer(INT)
     an integer INT

floating_point(FLOAT)
     a floating point number FLOAT

list([CAR|CDR])
     a cons cell consisting of CAR and CDR, which are wrapped terms
     recursively

functor(FUNCTOR(ARG, ...)
     a functor structure; its arguments (ARG, etc) are wrapped terms
     recursively

vector({ELEM, ...})
     a vector; its elements (ELEM, etc) are wrapped terms recursively

string(STR)
     a string STR

unknown(TERM)
     some unknown data; wrapping may be inprecise in this case

   For example, the wrapped representation of a term:

     f(a, X, {3, ["abc"|X]}, 3.14)

is the following.

     functor(f(atom(a),
             variable("X"),
             vector({integer(3), list([string("abc")|variable("X")])}),
             floating_point(3.14))).

   The following predicate convert wrapped terms to normal terms.

 - Predicate on variable: unwrap -WRAPPED ?TERM
     Converts a wrapped term WRAPPED to a normal term TERM.

   Wrapped terms are normally obtained as a result of input operations
(*note Input Messages with Prolog-like Interface: Input Msgs (Prolog
style).).  Wrapped terms can also be constructed by usual user
programs, as they are nothing more than a usual KL1 term.  The following
predicate that converts normal terms to wrapped terms may also be useful
in certain cases.

 - Predicate on variable: wrap ?TERM -WRAPPED
     Converts a normal term TERM to a wrapped term WRAPPED.

     In the current version, all variables are given the same name `_'.
     Thus, by wrapping a term and then unwrapping its result, all the
     variables in the original term will become references to the same
     variable.  This is a bug and is planned to be fixed in a future
     version.

     When TERM contains multiple references of a same variable,
     computation on-going concurrently may instantiate the variable.
     In such cases, this predicate may yield a wrapped term in which
     two original occurrences of the same variable are converted
     differently; one as a variable and another as a non-variable term.
     This is an inherent problem of the specification of this
     predicate and probably will never be fixed.  Thus, applying this
     predicate to non-ground terms should be restricted to certain
     metalevel programs, such as debugging utilities.


File: KLIC.info,  Node: System Control,  Next: Timer,  Prev: Input and Output,  Up: Builtin and Library

Controlling System Behavior
===========================

   The following predicates are provided in the module `system_control'.

 - Predicate on system_control: postmortem +MODULE +GOAL -RESULT
     Registers postmortem processing after normal or abnormal
     termination of the main program.  GOAL should be a functor
     structure specifying the predicate and arguments of the postmortem
     processing goal.  MODULE should be a symbolic atom specifying the
     module of the postmortem processing predicate.  Only a single goal
     can be specified; comma-separated sequences of goals are not
     allowed.

     When the registration is done, RESULT is unified with `[]'.
     Waiting for this will prevent further processing to be executed
     before the completion of the registration.

     If this predicate is called many times, the last registration will
     be effective.

 - Predicate on system_control: gc -BEFORE -AFTER
     Requests garbage collection and returns the heap size in words
     before and after the garbage collection to BEFORE and AFTER
     respectively.  The size of a word is the same as the size of type
     `long' of the C language system used in the installation.

     In parallel implementations, only garbage collection for local
     storage is requested.  Requesting of global garbage collection is
     not available.


File: KLIC.info,  Node: Timer,  Next: Random Numbers,  Prev: System Control,  Up: Builtin and Library

Timer
=====

   KLIC provides real-time timers.  Although Unix provides only one
timer per process, KLIC virtualizes the mechanism and provides as many
timers as needed.

   Implementations on host systems where real-time timers are not
available do not provide the feature.

   Time values (both times and time intervals) are represented by a
term of the form `time(DAY, SEC, USEC)', where DAY, SEC and USEC are
non-negative integers representing days, seconds and microseconds.  SEC
should be less than 86,000 (one day) and USEC should be less than
1,000,000 (one second).

   The following predicates are provided in the module `timer'.

 - Predicate on timer: get_time_of_day -TIME
     The current time expressed in seconds and microseconds since
     midnight of January 1, 1970 GMT is returned to TIME.

     The time obtained is that of when a goal of this predicate is
     actually executed.  Note that ordering of goal execution is up to
     the KLIC system.  The time reported is only guaranteed to be the
     time between two observable events: when the parent goal of this
     goal is reduced, and when the value of TIME is inspected.

     Note also that the reported time is what is returned by the
     underlying operating system of the worker task.  On a distributed
     system, clocks of constituting systems may not agree completely.

 - Predicate on timer: add TIME1 TIME2 -TIME
 - Predicate on timer: sub TIME1 TIME2 -TIME
     Computes sum and difference of two time values, respectively.

 - Predicate on timer: compare TIME1 TIME2 -RESULT
     Compares two time values TIME1 and TIME2 and returns the result in
     RESULT.  The result is `<' if TIME1 is smaller than (or before)
     TIME2, `=' if they are the same, `>' if TIME1 is larger than (or
     after) TIME2.

 - Predicate on timer: instantiate_at TIME -VAR
 - Predicate on timer: instantiate_after INTERVAL -VAR
     Unifies VAR with a symbolic atom `[]' at the time specified.  The
     former predicate does this *at* the specified time, while the
     latter does this *after* the specified time interval.  If the
     specified time has already passed, the variable may be instantiated
     immediately.

     Note that instantiation may be delayed arbitrarily long.
     Reasonable implementations should have short delays.

 - Predicate on timer: instantiate_every INTERVAL STOP -VAR
     Incrementally instantiate VAR with a list of symbolic atom `[]'.
     The first element is instantiated after the time interval
     specified, the second after time twice the specified value, etc.
     It will be repeated forever unless the argument STOP becomes
     instantiated, on that occasion, the list will be terminated.

     Note that instantiation may be delayed arbitrarily long.
     Reasonable implementations should have short delays.


File: KLIC.info,  Node: Random Numbers,  Prev: Timer,  Up: Builtin and Library

Random Number Generator
=======================

   Pseudo-random numbers can be generated using the object class
`random_numbers'.  This random number generator is based on `nrand48'.
The random number genrator feature is not availble if `nrand48' is not
on the host system.

 - Object Creation on random_numbers: new -RANDOMS RANGE
 - Object Creation on random_numbers: new -RANDOMS RANGE SEED
     An infinitely long list of pseudo-random integers ranging between
     0 and RANGE - 1, inclusive, is returned to RANDOMS.  RANGE should
     be a positive integer.  The optional argument SEED specifies the
     seed for random number generation.  The list elements are
     guaranteed to be the same if the same seed is given.

     Note that, although the list is virtually infinite, elements are
     computed lazily on demand as programs incrementally inspect their
     values.


File: KLIC.info,  Node: Using KLIC,  Next: Type Index,  Prev: Builtin and Library,  Up: Top

Using KLIC
**********

   This chapter describes how to use the KLIC system.

* Menu:

* Compiling::                   How to compile KL1 programs
* Running::                     How to run programs compiled with KLIC
* Tracing::                     Tracing execution for debugging
* Install::                     Installation of KLIC
* Distributed KLIC::
* Shared-Memory KLIC::


File: KLIC.info,  Node: Compiling,  Next: Running,  Prev: Using KLIC,  Up: Using KLIC

Compiling Programs with KLIC
============================

   After proper installation, KL1 programs can be compiled into C
program and then to executables by the command `klic'.  `klic' is a
compiler driver that allows various options.

* Menu:

* Command for Compilation::     Program compilation command
* Compiler Options::            Compiler options
* Mechanism of Compilation::    How programs are compiled


File: KLIC.info,  Node: Command for Compilation,  Next: Compiler Options,  Prev: Compiling,  Up: Compiling

Command for Compilation
-----------------------

   By simply running `klic' command with the name of KL1 program source
file with the trailing `.kl1' as an argument, that program will be
compiled into C and then to an executable format.

   For example, to compile `XXX.kl1', type in:

     % klic XXX.kl1

   The compilation result will be found in `a.out'.  If you want the
compilation result to be named `YYY', do the following.

     % klic -o YYY XXX.kl1

   If your program is divided into several files, say `XXX.kl1',
`YYY.kl1' and `ZZZ.kl1', you can compile and link them together by the
following.

     % klic XXX.kl1 YYY.kl1 ZZZ.kl1

   It is also possible to separately compile several KL1 source files
and link them afterwards.  To avoid linkage errors, you have to stop
before linkage by giving the `-c' flag, as follows.

     % klic -c XXX.kl1
     % klic -c YYY.kl1
     % klic -c ZZZ.kl1

   Finally, you have to link all of them together by the following.

     % klic XXX.o YYY.o ZZZ.o

   See *Note Compiler Options::, for details of compilation flags.

   If you want to link program pieces written directly in C, say
`CCC.c' and `DDD.c', with pieces written in KL1, `XXX.kl1' and
`YYY.kl1', simply do the following.

     % klic CCC.c DDD.c XXX.kl1 YYY.kl1

   The order of files specified does not matter.  C functions can be
invoked from within inline-expanded codes (*note Inline C Code::.).


File: KLIC.info,  Node: Compiler Options,  Next: Mechanism of Compilation,  Prev: Command for Compilation,  Up: Compiling

Compiler Options
----------------

   Options available for the compilation command `klic' are listed
below.

-c
     Stop after generating relocatable object and don't link the
     program.

-C
     Stop after translation into C.

-d
     Don't try any compilation (dry run).  Implies `-v'.

-D DATABASE_MANAGER
     Use the specified database manager program.

-g
     Debug flag passed to the C compiler.

-I DIRECTORY
     Use the additional include directory specified for C compilation.

-K KLIC_COMPILER
     Use the speicfied KL1 to C translator program.

-l LIBRARY
     Use the additional library specified for linking.

-L DIRECTORY
     Use the additional directory specified to be searched for `-l'.

-o FILE
     Use the file name for the generated executable file.

-O
-OLEVEL
     Use the specified optimization level.  When a non-zero optimization
     level is specified, some additional optimization flags may be also
     passed to the C compiler.  Such Additional optimization flags are
     system dependent and determined on KLIC system installation
     procedure.

     For this option, no spaces are allowed between `-O' and LEVEL.

-P PARALLEL
     Run subtasks (C compilers &c) in parallel.  At most PARALLEL
     subtasks are forked at a time.

-R
     Do recompilation regardless of file dates.

-S
     Stop after generating assembly code output.

-n
     Link with the non-debugging version of the runtime library.  By
     default, the debugging version is used.

-v
     Run in verbose mode.  All the commands executed through the
     compielr driver will be output to standard error.

-xDIRECTORY
     Use database file `klic.db' in the specified directory and also
     place `atom.c', `funct.c' and `predicates.c' and their
     corresponding objects in the same directory.  This flag is useful
     when programs to be linked together are distributed to multiple
     directories.

-XDIRECTORY
     Initiate the database file `klic.db' from the database initiation
     file `klicdb.init' under the specified directory, when the database
     file does not exist yet.  It defaults to the default library
     directory.

   The following environment variables can change the default behavior
of the compiler.  Options given at compilation time supersede the
environment variable values.

KLIC_LIBRARY
     Directory for runtime libraries.  Superseded by the `-X' option.

KLIC_DBINIT
     Directory for initial database.  Defaults to the directory for
     runtime libraries.

KLIC_COMPILER
     KL1 to C translator program.  Superseded by the `-K' option.

KLIC_DBMAKER
     Database manager program.  Superseded by the `-D' option.

KLIC_INCLUDE
     Additional include directory for C compilation.  Superseded by the
     `-I' option.

KLIC_CC
     C compiler to be used.

KLIC_CC_OPTIONS
     Additional option flags for the C compiler.

KLIC_LD
     Linker to be used.

KLIC_LD_OPTIONS
     Additional option flags for the linker.


File: KLIC.info,  Node: Mechanism of Compilation,  Prev: Compiler Options,  Up: Compiling

How KLIC Compiler Works
-----------------------

   Understanding how KL1 programs are compiled and executed may help
understanding the usage of KLIC in further depth.

   The system consists of the following three modules.

   * KLIC compiler

   * KLIC database manager

   * KLIC runtime system

   KL1 programs are compiled using the KLIC compiler into C programs.
It also generates files `FILE.ext' containing information on atoms and
functors used in the program.  The information in `.ext' files for
programs to be linked together is merged together later by the database
manager, into files `atom.h', `funct.h', `atom.c', `funct.c' and
`predicates.c'.

   The object C program is then compiled by a C compiler, with headers
provided by the KLIC runtime system, `atom.h' and `funct.h'.  The files
`atom.c', `funct.c' and `predicates.c' are also compiled, and linked
together with the runtime system (`predicates.c' is linked only with
debugging runtime).

   Compilation, database management and linkage are governed by a driver
program named `klic'.  This program `klic' plays a role similar to `cc'
and `make' combined.  `cc' controls the C preprocessor, the C compiler
kernel and the linker; `klic' controls the KL1-to-C compiler, the C
compiler, the KL1 program database manager and the linker.  `make'
selectively executes compilation only when needed by examining the file
dates; `klic' works similarly.


File: KLIC.info,  Node: Running,  Next: Tracing,  Prev: Compiling,  Up: Using KLIC

Running Programs Compiled with KLIC
===================================

   You can simply run the compiled excutable.  If you compiled your
program into the file `a.out', you simply give the file name `./a.out'
to the shell you are using.

   The predicate `main' with no arguments in the module `main' will be
the initial goal to be executed (*note Initial Goal::.).

* Menu:

* Runtime Switches::            Runtime command line switches


File: KLIC.info,  Node: Runtime Switches,  Prev: Running,  Up: Running

Runtime Switches for Programs Compiled with KLIC
------------------------------------------------

   The following options are available on running the compiled
executable.

-h SIZE
     Specifies initial heap size in  words.  As copying garbage
     collection is used, memory size actually used for heap will  be
     twice this  size.  The size  can be specified  directly  (such  as
     `2097152') or  with  a postfix `k' or  `m' (as `2048k' or `2m')
     to specify units of 2^10 or 2^20 words.  The default heap size is
     determined by the macro `HEAPSIZE',  which is 24k in the original
     distribution.   The length of one word is the same as the length
     of the type `long int' in C, that depends on the hardware and the
     C compiler you use.  The heap size will be increased automatically
     according  to options `-H' and `-a'.

-H SIZE
     Specifies maximum heap size in words.  Automatic heap expansion
     mechanism will never try to expand the heap above the size
     specified by this option.  The default value is infinite.

-a RATIO
     Specifies threashold active cell ratio as a floating point number.
     If the ratio of the space occupied by active (non-garbage) cells
     in the heap space is above this threshold, the heap size will be
     doubled in the next garbage collection, as far as the size doesn't
     exceed the maximum size specified by the `-H' option.  The default
     value is 0.5.

-g
     Specifies that time required for garbage collection is to be
     measured.  As garbage collection will not take long for small heap
     sizes, the measurement overhead can be more than that.  Thus, by
     default, garbage collection timing is disabled.

-s
     Specifies suspension statistics.  After execution of the program,
     suspended predicates and numbers of their suspensions are reported.
     This option is available when the debugging version of the runtime
     library is linked, which is the default setting (*note Compiler
     Options::.).

-t
     Specifies to start execution with tracing (*note Tracing Program
     Execution: Tracing.).  Tracing is only possible when the debugging
     version of the runtime library is linked, which is the default
     setting.  The non-debugging version of the runtime library can be
     specified by compilation time options (*note Compiler Options::.).

   When all the ready goals have been executed, the program will stop.
If there remain any goals awaiting for input data and if the program is
linked with the debugging runtime library, it will try to detect which
goal is problematic and report such a goal.  Otherwise, if the linked
library is a non-debugging version, only the number of such remaining
goals is reported.


File: KLIC.info,  Node: Tracing,  Next: Install,  Prev: Running,  Up: Using KLIC

Tracing Program Execution
=========================

   KLIC provides a debugging tracer with "spying" (break point) feature.

* Menu:

* Preparing for Trace::         Compiling your program to be traced
* Trace Ports::                 Places you stop at stepping execution
* Output of Tracer::            How your program execution process is displayed
* Controlling Trace::           Controlling which are traced and which are not
* Spying::                      Setting spypoints = break points
* Port Control::                Enabling and disabling tracing of each port
* Display Control::             Controlling the verbosity of trace display
* Dumping Goals::               Displaying all ready or suspended goals
* Misc Trace Commands::         Miscellaneous commands
* Perpetual Suspension::        Detecting goals that can never proceed


File: KLIC.info,  Node: Preparing for Trace,  Next: Trace Ports,  Prev: Tracing,  Up: Tracing

Preparation for Traced Execution
--------------------------------

   To use the tracing feature, you have to link your program with the
debugging version of the runtime library.  The debugging version is used
by default, but when you give the `-n' option to the compilation
command `klic', tracing will not be available.

   If you already have compiled and linked the program with the `-n'
option, you don't have to recompile the program from scratch; running
the command `klic' again without the `-n' option will only link the
object with the debugging version of the runtime library, which takes
much shorter time.

   To trace execution of a program, simply run your program with `-t'
option (*note Runtime Switches for Programs Compiled with KLIC: Runtime
Switches.).


File: KLIC.info,  Node: Trace Ports,  Next: Output of Tracer,  Prev: Preparing for Trace,  Up: Tracing

Trace Ports
-----------

   Execution of KL1 programs proceeds as follows.

  1. The initial goal `main:main' is put into a pool of goals to be
     executed.

  2. One goal is taken from the goal pool (`CALL').

  3. The goal is matched against the program clauses.

  4. If any of the clauses matches the goal, the goal is reduced into
     subgoals and they are put back to the goal pool (`REDUCE').

  5. If no clause matches the goal, then the whole computation will be
     aborted (`FAIL').

  6. If values of goal arguments or their substructures are not defined
     and thus it is not possible yet to decide whether some clauses
     will match the goal or not, the goal is put into another goal pool
     awaiting for required values (`SUSPEND').

  7. If there still remain some goals in the goal pool, loop back to the
     step 2.

   Execution of a goal can be traced on four of the above listed points,
numbered 2, 4, 5 and 6.  Such points of interest are called "trace
ports" and referenced as `CALL', `REDUCE', `FAIL' and `SUSPEND' ports,
respectively.

   Those who are accustomed to the four-port trace model of Prolog may
wonder why two other ports of Prolog, `EXIT' and `REDO' are missing.
The `REDO' port does not exist because KL1 programs do not backtrack.
The `EXIT' port is not traced for two reasons.  First, keeping track of
all the goal-subgoal hierarchy is much more costly for a concurrent
language such as KL1 than for sequential languages such as Prolog.
Many different subtrees of the hierarchy may run interleaving each
other, because of the data-flow synchronization feature.  The other
reason is that, KL1 programs are often written as a set of
communicating processes each defined as a goal calling the same
predicate in a tail-recursive fashion.  Such processes (sometimes called
"perpetual processes") will almost never finish and detecting their
termination is not as meaningful as in Prolog.


File: KLIC.info,  Node: Output of Tracer,  Next: Controlling Trace,  Prev: Trace Ports,  Up: Tracing

Format of Trace Display
-----------------------

   Below is our sample program for explanation here.

     :- module main.
     
     main :- nrev([1,2],X), builtin:print(X).
     
     nrev([], R) :- R = [].
     nrev([W|X], R) :- nrev(X, XR), append(XR, [W], R).
     
     append([], Y, Z) :- Z = Y.
     append([W|X], Y, WZ) :- WZ = [W|Z], append(X, Y, Z).

Listed below is output of a full trace of execution of the sample
program.

        1 CALL:main:main?
        1 REDU:main:main :-
        2   0:+nrev([1,2],_4)
        3   1:+builtin:print(_4)?
        2 CALL:main:nrev([1,2],_4)?
        2 REDU:main:nrev([1,2],_4) :-
        4   0:+nrev([2],_D)
        5   1:+append(_D,[1],_4)?
        4 CALL:main:nrev([2],_D)?
        4 REDU:main:nrev([2],_D) :-
        6   0:+nrev([],_18)
        7   1:+append(_18,[2],_D)?
        6 CALL:main:nrev([],_18)?
        6 REDU:main:nrev([],[])?
        7 CALL:main:append([],[2],_D)?
        7 REDU:main:append([],[2],[2])?
        5 CALL:main:append([2],[1],_4)?
        5 REDU:main:append([2],[1],[2|_1F]) :-
        8   0:+append([],[1],_1F)?
        8 CALL:main:append([],[1],_1F)?
        8 REDU:main:append([],[1],[1])?
        3 CALL:builtin:print([2,1])?
     [2,1]
        3 REDU:builtin:print([2,1])?

   As this program does not make any suspensions nor failures, all the
trace outputs here are either at the call or the reduce port (marked as
`REDU').

   The first line of the above is the trace of the call port of the
initial goal `main:main'.

        1 CALL:main:main?

All the traced goals are given a unique identifier (an integer value) to
distinguish them among themselves.  The number `1' in the first column
here is the identifier of the initial goal.

   The initial goal matches the first clause defined in the program and
thus reduced into subgoals as defined in the program clause.  This
reduction is traced as follows.

        1 REDU:main:main :-
        2   0:+nrev([1,2],_4)
        3   1:+builtin:print(_4)?

This shows that the original goal `main:main' with ID 1 has been
reduced into two new goals, `main:nrev([1, 2], _4)' and
`builtin:print(_4)', with IDs 2 and 3 respectively.

   The numbers 0 and 1 following the IDs 2 and 3 of the two new goals
are sequential numbers for the subgoals generated by the reduction.
They are used by some tracer commands to identify which subgoal to
apply the command to.  Unlike unique goal IDs that have global meaning,
these subgoal numbers are meaningful only at this specific port.

   Next comes `:', which means the subgoal is an ordinary subgoal of
the parent goal.  There are other possibilities here.  The character
`*' means that the goal following it is also a subgoal, but is given a
priority different from the parent.  The priority is displayed in a
pseudo-pragma format.  The character `!' means that the goal following
it is not actually a subgoal reduced from the parent goal, but is a
goal awaiting for some variable value which has just waken up as this
reduction gave some concrete value to the variable.  The character `#'
similarly indicates a goal waken up, but with a priority different from
the parent.

   Then comes either `+' or `-'.  `+' means that the subgoal will be
traced if you simply continue the execution, and `-' means it will not.
This can be changed by giving some tracer commands described below.
In the example above, all of the subgoals have `+' as all goals are
traced.

   Then the module name, a colon character, and the predicate name of
the subgoal are displayed.  The module name for predicates defined in
the same module as the predicate of the parent goal is omitted with the
colon for brevity.  In the above example, the subgoal calling `nrev'
(that is `main') does not have its module name displayed, as it is the
same as the parent goal `main:main'.

   Finally comes the argument list in parentheses separated by commas.
The second argument of nrev and the only argument of print is `_4',
which corresponds to a variable corresponding to `X' in the source
program.  As variables are newly allocated for all incarnation of
predicate clauses, and as two or more variables can be unified together,
displaying their original names in the source program is not meaningful.
They are given unique names such as `_4'.

   Actually, this number 4 is related to the physical memory address of
the variable.  It will thus change completely by garbage collections.
However, as garbage collections are not so frequent, the address
information is still quite useful for debugging.

   The trace output stops after displaying all the subgoals and a
question mark.  Here, you can input one of the trace commands described
below.


File: KLIC.info,  Node: Controlling Trace,  Next: Spying,  Prev: Output of Tracer,  Up: Tracing

Trace Controlling Commands
--------------------------

   Tracing can be controlled at each *leashed* port (*note Controlling
Trace Ports: Port Control.).  Tracing can be controlled for the traced
goal as a whole or, at the reduce port, for each of the newly created
subgoal.  The default of whether or not to trace goals of each
predicate can also be set.

* Menu:

* Goal Control::                Controlling trace of the traced goal
* Subgoal Control::             Controlling trace of newly created subgoals
* Predicate Control::           Changing default trace of predicates


File: KLIC.info,  Node: Goal Control,  Next: Subgoal Control,  Prev: Controlling Trace,  Up: Controlling Trace

Controlling Tracing of the Traced Goal
......................................

   The following commands are available for controlling program
execution.

Continue: `c' or simply `<RET>'
     Continues stepping execution.  Subgoal marked as `-' are not
     traced even in stepping mode.

Leap: `l'
     Continues execution without tracing until a spy point is
     encountered.  *Note Spying::, for details.

Skip: `s'
     Continues execution of the traced goal and all subgoals thereof
     without tracing them at all.  Even spy points are neglected.

Abort: `a'
     Aborts whole execution of the program.

   These commands do not take any arguments.


File: KLIC.info,  Node: Subgoal Control,  Next: Predicate Control,  Prev: Goal Control,  Up: Controlling Trace

Controlling Tracing of Newly Created Subgoals
.............................................

   Tracing of each subgoal (displayed as `+' or `-') can be changed by
the following commands.

Trace: `+' SUBGOAL_NUMBER ...
     Switches on the trace of the specified subgoal(s).  Multiple
     subgoal numbers separated by spaces can be specified.  If no
     subgoal numbers are given, all the subgoals become traced.

No Trace: `-' SUBGOAL_NUMBER ...
     Switches off the trace of the specified subgoal(s).  Multiple
     subgoal numbers separated by spaces can be specified.  If no
     subgoal numbers are given, all the subgoals become untraced.

Toggle Trace: SUBGOAL_NUMBER ...
     Toggles the trace switch of the specified subgoal(s).  Multiple
     subgoal numbers separated by spaces can be specified.


File: KLIC.info,  Node: Predicate Control,  Prev: Subgoal Control,  Up: Controlling Trace

Changing Default Trace of Predicates
....................................

   By default, all the subgoals of a goal will have trace switch on
(`+') initially at the reduce port.  This default setting can be
changed predicate by predicate using commands described in this section,
so that predicates you are not interested in will not be traced by
default.

   In what follows, command arguments <predicate> has one of the
following format.

MODULE:PREDICATE/ARITY
     Specifies explicitly and exactly one predicate.  For example,
     `main:nrev/2'.

MODULE:PREDICATE
     Specifies all the predicates within a module with different
     arities.

MODULE:
     Specifies all the predicates defined in a module.  Note that a
     colon is required after the module name to distinguish it from a
     predicate name.

PREDICATE/ARITY
     Specifies the predicate defined in the same module as the
     predicate of the currently traced goal with the given name and
     arity.

PREDICATE
     Specifies all the predicates defined in the same module as the
     predicate of the currently traced goal with the given name.

   Listed below are commands to change the default for given predicates.

No Trace Default: `n' PREDICATE ...
     Sets the default trace for the predicate(s) to be off.  If no
     predicates are given as argument, the predicate of the traced goal
     is considered to be specified.

Trace Default: `t' PREDICATE ...
     Sets the default trace for the predicate(s) to be on.  If no
     predicates are given as argument, the predicate of the traced goal
     is considered to be specified.


File: KLIC.info,  Node: Spying,  Next: Port Control,  Prev: Controlling Trace,  Up: Tracing

Spying
------

   It is often the case that only some specific predicates are of
interest for debugging.  In such cases, ports for such predicates can be
specified as the "spy points".  You can let program run without tracing
until some spy point is encountered, using the leap (`l') command.
*Note Controlling Tracing of the Traced Goal: Goal Control, for details.

   Commands described in this section set or reset such spy points.

Spy: `S' PREDICATE ...
     Makes the predicate(s) spied.  If no predicates are given as
     argument, the predicate of the traced goal is spied.

No Spy: `N' PREDICATE ...
     Resets the spy point on the predicate(s).  If no predicates are
     given as argument, the spy point on the predicate of the traced
     goal is reset.


File: KLIC.info,  Node: Port Control,  Next: Display Control,  Prev: Spying,  Up: Tracing

Controlling Trace Ports
-----------------------

   The four trace ports can be selectively enabled and disabled.
Disabled ports will not be traced at all.

   In addition, for each port, you can specify whether to stop and wait
for command input.  Ports where execution stops and waits for commands
are said to be "leashed".  On ports enabled but not leashed, the trace
output will be displayed but execution continues as if the continue
command (carriage return) was input immediately.  For spied predicates,
even unleashed ports will be leashed.

   Commands described in this section is for controlling such attributes
of ports.  They take port names as their arguments, specified as one of
the following ways.

Call:
     `c', `call'

Reduce:
     `r', `redu', `reduce'

Suspend:
     `s', `susp', `suspend'

Fail:
     `f', `fail'

All ports:
     `a', `all'

   Listed below are the commands for controlling ports.

Enable Port: `E' PORT ...
     Enables the specified port(s).

Disable Port: `D' PORT ...
     Disables the specified port(s).

Leash Port: `L' PORT ...
     Leashes the specified port(s).

Unleash Port: `U' PORT ...
     Unleashes the specified port(s).


File: KLIC.info,  Node: Display Control,  Next: Dumping Goals,  Prev: Port Control,  Up: Tracing

Display Control Commands
------------------------

   Sometimes, full information of the traced goals is not desirable, as
too much information is only harmful for understanding the program
behavior.  Thus, commands in this section are provided for controlling
the amount of information displayed on trace ports.

   The amount of display is controlled by a combination of the following
options.

   * By limiting display depth: Arguments of structures below depth
     limit are displayed in the following abbreviated way.

          f(a,b,c,d,e)    ==>    f(..)
          [a,b,c,d,e]     ==>    [..]

   * By limiting display length: Argument lists of structures or
     character strings longer than the length limit are displayed in
     the following abbreviated way.

          f(a,b,c,d,e)    ==>    f(a,b,c,..)
          [a,b,c,d,e]     ==>    [a,b,c,..]
          "abcde"         ==>    "abc.."

   * By specifying a subterm to be displayed: Only a part of the traced
     goal can be specified for display.

   The following commands can be used to control the options.

Set Print Depth: `pd' DEPTH
     Sets depth limit of displaying data structures to DEPTH.  With no
     argument, prints the current depth limit value.

Set Print Length: `pl' LENGTH
     Sets length limit of displaying data structures to LENGTH.  With
     no argument, prints the current length limit value.

Toggle Verbose Print: `pv'
     Toggles verbose printing mode switch.  In verbose printing mode,
     variables with goals awaiting for its value are displayed with the
     information of the goal.

Set Subterm: `^' N

Reset Subterm:`^'
     Sets the N-th subterm of the traced goal to be inspected.  With 0
     specified as N, the subterm goes up one level.  With N omitted,
     subterm inspection is reset.  For list structures, 1 means car and
     2 means cdr.

     With subterm specification, only the subterm of the traced goal is
     displayed after the information of which subterm is inspected.  An
     example follows.

            10 CALL: foo:bar(f(a,g(..),[..]))? ^1
            10 CALL: ^1 f(a,g(b,c),[d,e])? ^2
            10 CALL: ^1^2 g(b,c)? ^0
            10 CALL: ^1 f(a,g(b,c),[d,e])? ^3
            10 CALL: ^1^3 [d,e]? ^2
            10 CALL: ^1^3^2 [e]? ^
            10 CALL: foo:bar(f(a,g(..),[..]))?

     At reduce ports, subgoals created by the reduction are not
     displayed when subterm display is specified; only the specified
     subterm of the parent goal is displayed.  With the current
     version, vector elements cannot be specified as subterms.

   The initial setting of depth and length limits are 3 and 7,
respectively.  Verbose print mode is initially switched off.


File: KLIC.info,  Node: Dumping Goals,  Next: Misc Trace Commands,  Prev: Display Control,  Up: Tracing

Dumping Goals
-------------

   It is desirable sometimes to dump all the goals in the system as a
last resort.  The following commands do it.

Dump Ready Queue: `Q'
     Displays all the goals in the ready queue (goal pool) with their
     priorities.

Dump Suspended (Waiting) Goals: `W'
     Displays all the suspended goals in the system with their
     priorities.


File: KLIC.info,  Node: Misc Trace Commands,  Next: Perpetual Suspension,  Prev: Dumping Goals,  Up: Tracing

Miscellaneous Commands
----------------------

Status Query: `='
     Displays tracer status information, such as follows.

             port: Call Susp Redu Fail
          enabled:  +    +    +    +
          leashed:  +    +    +    +
          print terse; depth = 3; length = 7

List Modules: `lm'
     Lists all the modules of the currently executed program.

List Predicates: `lp'
     Lists all the predicates and their default trace status of the
     currently executed program.

Queue: `Q'
     Lists the contents of the ready queue (goal pool).

Help: `?' or `h'
     Lists all the commands and their terse description available at the
     current port.


File: KLIC.info,  Node: Perpetual Suspension,  Prev: Misc Trace Commands,  Up: Tracing

Detecting Perpetual Suspensions
-------------------------------

   When some goals are awaiting for instantiation of a variable that
will never be instantiated by any other goals, such goals will never
proceed.  This situation is called "perpetual suspension".  Perpetual
suspension is detected by the garbage collector of KLIC.  Thus, during
program execution, garbage collections may find perpetual suspensions.

   The system keeps track of the number of suspended goals.  When there
exist no goals ready for running and there are suspended goals
remaining, the system will try garbage collection to detect perpetual
suspensions.

   Perpetual suspensions are reported as follows.

     !!! Perpetual Suspention Detected !!!
        3 PSUS: MODULE:PREDICATE(ARGS...)?

The same command set as at a fail port is available here.


File: KLIC.info,  Node: Install,  Next: Distributed KLIC,  Prev: Tracing,  Up: Using KLIC

Installation
============

   Installation of KLIC should be fairly easy.

   Host-dependent and preference-based customizations are made by
running a configuration script provided with the distribution.  Then
`make all' should compile the whole system.  You can make sure that the
system has been compiled without problems by running `make tests'.  Then
you can install the system by `make install'.

* Menu:

* Configuration::               Configuration script
* Make All::                    Compiling the system
* Make Tests::                  Testing the compilation
* Make Install::                Actually installing the system
* Make Distclean::              Cleaning up after installation
* Troubles::                    What to do when you have some trouble


File: KLIC.info,  Node: Configuration,  Next: Make All,  Prev: Install,  Up: Install

Configuration
-------------

   First thing to do in installation of KLIC is to configure the KLIC
system depending on the host computer system and your preference.

   Go to the root directory of the distribution (referred to as ROOT in
what follows).  Then, run the configuration script there by a command
`./Configure'.  The script will search for available software tools in
your system and ask your preferences.

   The default shell programs on some Unix systems based on BSD 4.2 do
not understand some of the constructs used in this configuration
script.  In such a case, obtain a modern shell (such as GNU `bash') and
let it execute the script, as follows.

     % bash Configure

   If you have built the system before and rebuilding it in the same
directory, it will ask whether the same values you specified the last
time should be used as default values.

   The next question it asks (or the first, if it is the first time to
build the system) is whether to configure also for parallel
implementations.  If you want to install only the sequential system,
please answer `no' to the question.  See relevant sections (*note
Distributed KLIC::. and *note Shared-Memory KLIC::.), for further
details of configuraion of parallel versions of the system.

   The configuration script will make three files.

     `ROOT/Makefile'
     `ROOT/include/klic/config.h'
     `ROOT/config.sh'

   The last one records the specified options for reconfiguration.

   The configuration script asks about the parallelism used in the
installation procedure.  You can specify non-zero parallelism here to
speed up the procedure if you are installing your system on a lightly
loaded multiprocessor system.  Do *not* use parallel execution features
of the `make' program.


File: KLIC.info,  Node: Make All,  Next: Make Tests,  Prev: Configuration,  Up: Install

Compiling the KLIC system
-------------------------

   After configuring the system, typing in `make all' should compile
the whole KLIC system, including the KL1 to C compiler and the runtime
libraries.


File: KLIC.info,  Node: Make Tests,  Next: Make Install,  Prev: Make All,  Up: Install

Testing the Compilation
-----------------------

   After system compilation is finished, you are recommended to test
whether the compilation went without problems.  To do that, type in
`make tests' in the root directory of the distribution (not in its
subdirectory `test').  This will compile and run several KL1 test
programs and compares the output with the expected output.


File: KLIC.info,  Node: Make Install,  Next: Make Distclean,  Prev: Make Tests,  Up: Install

Installing the Objects
----------------------

   After compilation, typing in `make install' will install the
compiler, header files and runtime libraries to directories specified on
configuration (*note Configuration::.).


File: KLIC.info,  Node: Make Distclean,  Next: Troubles,  Prev: Make Install,  Up: Install

Cleaning Up the Installation Directory
--------------------------------------

   After installation has been done, typing in `make distclean' will
delete all the files *not* included in the distribution.

   Normal users should *not* try `make realclean', which will delete C
program source files generated from KL1.  A working KL1 to C compiler
will be needed to regenerate the C program source files.


File: KLIC.info,  Node: Troubles,  Prev: Make Distclean,  Up: Install

When Something Goes Wrong
-------------------------

   When the installation procedure went wrong because of
misconfiguration, you had better start all over again from the
configuration step (*note Configuration::.).  The configuraion script
will ask you whether to clean up the system for reconfiguration.
Please answer affirmative then.

   Dependency rules written in Makefiles are inappropriate for using
parallel make features provided by some versions of `make'.  The
compilation procedure of KLIC relies on the fact that contents of atom
and functor databases are monotonically increasing.  Dependencies on
them are intentionally omitted to avoid redundant recompilation.  Use
the parallel compilation feature of the compiler driver `klic' that
understands the mechanism instead.  Parallelism used during installation
procedure is specified at the configuration step (*note
Configuration::.).

   If you think the problem is due to the distributed code, please
report your problem to the following address.

     `klic-bugs@icot.or.jp'

   Including information on your host system (hardware and operating
system), your configuration (contents of the file `config.sh'), and log
of your installation would be of great help in analysing your problems.


File: KLIC.info,  Node: Distributed KLIC,  Next: Shared-Memory KLIC,  Prev: Install,  Up: Using KLIC

Distributed Memory Parallel Implementation of KLIC
==================================================

   A version of the distributed parallel implementation of KLIC is
included in this KLIC distribution.  The distributed implementation is
based on PVM 3.3.  Implementations on other portable parallel processing
libraries, such as MPI, and those on system-specific interprocess
communication libraries have also been done, but not yet integrated into
this distribution.

   Although it is based on PVM, the current version does not support
heterogeneous configuration: It does not work with systems consisting of
processors with multiple architectures or running different operating
systems.  Currently, we don't have any plans to support heterogenous
systems.

* Menu:

* Installation of Distributed KLIC::
* Compiling Programs for Distributed KLIC::
* Running Programs of Distributed KLIC::


File: KLIC.info,  Node: Installation of Distributed KLIC,  Next: Compiling Programs for Distributed KLIC,  Prev: Distributed KLIC,  Up: Distributed KLIC

Installation of Distributed KLIC
--------------------------------

   To install the PVM version of the distributed KLIC, you have to first
answer affirmatively to the question from the configuration script
asking whether to configure for parallel implementations and then
affirmatively again to to the question asking whether to configure for
the distributed KLIC.  Then it will ask for several questions on which
directories the PVM system is installed and which PVM library is to be
used, if several of them are available.

   The following will be asked.
   * Root directory of the pvm system

   * The keyword for architecture of the system (`SUN4MP', for example)

   * The name of the PVM library (`pvm3', for example)

   The current version has problems with PVM implementations which does
not use daemon processes.  For example, on shared-memory multiprocessor
Sparc systems running Solaris 2, the library `pvm3' does not work.  Use
`pvm3s' that use sockets instead of shared-memory for interprocess
communication.

   The rest of the installation procedure is the same as the procedure
without the distributed KLIC system.

   The distributed KLIC system runs exactly the same as its sequential
version when the option for distributed processing (`-dp') is not
specified on compilation.


File: KLIC.info,  Node: Compiling Programs for Distributed KLIC,  Next: Running Programs of Distributed KLIC,  Prev: Installation of Distributed KLIC,  Up: Distributed KLIC

Compiling Programs for Distributed KLIC
---------------------------------------

   Compilation procedure is almost the same for the sequential version
except that the following option is available.

-dp
     Specifies compilation for the distributed KLIC system.  Without
     this option, the compiled object code will run only sequentially.


File: KLIC.info,  Node: Running Programs of Distributed KLIC,  Prev: Compiling Programs for Distributed KLIC,  Up: Distributed KLIC

Running Programs of Distributed KLIC
------------------------------------

* Menu:

* Setting Up PVM::
* Runtime Options for Distributed KLIC::
* Known Bugs of Distributed KLIC::


File: KLIC.info,  Node: Setting Up PVM,  Next: Runtime Options for Distributed KLIC,  Prev: Running Programs of Distributed KLIC,  Up: Running Programs of Distributed KLIC

Setting Up PVM
..............

   Before executing programs compiled for distributed execution, the PVM
system has to be running on your system.  The following set up will be
required.

   * The following environment variables should be set properly.

    PVM_ROOT
          The root directory of the PVM system installed on your system.

    PVM_ARCH
          The keyword specifying the architecture of the system.

     They should be the same as what you specified on installation of
     the KLIC system.

   * The PVM demon should be running.  The demon can be started by
     invoking the PVM console, which is in
     `$PVM_ROOT/lib/$PVM_ARCH/pvm'.  It would be convenient to keep a
     window for this console.

   For other setting parameters and details of operation of PVM console,
please consult its own manual.


File: KLIC.info,  Node: Runtime Options for Distributed KLIC,  Next: Known Bugs of Distributed KLIC,  Prev: Setting Up PVM,  Up: Running Programs of Distributed KLIC

Runtime Options for Distributed KLIC
....................................

   The following options are available when running programs in the
distributed KLIC system, in addition to those available for the
sequential version.

-p N
     Specifies the number of workers (Unix processes) for running the
     program.

-e
     Specifies eager transfer mode.  Normally, KLIC transfers data
     structures between processors on demands.  Thus, nested data
     structures are transferred one level at a time.  In the eager
     transfer mode, nested structures are sent at a time as far as they
     are already defined.  This makes the execution more efficient for
     some programs, but may degrade the performance for others.

-E LEVEL
     Specifies how many level of nested data structures are to be
     transferred at each communication.

-I MICROSEC
     Specifies interval between interprocessor communication polling.
     Whether such polling is needed and which value to be appropriate
     depend on host systems and implementations of the physical
     communication layer.  In most cases, its default value of 10000 is
     appropriate.

-n
     Specifies printing out of some runtime statistics on interprocess
     communication.

-notimer
     Specifies not to use timer-driven communication polling.  Whether
     such polling is mandatory depends on implementation of the physical
     communication layer.

-relsp
     Specifies that relative path should be used for the executable
     file on spawning worker tasks.

-S
     Specifies not to notify receiver processes of communication
     packets by sending singals.  On some implementations, this may
     speed up program execution by eliminating signal sending overheads.


File: KLIC.info,  Node: Known Bugs of Distributed KLIC,  Prev: Runtime Options for Distributed KLIC,  Up: Running Programs of Distributed KLIC

Known Bugs of Distributed KLIC
..............................

   * Atoms and functors newly registered during program execution may
     not be handled properly.

   * Specification of spying (*note Spying::.) is effective only within
     the computation node where it is specified.  


File: KLIC.info,  Node: Shared-Memory KLIC,  Prev: Distributed KLIC,  Up: Using KLIC

Shared-Memory Implementation of KLIC
====================================

   A version of the shared-memory parallel implementation of KLIC is
included in this KLIC distribution.  The implementation contains
hardware, operating system, and C compiler dependent parts.  The version
included is for Sparc-based systems running SunOS 5.3 and Alpha-based
systems running DEC OSF/1.  Gnu CC should be used for their compilation.


* Menu:

* Installation of Shared-Memory KLIC::
* Compiling Programs for Shared-Memory KLIC::
* Running Programs of Shared-Memory KLIC::


File: KLIC.info,  Node: Installation of Shared-Memory KLIC,  Next: Compiling Programs for Shared-Memory KLIC,  Prev: Shared-Memory KLIC,  Up: Shared-Memory KLIC

Installation of Shared-Memory KLIC
----------------------------------

   To install the shared-memory parallel version of KLIC, you have to
first answer affirmatively to the question from the configuration script
asking whether to configure shared-memory parallel implementation.

   The rest of the installation procedure is the same as the procedure
without the shared-memory KLIC system.

   The shared-memory KLIC system runs exactly the same as its sequential
version when the option for shared-memory parallel processing (`-shm')
is not specified on compilation.  


File: KLIC.info,  Node: Compiling Programs for Shared-Memory KLIC,  Next: Running Programs of Shared-Memory KLIC,  Prev: Installation of Shared-Memory KLIC,  Up: Shared-Memory KLIC

Compiling Programs for Shared-Memory KLIC
-----------------------------------------

   Compilation procedure is almost the same for the sequential version
except that the following option is available.

-shm
     Specifies compilation for the shared-memory KLIC system.  Without
     this option, the compiled object code will run only sequentially.



File: KLIC.info,  Node: Running Programs of Shared-Memory KLIC,  Prev: Compiling Programs for Shared-Memory KLIC,  Up: Shared-Memory KLIC

Running Programs of Shared-Memory KLIC
--------------------------------------

* Menu:

* Runtime Options for Shared-Memory KLIC::
* Known Bugs of Shared-Memory KLIC::


File: KLIC.info,  Node: Runtime Options for Shared-Memory KLIC,  Next: Known Bugs of Shared-Memory KLIC,  Prev: Running Programs of Shared-Memory KLIC,  Up: Running Programs of Shared-Memory KLIC

Runtime Options for Shared-MemoryKLIC
.....................................

   The following options are available when running programs in the
shared-memory KLIC system, in addition to those available for the
sequential version.

-p N
     Specifies the number of workers (Unix processes) for running the
     program.

-D
     Reports process numbers of children workers.  Maybe useful for
     lower level debugging.

-S SIZE
     Specifies the size of the shared heap.  In the current
     implementation, shared heap is allocated at the initiation and
     will never be expanded.


File: KLIC.info,  Node: Known Bugs of Shared-Memory KLIC,  Prev: Runtime Options for Shared-Memory KLIC,  Up: Running Programs of Shared-Memory KLIC

Known Bugs of Shared-Memory KLIC
................................

   * The tracer may not work correctly.  


File: KLIC.info,  Node: Type Index,  Next: Predicate Index,  Prev: Using KLIC,  Up: Top

Data Type Index
***************

* Menu:

* atom:                                  Symbolic Atoms.
* floating point number:                 Floating Points.
* functor:                               Functors.
* integer:                               Integers.
* list:                                  Lists.
* merger:                                Merging.
* module:                                Module Type.
* predicate:                             Predicate Type.
* string:                                Strings.
* vector:                                Vectors.


File: KLIC.info,  Node: Predicate Index,  Next: Module Index,  Prev: Type Index,  Up: Top

Predicate, Method and Message Index
***********************************

* Menu:

* $:= on builtin:                        Floating Arith.
* $< on builtin:                         Floating Comp.
* $=:= on builtin:                       Floating Comp.
* $=< on builtin:                        Floating Comp.
* $=\= on builtin:                       Floating Comp.
* $> on builtin:                         Floating Comp.
* $>= on builtin:                        Floating Comp.
* := on builtin:                         Integer Arith.
* < on builtin:                          Integer Comp.
* = on builtin:                          Unification.
* =.. on functor_table:                  Functor Operation.
* =:= on builtin:                        Integer Comp.
* =< on builtin:                         Integer Comp.
* =\= on builtin:                        Integer Comp.
* > on builtin:                          Integer Comp.
* >= on builtin:                         Integer Comp.
* @< on builtin:                         Comparison and Hashing.
* @=< on builtin:                        Comparison and Hashing.
* @> on builtin:                         Comparison and Hashing.
* @>= on builtin:                        Comparison and Hashing.
* \= on builtin:                         Comparison and Hashing.
* accept on bound socket:                Sockets.
* access on unix stream:                 Files & Dirs.
* acos on float:                         Floating Arith.
* add on float:                          Floating Arith.
* add on timer:                          Timer.
* addop on Prolog-like I/O:              Common Msgs (Prolog style).
* append_open on klicio stream:          Opening Prolog I/O.
* append_open on unix stream:            I/O Opening.
* apply on predicate:                    Predicate Type.
* arg on builtin:                        Functor Operation.
* argc on unix:                          Predicate Interface.
* argv on unix:                          Predicate Interface.
* arity on predicate:                    Predicate Type.
* asin on float:                         Floating Arith.
* atan on float:                         Floating Arith.
* atom on builtin:                       Symbolic Atom Operation.
* atom_number on atom_table:             Symbolic Atom Operation.
* atomic on builtin:                     Atomic Data.
* bind on unix stream:                   Sockets.
* call on predicate:                     Predicate Type.
* cd on unix stream:                     Files & Dirs.
* ceil on float:                         Floating Arith.
* chmod on unix stream:                  Files & Dirs.
* compare on builtin:                    Comparison and Hashing.
* compare on timer:                      Timer.
* connect on unix stream:                Sockets.
* cos on float:                          Floating Arith.
* cosn on float:                         Floating Arith.
* current_node on builtin:               Execution Status.
* current_priority on builtin:           Execution Status.
* divide on float:                       Floating Arith.
* element on string <1>:                 Predicates on Strings.
* element on string:                     Predicates and Methods.
* element on vector:                     Predicates on Vectors.
* element_size on string:                Predicates on Strings.
* equal on float:                        Floating Comp.
* exit on unix:                          Predicate Interface.
* exp on float:                          Floating Arith.
* fclose on C-like I/O:                  Common Msgs (C style).
* fclose on Prolog-like I/O:             Common Msgs (Prolog style).
* feof on C-like I/O:                    Common Msgs (C style).
* feof on Prolog-like I/O:               Common Msgs (Prolog style).
* fflush on C-like I/O:                  Output Msgs (C style).
* fflush on Prolog-like I/O:             Output Msgs (Prolog style).
* float on builtin:                      Floating Points.
* float on float:                        Floating Points.
* floor on float:                        Floating Arith.
* fork on unix stream:                   Misc Unix Messages.
* fork_with_pipes on unix stream:        Misc Unix Messages.
* fread on C-like I/O:                   Input Msgs (C style).
* fread on Prolog-like I/O:              Input Msgs (Prolog style).
* fseek on C-like I/O:                   Common Msgs (C style).
* fseek on Prolog-like I/O:              Common Msgs (Prolog style).
* ftell on C-like I/O:                   Common Msgs (C style).
* ftell on Prolog-like I/O:              Common Msgs (Prolog style).
* functor on builtin:                    Functor Operation.
* fwrite on C-like I/O:                  Output Msgs (C style).
* fwrite on Prolog-like I/O:             Output Msgs (Prolog style).
* gc on system_control:                  System Control.
* get_atom_name on atom_table:           Symbolic Atom Operation.
* get_atom_string on atom_table:         Symbolic Atom Operation.
* get_time_of_day on timer:              Timer.
* getc on C-like I/O:                    Input Msgs (C style).
* getc on Prolog-like I/O:               Input Msgs (Prolog style).
* getenv on unix stream:                 Misc Unix Messages.
* gett on Prolog-like I/O:               Input Msgs (Prolog style).
* getwt on Prolog-like I/O:              Input Msgs (Prolog style).
* greater_than on float:                 Floating Comp.
* hash on builtin:                       Comparison and Hashing.
* instantiate_after on timer:            Timer.
* instantiate_at on timer:               Timer.
* instantiate_every on timer:            Timer.
* integer on builtin:                    Integers.
* intern on atom_table:                  Symbolic Atom Operation.
* join on string:                        Predicates on Strings.
* join on vector:                        Predicates on Vectors.
* kill on unix stream:                   Misc Unix Messages.
* klicio on klicio:                      Opening Prolog I/O.
* less_than on float:                    Floating Comp.
* less_than on string:                   Predicates on Strings.
* linecount on C-like I/O:               Input Msgs (C style).
* linecount on Prolog-like I/O:          Input Msgs (Prolog style).
* list on builtin:                       Lists.
* log on float:                          Floating Arith.
* make_atom on atom_table:               Symbolic Atom Operation.
* mktemp on unix stream:                 Files & Dirs.
* module on module:                      Module Type.
* module on predicate:                   Predicate Type.
* multiply on float:                     Floating Arith.
* name on module:                        Module Type.
* name on predicate:                     Predicate Type.
* new on float:                          Creating Floats.
* new on merge:                          Merging.
* new on module:                         Module Type.
* new on predicate:                      Predicate Type.
* new on random_numbers:                 Random Numbers.
* new on string:                         Creating Strings.
* new on vector:                         Creating Vectors.
* new_functor on builtin:                Functor Operation.
* new_string on builtin:                 Creating Strings.
* new_vector on builtin:                 Creating Vectors.
* nl on Prolog-like I/O:                 Output Msgs (Prolog style).
* not_equal on float:                    Floating Comp.
* not_greater_than on float:             Floating Comp.
* not_less_than on float:                Floating Comp.
* not_less_than on string:               Predicates on Strings.
* NUMBER on C-like I/O:                  Output Msgs (C style).
* NUMBER on Prolog-like I/O:             Output Msgs (Prolog style).
* postmortem on system_control:          System Control.
* pow on float:                          Floating Arith.
* predicate on predicate:                Predicate Type.
* putc on C-like I/O <1>:                Output Msgs (C style).
* putc on C-like I/O:                    Messages.
* putc on Prolog-like I/O:               Output Msgs (Prolog style).
* putenv on unix stream:                 Misc Unix Messages.
* putt on Prolog-like I/O:               Output Msgs (Prolog style).
* puttq on Prolog-like I/O:              Output Msgs (Prolog style).
* putwt on Prolog-like I/O:              Output Msgs (Prolog style).
* putwtq on Prolog-like I/O:             Output Msgs (Prolog style).
* read_open on klicio stream:            Opening Prolog I/O.
* read_open on unix stream:              I/O Opening.
* rmop on Prolog-like I/O:               Common Msgs (Prolog style).
* search_character on builtin:           Predicates on Strings.
* search_character on string:            Predicates on Strings.
* set_element on string:                 Predicates on Strings.
* set_element on vector:                 Predicates on Vectors.
* set_string_element on builtin:         Predicates on Strings.
* set_vector_element on builtin:         Predicates on Vectors.
* setarg on builtin:                     Functor Operation.
* signal_stream on unix stream:          Signals.
* sin on float:                          Floating Arith.
* sinh on float:                         Floating Arith.
* size on string:                        Predicates on Strings.
* size on vector:                        Predicates on Vectors.
* split on string:                       Predicates on Strings.
* split on vector:                       Predicates on Vectors.
* sqrt on float:                         Floating Arith.
* stderr on klicio stream:               Opening Prolog I/O.
* stderr on unix stream:                 I/O Opening.
* stdin on klicio stream:                Opening Prolog I/O.
* stdin on unix stream:                  I/O Opening.
* stdout on klicio stream:               Opening Prolog I/O.
* stdout on unix stream:                 I/O Opening.
* string on builtin:                     Predicates on Strings.
* string on string:                      Predicates on Strings.
* string_element on builtin <1>:         Predicates on Strings.
* string_element on builtin:             Predicates and Methods.
* string_less_than on builtin:           Predicates on Strings.
* string_not_less_than on builtin:       Predicates on Strings.
* sub on timer:                          Timer.
* subtract on float:                     Floating Arith.
* sync on C-like I/O:                    Common Msgs (C style).
* sync on Prolog-like I/O:               Common Msgs (Prolog style).
* system on unix stream:                 Misc Unix Messages.
* tan on float:                          Floating Arith.
* tanh on float:                         Floating Arith.
* times on unix:                         Predicate Interface.
* umask on unix stream:                  Files & Dirs.
* unbound on builtin:                    Debugging.
* ungetc on C-like I/O:                  Input Msgs (C style).
* ungetc on Prolog-like I/O:             Input Msgs (Prolog style).
* unix on unix:                          Unix Stream.
* unlink on unix stream:                 Files & Dirs.
* unwrap on variable:                    Wrapped Terms.
* update_open on klicio stream:          Opening Prolog I/O.
* update_open on unix stream:            I/O Opening.
* vector on builtin:                     Predicates on Vectors.
* vector on vector:                      Predicates on Vectors.
* vector_element on builtin:             Predicates on Vectors.
* wait on builtin:                       Synchronization.
* wrap on variable:                      Wrapped Terms.
* write_open on klicio stream:           Opening Prolog I/O.
* write_open on unix stream:             I/O Opening.


File: KLIC.info,  Node: Module Index,  Next: Concepts,  Prev: Predicate Index,  Up: Top

Module Index
************

* Menu:

* atom_table:                            Symbolic Atom Operation.
* functor_table:                         Functor Operation.
* generic (pseudo module):               Generic Objects.
* klicio:                                Opening Prolog I/O.
* system_control:                        System Control.
* unix:                                  Unix.


File: KLIC.info,  Node: Concepts,  Prev: Module Index,  Up: Top

Concept Index
*************

* Menu:

* aborting:                              Predicate Interface.
* accumulator:                           Usage of Paired Arguments.
* alternatively:                         Alternatively.
* argument mode:                         Argument Modes.
* argument pair:                         Argument Pair Notation.
* argument pair name:                    Paired Arguments.
* arithmetics on floating points:        Floating Arith.
* arithmetics on integers:               Integer Arith.
* array:                                 Vectors.
* asynchronous I/O:                      Sockets.
* atom:                                  Symbolic Atoms.
* atomic data:                           Atomic Data.
* body:                                  Basics.
* body method:                           Body Methods.
* break point:                           Spying.
* bug report:                            Reporting Bugs.
* C <1>:                                 C-like I/O.
* C:                                     Inline C Code.
* car:                                   Lists.
* cdr:                                   Lists.
* ceiling:                               Floating Arith.
* character code:                        Notation of Integers.
* character input:                       Input Msgs (C style).
* character output:                      Output Msgs (C style).
* character string:                      Strings.
* chdir:                                 Files & Dirs.
* class:                                 Predicates and Methods.
* clause <1>:                            Predicates.
* clause:                                Basics.
* clause preference:                     Alternatively.
* closing a file:                        Common Msgs (C style).
* command line arguments:                Predicate Interface.
* comparison:                            Comparison and Hashing.
* comparison of strings:                 Predicates on Strings.
* comparison on floating points:         Floating Comp.
* comparison on integers:                Integer Comp.
* compilation:                           Compiling.
* concurrent logic programming language: Language.
* configuration <1>:                     Installation of Shared-Memory KLIC.
* configuration <2>:                     Installation of Distributed KLIC.
* configuration:                         Configuration.
* cons cell:                             Lists.
* converting integer to floating point:  Creating Floats.
* copyright:                             Copying.
* cosine:                                Floating Arith.
* creating generic objects:              Creating Objects.
* creation of floating point numbers:    Creating Floats.
* creation of vectors:                   Creating Vectors.
* debugging:                             Tracing.
* decrement:                             Macros for Paired Arguments.
* depth limit of trace display:          Display Control.
* dictionary order:                      Predicates on Strings.
* difference list:                       Usage of Paired Arguments.
* directory:                             Files & Dirs.
* distributed KLIC:                      Distributed KLIC.
* distribution:                          Copying.
* dump:                                  Dumping Goals.
* end of file:                           Common Msgs (C style).
* environment varialble:                 Misc Unix Messages.
* execution:                             Basics.
* exit code:                             Predicate Interface.
* expanded pair:                         Paired Arguments.
* exponential:                           Floating Arith.
* file:                                  Files & Dirs.
* floating point arithmetics:            Floating Arith.
* floating point comparison:             Floating Comp.
* floating point conversion from an integer: Creating Floats.
* floating point notation:               Notation of Floats.
* floating point number:                 Floating Points.
* flooring:                              Floating Arith.
* flushing changes:                      Common Msgs (C style).
* forking processes:                     Misc Unix Messages.
* functor:                               Functors.
* functor notation:                      Notation of Functors.
* garbage collection:                    System Control.
* generic method <1>:                    Generic Objects.
* generic method:                        Predicates and Methods.
* generic object:                        Generic Objects.
* GHC:                                   Language.
* goal:                                  Goals.
* goal pool:                             Dumping Goals.
* guard:                                 Basics.
* guard method:                          Guard Methods.
* hashing:                               Comparison and Hashing.
* header file:                           Top Insertion.
* higher order:                          Executable Code.
* hyperbolic function:                   Floating Arith.
* I/O:                                   C-like I/O.
* ICOT Free Software:                    Copying.
* increment:                             Macros for Paired Arguments.
* initial goal:                          Initial Goal.
* inline:                                Inline C Code.
* input <1>:                             Input Msgs (C style).
* input:                                 Input and Output.
* input argument:                        Argument Modes.
* installation:                          Install.
* integer:                               Integers.
* integer arithmetics:                   Integer Arith.
* integer comparison:                    Integer Comp.
* integer to floating point conversion:  Creating Floats.
* interprocess communication:            Messages.
* interrupt:                             Signals.
* interval timer:                        Timer.
* KL1:                                   Language.
* length limit of trace display:         Display Control.
* linkage:                               Compiling.
* Linux:                                 Sockets.
* list:                                  Lists.
* logarithm:                             Floating Arith.
* mailing list:                          Reporting Bugs.
* main:                                  Initial Goal.
* merging:                               Merging.
* message:                               Messages.
* message sending:                       Macros for Paired Arguments.
* message stream:                        Merging.
* method <1>:                            Generic Objects.
* method:                                Predicates and Methods.
* module:                                Modules.
* negation:                              Predicates.
* new release:                           Reporting Bugs.
* nil:                                   Lists.
* notation of lists:                     Notation of Lists.
* object creation:                       Creating Objects.
* open <1>:                              Opening Prolog I/O.
* open:                                  I/O Opening.
* operating system:                      Unix.
* operations on functors:                Functor Operation.
* operator precedence grammar:           Prolog I/O.
* otherwise:                             Predicates.
* output:                                Input and Output.
* output argument:                       Argument Modes.
* paired argument <1>:                   Paired Arguments.
* paired argument:                       Argument Pair Notation.
* parallel processing <1>:               Shared-Memory KLIC.
* parallel processing:                   Distributed KLIC.
* port <1>:                              Port Control.
* port:                                  Trace Ports.
* postmortem processing:                 System Control.
* predicate <1>:                         Predicates.
* predicate:                             Predicates and Methods.
* preference of clauses:                 Alternatively.
* principal functor <1>:                 Functors.
* principal functor:                     Comparison and Hashing.
* priority <1>:                          Execution Status.
* priority:                              Priority.
* process forking:                       Misc Unix Messages.
* program:                               Executable Code.
* PVM <1>:                               Distributed KLIC.
* PVM:                                   Configuration.
* random number:                         Random Numbers.
* reading in:                            Input Msgs (C style).
* ready queue:                           Dumping Goals.
* real number:                           Floating Points.
* record structure:                      Functors.
* rounding:                              Floating Arith.
* running:                               Running.
* seek:                                  Common Msgs (C style).
* shared-memory KLIC:                    Shared-Memory KLIC.
* shell command:                         Misc Unix Messages.
* signal:                                Signals.
* signal sending:                        Misc Unix Messages.
* sine:                                  Floating Arith.
* spy:                                   Spying.
* square root:                           Floating Arith.
* standard input <1>:                    Opening Prolog I/O.
* standard input:                        I/O Opening.
* standard order:                        Comparison and Hashing.
* standard output <1>:                   Opening Prolog I/O.
* standard output:                       I/O Opening.
* stdio:                                 I/O Opening.
* stream:                                Merging.
* string:                                Strings.
* string input:                          Input Msgs (C style).
* string output:                         Output Msgs (C style).
* structure:                             Structured Data.
* subterm:                               Display Control.
* suspended goal:                        Dumping Goals.
* symbol:                                Symbolic Atoms.
* symbolic atom:                         Symbolic Atoms.
* synchronization:                       Common Msgs (C style).
* tangent:                               Floating Arith.
* time:                                  Timer.
* timer:                                 Timer.
* trace display:                         Display Control.
* tracing:                               Tracing.
* trigonometric function:                Floating Arith.
* unbound:                               Debugging.
* unification:                           Unification.
* Unix interface:                        Unix.
* unlink:                                Files & Dirs.
* update:                                Macros for Paired Arguments.
* vector:                                Vectors.
* verbose print:                         Display Control.
* wrapped term:                          Wrapped Terms.
* writing out:                           Output Msgs (C style).



Tag Table:
Node: Top468
Node: Copying9773
Node: Introduction14938
Node: Description16070
Node: Predicates and Methods16433
Node: Messages18663
Node: Argument Modes20041
Node: Reporting Bugs20662
Node: Language21305
Node: Basics22707
Node: Predicates24324
Node: Modules26574
Node: Goals27434
Node: Initial Goal28470
Node: Generic Objects28975
Node: Creating Objects30258
Node: Guard Methods30786
Node: Body Methods31583
Node: Priority32312
Node: Alternatively33929
Node: Argument Pair Notation35372
Node: Paired Arguments35820
Node: Macros for Paired Arguments39425
Node: Usage of Paired Arguments40611
Node: Inline C Code41308
Node: Top Insertion42188
Node: Guard Insertion43131
Node: C-Level Rep45781
Node: Examples of Inline47025
Node: Hints of Inline48272
Node: Builtin and Library49716
Node: Common Operations50538
Node: Unification51091
Node: Synchronization51879
Node: Comparison and Hashing52107
Node: Execution Status55443
Node: Debugging56268
Node: Atomic Data57560
Node: Symbolic Atoms58633
Node: Notation of Atoms59051
Node: Symbolic Atom Operation60682
Node: Integers62317
Node: Notation of Integers62889
Node: Integer Arith64582
Node: Integer Comp66486
Node: Floating Points67367
Node: Notation of Floats68006
Node: Creating Floats68631
Node: Floating Arith69323
Node: Floating Comp72062
Node: Structured Data73698
Node: Functors74173
Node: Notation of Functors74703
Node: Functor Operation75366
Node: Lists78106
Node: Notation of Lists79275
Node: Merging80708
Node: Vectors85631
Node: Notation of Vectors86268
Node: Creating Vectors86793
Node: Predicates on Vectors87836
Node: Strings90309
Node: Notation of Strings91021
Node: Creating Strings92755
Node: Predicates on Strings94089
Node: Executable Code97277
Node: Module Type97760
Node: Predicate Type98547
Node: Unix101072
Node: Unix Stream102015
Node: I/O Opening103531
Node: Sockets105026
Node: Files & Dirs107590
Node: Signals109721
Node: Misc Unix Messages110575
Node: Predicate Interface112776
Node: Input and Output113806
Node: C-like I/O114524
Node: Common Msgs (C style)115260
Node: Input Msgs (C style)117046
Node: Output Msgs (C style)118338
Node: Prolog I/O119567
Node: Opening Prolog I/O120588
Node: Common Msgs (Prolog style)122573
Node: Input Msgs (Prolog style)123419
Node: Output Msgs (Prolog style)124905
Node: Wrapped Terms127140
Node: System Control129919
Node: Timer131397
Node: Random Numbers134340
Node: Using KLIC135307
Node: Compiling135782
Node: Command for Compilation136287
Node: Compiler Options137818
Node: Mechanism of Compilation140920
Node: Running142431
Node: Runtime Switches142959
Node: Tracing145781
Node: Preparing for Trace146713
Node: Trace Ports147585
Node: Output of Tracer149627
Node: Controlling Trace154419
Node: Goal Control155100
Node: Subgoal Control155872
Node: Predicate Control156797
Node: Spying158506
Node: Port Control159370
Node: Display Control160642
Node: Dumping Goals163454
Node: Misc Trace Commands163932
Node: Perpetual Suspension164711
Node: Install165633
Node: Configuration166496
Node: Make All168346
Node: Make Tests168642
Node: Make Install169111
Node: Make Distclean169432
Node: Troubles169931
Node: Distributed KLIC171263
Node: Installation of Distributed KLIC172263
Node: Compiling Programs for Distributed KLIC173718
Node: Running Programs of Distributed KLIC174239
Node: Setting Up PVM174554
Node: Runtime Options for Distributed KLIC175556
Node: Known Bugs of Distributed KLIC177474
Node: Shared-Memory KLIC177909
Node: Installation of Shared-Memory KLIC178563
Node: Compiling Programs for Shared-Memory KLIC179301
Node: Running Programs of Shared-Memory KLIC179839
Node: Runtime Options for Shared-Memory KLIC180149
Node: Known Bugs of Shared-Memory KLIC180936
Node: Type Index181199
Node: Predicate Index181859
Node: Module Index193644
Node: Concepts194121

End Tag Table
